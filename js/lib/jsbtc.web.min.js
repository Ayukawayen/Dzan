var jsbtc = function(A) {
    var i = {};

    function e(t) {
        if (i[t]) return i[t].exports;
        var I = i[t] = {
            i: t,
            l: !1,
            exports: {}
        };
        return A[t].call(I.exports, I, I.exports, e), I.l = !0, I.exports
    }
    return e.m = A, e.c = i, e.d = function(A, i, t) {
        e.o(A, i) || Object.defineProperty(A, i, {
            configurable: !1,
            enumerable: !0,
            get: t
        })
    }, e.r = function(A) {
        Object.defineProperty(A, "__esModule", {
            value: !0
        })
    }, e.n = function(A) {
        var i = A && A.__esModule ? function() {
            return A.default
        } : function() {
            return A
        };
        return e.d(i, "a", i), i
    }, e.o = function(A, i) {
        return Object.prototype.hasOwnProperty.call(A, i)
    }, e.p = "", e(e.s = 25)
}([function(A, i, e) {
    "use strict";
    (function(A) {
        var t = e(21),
            I = e(20),
            g = e(19);

        function r() {
            return n.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
        }

        function o(A, i) {
            if (r() < i) throw new RangeError("Invalid typed array length");
            return n.TYPED_ARRAY_SUPPORT ? (A = new Uint8Array(i)).__proto__ = n.prototype : (null === A && (A = new n(i)), A.length = i), A
        }

        function n(A, i, e) {
            if (!(n.TYPED_ARRAY_SUPPORT || this instanceof n)) return new n(A, i, e);
            if ("number" == typeof A) {
                if ("string" == typeof i) throw new Error("If encoding is specified then the first argument must be a string");
                return s(this, A)
            }
            return B(this, A, i, e)
        }

        function B(A, i, e, t) {
            if ("number" == typeof i) throw new TypeError('"value" argument must not be a number');
            return "undefined" != typeof ArrayBuffer && i instanceof ArrayBuffer ? function(A, i, e, t) {
                if (i.byteLength, e < 0 || i.byteLength < e) throw new RangeError("'offset' is out of bounds");
                if (i.byteLength < e + (t || 0)) throw new RangeError("'length' is out of bounds");
                i = void 0 === e && void 0 === t ? new Uint8Array(i) : void 0 === t ? new Uint8Array(i, e) : new Uint8Array(i, e, t);
                n.TYPED_ARRAY_SUPPORT ? (A = i).__proto__ = n.prototype : A = E(A, i);
                return A
            }(A, i, e, t) : "string" == typeof i ? function(A, i, e) {
                "string" == typeof e && "" !== e || (e = "utf8");
                if (!n.isEncoding(e)) throw new TypeError('"encoding" must be a valid string encoding');
                var t = 0 | Q(i, e),
                    I = (A = o(A, t)).write(i, e);
                I !== t && (A = A.slice(0, I));
                return A
            }(A, i, e) : function(A, i) {
                if (n.isBuffer(i)) {
                    var e = 0 | C(i.length);
                    return 0 === (A = o(A, e)).length ? A : (i.copy(A, 0, 0, e), A)
                }
                if (i) {
                    if ("undefined" != typeof ArrayBuffer && i.buffer instanceof ArrayBuffer || "length" in i) return "number" != typeof i.length || (t = i.length) != t ? o(A, 0) : E(A, i);
                    if ("Buffer" === i.type && g(i.data)) return E(A, i.data)
                }
                var t;
                throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
            }(A, i)
        }

        function a(A) {
            if ("number" != typeof A) throw new TypeError('"size" argument must be a number');
            if (A < 0) throw new RangeError('"size" argument must not be negative')
        }

        function s(A, i) {
            if (a(i), A = o(A, i < 0 ? 0 : 0 | C(i)), !n.TYPED_ARRAY_SUPPORT)
                for (var e = 0; e < i; ++e) A[e] = 0;
            return A
        }

        function E(A, i) {
            var e = i.length < 0 ? 0 : 0 | C(i.length);
            A = o(A, e);
            for (var t = 0; t < e; t += 1) A[t] = 255 & i[t];
            return A
        }

        function C(A) {
            if (A >= r()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + r().toString(16) + " bytes");
            return 0 | A
        }

        function Q(A, i) {
            if (n.isBuffer(A)) return A.length;
            if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(A) || A instanceof ArrayBuffer)) return A.byteLength;
            "string" != typeof A && (A = "" + A);
            var e = A.length;
            if (0 === e) return 0;
            for (var t = !1;;) switch (i) {
                case "ascii":
                case "latin1":
                case "binary":
                    return e;
                case "utf8":
                case "utf-8":
                case void 0:
                    return U(A).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return 2 * e;
                case "hex":
                    return e >>> 1;
                case "base64":
                    return Y(A).length;
                default:
                    if (t) return U(A).length;
                    i = ("" + i).toLowerCase(), t = !0
            }
        }

        function h(A, i, e) {
            var t = !1;
            if ((void 0 === i || i < 0) && (i = 0), i > this.length) return "";
            if ((void 0 === e || e > this.length) && (e = this.length), e <= 0) return "";
            if ((e >>>= 0) <= (i >>>= 0)) return "";
            for (A || (A = "utf8");;) switch (A) {
                case "hex":
                    return F(this, i, e);
                case "utf8":
                case "utf-8":
                    return m(this, i, e);
                case "ascii":
                    return S(this, i, e);
                case "latin1":
                case "binary":
                    return M(this, i, e);
                case "base64":
                    return k(this, i, e);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return N(this, i, e);
                default:
                    if (t) throw new TypeError("Unknown encoding: " + A);
                    A = (A + "").toLowerCase(), t = !0
            }
        }

        function c(A, i, e) {
            var t = A[i];
            A[i] = A[e], A[e] = t
        }

        function l(A, i, e, t, I) {
            if (0 === A.length) return -1;
            if ("string" == typeof e ? (t = e, e = 0) : e > 2147483647 ? e = 2147483647 : e < -2147483648 && (e = -2147483648), e = +e, isNaN(e) && (e = I ? 0 : A.length - 1), e < 0 && (e = A.length + e), e >= A.length) {
                if (I) return -1;
                e = A.length - 1
            } else if (e < 0) {
                if (!I) return -1;
                e = 0
            }
            if ("string" == typeof i && (i = n.from(i, t)), n.isBuffer(i)) return 0 === i.length ? -1 : u(A, i, e, t, I);
            if ("number" == typeof i) return i &= 255, n.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? I ? Uint8Array.prototype.indexOf.call(A, i, e) : Uint8Array.prototype.lastIndexOf.call(A, i, e) : u(A, [i], e, t, I);
            throw new TypeError("val must be string, number or Buffer")
        }

        function u(A, i, e, t, I) {
            var g, r = 1,
                o = A.length,
                n = i.length;
            if (void 0 !== t && ("ucs2" === (t = String(t).toLowerCase()) || "ucs-2" === t || "utf16le" === t || "utf-16le" === t)) {
                if (A.length < 2 || i.length < 2) return -1;
                r = 2, o /= 2, n /= 2, e /= 2
            }

            function B(A, i) {
                return 1 === r ? A[i] : A.readUInt16BE(i * r)
            }
            if (I) {
                var a = -1;
                for (g = e; g < o; g++)
                    if (B(A, g) === B(i, -1 === a ? 0 : g - a)) {
                        if (-1 === a && (a = g), g - a + 1 === n) return a * r
                    } else -1 !== a && (g -= g - a), a = -1
            } else
                for (e + n > o && (e = o - n), g = e; g >= 0; g--) {
                    for (var s = !0, E = 0; E < n; E++)
                        if (B(A, g + E) !== B(i, E)) {
                            s = !1;
                            break
                        }
                    if (s) return g
                }
            return -1
        }

        function d(A, i, e, t) {
            e = Number(e) || 0;
            var I = A.length - e;
            t ? (t = Number(t)) > I && (t = I) : t = I;
            var g = i.length;
            if (g % 2 != 0) throw new TypeError("Invalid hex string");
            t > g / 2 && (t = g / 2);
            for (var r = 0; r < t; ++r) {
                var o = parseInt(i.substr(2 * r, 2), 16);
                if (isNaN(o)) return r;
                A[e + r] = o
            }
            return r
        }

        function p(A, i, e, t) {
            return b(U(i, A.length - e), A, e, t)
        }

        function f(A, i, e, t) {
            return b(function(A) {
                for (var i = [], e = 0; e < A.length; ++e) i.push(255 & A.charCodeAt(e));
                return i
            }(i), A, e, t)
        }

        function y(A, i, e, t) {
            return f(A, i, e, t)
        }

        function D(A, i, e, t) {
            return b(Y(i), A, e, t)
        }

        function w(A, i, e, t) {
            return b(function(A, i) {
                for (var e, t, I, g = [], r = 0; r < A.length && !((i -= 2) < 0); ++r) e = A.charCodeAt(r), t = e >> 8, I = e % 256, g.push(I), g.push(t);
                return g
            }(i, A.length - e), A, e, t)
        }

        function k(A, i, e) {
            return 0 === i && e === A.length ? t.fromByteArray(A) : t.fromByteArray(A.slice(i, e))
        }

        function m(A, i, e) {
            e = Math.min(A.length, e);
            for (var t = [], I = i; I < e;) {
                var g, r, o, n, B = A[I],
                    a = null,
                    s = B > 239 ? 4 : B > 223 ? 3 : B > 191 ? 2 : 1;
                if (I + s <= e) switch (s) {
                    case 1:
                        B < 128 && (a = B);
                        break;
                    case 2:
                        128 == (192 & (g = A[I + 1])) && (n = (31 & B) << 6 | 63 & g) > 127 && (a = n);
                        break;
                    case 3:
                        g = A[I + 1], r = A[I + 2], 128 == (192 & g) && 128 == (192 & r) && (n = (15 & B) << 12 | (63 & g) << 6 | 63 & r) > 2047 && (n < 55296 || n > 57343) && (a = n);
                        break;
                    case 4:
                        g = A[I + 1], r = A[I + 2], o = A[I + 3], 128 == (192 & g) && 128 == (192 & r) && 128 == (192 & o) && (n = (15 & B) << 18 | (63 & g) << 12 | (63 & r) << 6 | 63 & o) > 65535 && n < 1114112 && (a = n)
                }
                null === a ? (a = 65533, s = 1) : a > 65535 && (a -= 65536, t.push(a >>> 10 & 1023 | 55296), a = 56320 | 1023 & a), t.push(a), I += s
            }
            return function(A) {
                var i = A.length;
                if (i <= 4096) return String.fromCharCode.apply(String, A);
                var e = "",
                    t = 0;
                for (; t < i;) e += String.fromCharCode.apply(String, A.slice(t, t += 4096));
                return e
            }(t)
        }
        i.Buffer = n, i.SlowBuffer = function(A) {
            +A != A && (A = 0);
            return n.alloc(+A)
        }, i.INSPECT_MAX_BYTES = 50, n.TYPED_ARRAY_SUPPORT = void 0 !== A.TYPED_ARRAY_SUPPORT ? A.TYPED_ARRAY_SUPPORT : function() {
            try {
                var A = new Uint8Array(1);
                return A.__proto__ = {
                    __proto__: Uint8Array.prototype,
                    foo: function() {
                        return 42
                    }
                }, 42 === A.foo() && "function" == typeof A.subarray && 0 === A.subarray(1, 1).byteLength
            } catch (A) {
                return !1
            }
        }(), i.kMaxLength = r(), n.poolSize = 8192, n._augment = function(A) {
            return A.__proto__ = n.prototype, A
        }, n.from = function(A, i, e) {
            return B(null, A, i, e)
        }, n.TYPED_ARRAY_SUPPORT && (n.prototype.__proto__ = Uint8Array.prototype, n.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && n[Symbol.species] === n && Object.defineProperty(n, Symbol.species, {
            value: null,
            configurable: !0
        })), n.alloc = function(A, i, e) {
            return function(A, i, e, t) {
                return a(i), i <= 0 ? o(A, i) : void 0 !== e ? "string" == typeof t ? o(A, i).fill(e, t) : o(A, i).fill(e) : o(A, i)
            }(null, A, i, e)
        }, n.allocUnsafe = function(A) {
            return s(null, A)
        }, n.allocUnsafeSlow = function(A) {
            return s(null, A)
        }, n.isBuffer = function(A) {
            return !(null == A || !A._isBuffer)
        }, n.compare = function(A, i) {
            if (!n.isBuffer(A) || !n.isBuffer(i)) throw new TypeError("Arguments must be Buffers");
            if (A === i) return 0;
            for (var e = A.length, t = i.length, I = 0, g = Math.min(e, t); I < g; ++I)
                if (A[I] !== i[I]) {
                    e = A[I], t = i[I];
                    break
                }
            return e < t ? -1 : t < e ? 1 : 0
        }, n.isEncoding = function(A) {
            switch (String(A).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return !0;
                default:
                    return !1
            }
        }, n.concat = function(A, i) {
            if (!g(A)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === A.length) return n.alloc(0);
            var e;
            if (void 0 === i)
                for (i = 0, e = 0; e < A.length; ++e) i += A[e].length;
            var t = n.allocUnsafe(i),
                I = 0;
            for (e = 0; e < A.length; ++e) {
                var r = A[e];
                if (!n.isBuffer(r)) throw new TypeError('"list" argument must be an Array of Buffers');
                r.copy(t, I), I += r.length
            }
            return t
        }, n.byteLength = Q, n.prototype._isBuffer = !0, n.prototype.swap16 = function() {
            var A = this.length;
            if (A % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var i = 0; i < A; i += 2) c(this, i, i + 1);
            return this
        }, n.prototype.swap32 = function() {
            var A = this.length;
            if (A % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var i = 0; i < A; i += 4) c(this, i, i + 3), c(this, i + 1, i + 2);
            return this
        }, n.prototype.swap64 = function() {
            var A = this.length;
            if (A % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var i = 0; i < A; i += 8) c(this, i, i + 7), c(this, i + 1, i + 6), c(this, i + 2, i + 5), c(this, i + 3, i + 4);
            return this
        }, n.prototype.toString = function() {
            var A = 0 | this.length;
            return 0 === A ? "" : 0 === arguments.length ? m(this, 0, A) : h.apply(this, arguments)
        }, n.prototype.equals = function(A) {
            if (!n.isBuffer(A)) throw new TypeError("Argument must be a Buffer");
            return this === A || 0 === n.compare(this, A)
        }, n.prototype.inspect = function() {
            var A = "",
                e = i.INSPECT_MAX_BYTES;
            return this.length > 0 && (A = this.toString("hex", 0, e).match(/.{2}/g).join(" "), this.length > e && (A += " ... ")), "<Buffer " + A + ">"
        }, n.prototype.compare = function(A, i, e, t, I) {
            if (!n.isBuffer(A)) throw new TypeError("Argument must be a Buffer");
            if (void 0 === i && (i = 0), void 0 === e && (e = A ? A.length : 0), void 0 === t && (t = 0), void 0 === I && (I = this.length), i < 0 || e > A.length || t < 0 || I > this.length) throw new RangeError("out of range index");
            if (t >= I && i >= e) return 0;
            if (t >= I) return -1;
            if (i >= e) return 1;
            if (this === A) return 0;
            for (var g = (I >>>= 0) - (t >>>= 0), r = (e >>>= 0) - (i >>>= 0), o = Math.min(g, r), B = this.slice(t, I), a = A.slice(i, e), s = 0; s < o; ++s)
                if (B[s] !== a[s]) {
                    g = B[s], r = a[s];
                    break
                }
            return g < r ? -1 : r < g ? 1 : 0
        }, n.prototype.includes = function(A, i, e) {
            return -1 !== this.indexOf(A, i, e)
        }, n.prototype.indexOf = function(A, i, e) {
            return l(this, A, i, e, !0)
        }, n.prototype.lastIndexOf = function(A, i, e) {
            return l(this, A, i, e, !1)
        }, n.prototype.write = function(A, i, e, t) {
            if (void 0 === i) t = "utf8", e = this.length, i = 0;
            else if (void 0 === e && "string" == typeof i) t = i, e = this.length, i = 0;
            else {
                if (!isFinite(i)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                i |= 0, isFinite(e) ? (e |= 0, void 0 === t && (t = "utf8")) : (t = e, e = void 0)
            }
            var I = this.length - i;
            if ((void 0 === e || e > I) && (e = I), A.length > 0 && (e < 0 || i < 0) || i > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            t || (t = "utf8");
            for (var g = !1;;) switch (t) {
                case "hex":
                    return d(this, A, i, e);
                case "utf8":
                case "utf-8":
                    return p(this, A, i, e);
                case "ascii":
                    return f(this, A, i, e);
                case "latin1":
                case "binary":
                    return y(this, A, i, e);
                case "base64":
                    return D(this, A, i, e);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return w(this, A, i, e);
                default:
                    if (g) throw new TypeError("Unknown encoding: " + t);
                    t = ("" + t).toLowerCase(), g = !0
            }
        }, n.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        };

        function S(A, i, e) {
            var t = "";
            e = Math.min(A.length, e);
            for (var I = i; I < e; ++I) t += String.fromCharCode(127 & A[I]);
            return t
        }

        function M(A, i, e) {
            var t = "";
            e = Math.min(A.length, e);
            for (var I = i; I < e; ++I) t += String.fromCharCode(A[I]);
            return t
        }

        function F(A, i, e) {
            var t = A.length;
            (!i || i < 0) && (i = 0), (!e || e < 0 || e > t) && (e = t);
            for (var I = "", g = i; g < e; ++g) I += J(A[g]);
            return I
        }

        function N(A, i, e) {
            for (var t = A.slice(i, e), I = "", g = 0; g < t.length; g += 2) I += String.fromCharCode(t[g] + 256 * t[g + 1]);
            return I
        }

        function G(A, i, e) {
            if (A % 1 != 0 || A < 0) throw new RangeError("offset is not uint");
            if (A + i > e) throw new RangeError("Trying to access beyond buffer length")
        }

        function R(A, i, e, t, I, g) {
            if (!n.isBuffer(A)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (i > I || i < g) throw new RangeError('"value" argument is out of bounds');
            if (e + t > A.length) throw new RangeError("Index out of range")
        }

        function K(A, i, e, t) {
            i < 0 && (i = 65535 + i + 1);
            for (var I = 0, g = Math.min(A.length - e, 2); I < g; ++I) A[e + I] = (i & 255 << 8 * (t ? I : 1 - I)) >>> 8 * (t ? I : 1 - I)
        }

        function v(A, i, e, t) {
            i < 0 && (i = 4294967295 + i + 1);
            for (var I = 0, g = Math.min(A.length - e, 4); I < g; ++I) A[e + I] = i >>> 8 * (t ? I : 3 - I) & 255
        }

        function H(A, i, e, t, I, g) {
            if (e + t > A.length) throw new RangeError("Index out of range");
            if (e < 0) throw new RangeError("Index out of range")
        }

        function q(A, i, e, t, g) {
            return g || H(A, 0, e, 4), I.write(A, i, e, t, 23, 4), e + 4
        }

        function P(A, i, e, t, g) {
            return g || H(A, 0, e, 8), I.write(A, i, e, t, 52, 8), e + 8
        }
        n.prototype.slice = function(A, i) {
            var e, t = this.length;
            if ((A = ~~A) < 0 ? (A += t) < 0 && (A = 0) : A > t && (A = t), (i = void 0 === i ? t : ~~i) < 0 ? (i += t) < 0 && (i = 0) : i > t && (i = t), i < A && (i = A), n.TYPED_ARRAY_SUPPORT)(e = this.subarray(A, i)).__proto__ = n.prototype;
            else {
                var I = i - A;
                e = new n(I, void 0);
                for (var g = 0; g < I; ++g) e[g] = this[g + A]
            }
            return e
        }, n.prototype.readUIntLE = function(A, i, e) {
            A |= 0, i |= 0, e || G(A, i, this.length);
            for (var t = this[A], I = 1, g = 0; ++g < i && (I *= 256);) t += this[A + g] * I;
            return t
        }, n.prototype.readUIntBE = function(A, i, e) {
            A |= 0, i |= 0, e || G(A, i, this.length);
            for (var t = this[A + --i], I = 1; i > 0 && (I *= 256);) t += this[A + --i] * I;
            return t
        }, n.prototype.readUInt8 = function(A, i) {
            return i || G(A, 1, this.length), this[A]
        }, n.prototype.readUInt16LE = function(A, i) {
            return i || G(A, 2, this.length), this[A] | this[A + 1] << 8
        }, n.prototype.readUInt16BE = function(A, i) {
            return i || G(A, 2, this.length), this[A] << 8 | this[A + 1]
        }, n.prototype.readUInt32LE = function(A, i) {
            return i || G(A, 4, this.length), (this[A] | this[A + 1] << 8 | this[A + 2] << 16) + 16777216 * this[A + 3]
        }, n.prototype.readUInt32BE = function(A, i) {
            return i || G(A, 4, this.length), 16777216 * this[A] + (this[A + 1] << 16 | this[A + 2] << 8 | this[A + 3])
        }, n.prototype.readIntLE = function(A, i, e) {
            A |= 0, i |= 0, e || G(A, i, this.length);
            for (var t = this[A], I = 1, g = 0; ++g < i && (I *= 256);) t += this[A + g] * I;
            return t >= (I *= 128) && (t -= Math.pow(2, 8 * i)), t
        }, n.prototype.readIntBE = function(A, i, e) {
            A |= 0, i |= 0, e || G(A, i, this.length);
            for (var t = i, I = 1, g = this[A + --t]; t > 0 && (I *= 256);) g += this[A + --t] * I;
            return g >= (I *= 128) && (g -= Math.pow(2, 8 * i)), g
        }, n.prototype.readInt8 = function(A, i) {
            return i || G(A, 1, this.length), 128 & this[A] ? -1 * (255 - this[A] + 1) : this[A]
        }, n.prototype.readInt16LE = function(A, i) {
            i || G(A, 2, this.length);
            var e = this[A] | this[A + 1] << 8;
            return 32768 & e ? 4294901760 | e : e
        }, n.prototype.readInt16BE = function(A, i) {
            i || G(A, 2, this.length);
            var e = this[A + 1] | this[A] << 8;
            return 32768 & e ? 4294901760 | e : e
        }, n.prototype.readInt32LE = function(A, i) {
            return i || G(A, 4, this.length), this[A] | this[A + 1] << 8 | this[A + 2] << 16 | this[A + 3] << 24
        }, n.prototype.readInt32BE = function(A, i) {
            return i || G(A, 4, this.length), this[A] << 24 | this[A + 1] << 16 | this[A + 2] << 8 | this[A + 3]
        }, n.prototype.readFloatLE = function(A, i) {
            return i || G(A, 4, this.length), I.read(this, A, !0, 23, 4)
        }, n.prototype.readFloatBE = function(A, i) {
            return i || G(A, 4, this.length), I.read(this, A, !1, 23, 4)
        }, n.prototype.readDoubleLE = function(A, i) {
            return i || G(A, 8, this.length), I.read(this, A, !0, 52, 8)
        }, n.prototype.readDoubleBE = function(A, i) {
            return i || G(A, 8, this.length), I.read(this, A, !1, 52, 8)
        }, n.prototype.writeUIntLE = function(A, i, e, t) {
            (A = +A, i |= 0, e |= 0, t) || R(this, A, i, e, Math.pow(2, 8 * e) - 1, 0);
            var I = 1,
                g = 0;
            for (this[i] = 255 & A; ++g < e && (I *= 256);) this[i + g] = A / I & 255;
            return i + e
        }, n.prototype.writeUIntBE = function(A, i, e, t) {
            (A = +A, i |= 0, e |= 0, t) || R(this, A, i, e, Math.pow(2, 8 * e) - 1, 0);
            var I = e - 1,
                g = 1;
            for (this[i + I] = 255 & A; --I >= 0 && (g *= 256);) this[i + I] = A / g & 255;
            return i + e
        }, n.prototype.writeUInt8 = function(A, i, e) {
            return A = +A, i |= 0, e || R(this, A, i, 1, 255, 0), n.TYPED_ARRAY_SUPPORT || (A = Math.floor(A)), this[i] = 255 & A, i + 1
        }, n.prototype.writeUInt16LE = function(A, i, e) {
            return A = +A, i |= 0, e || R(this, A, i, 2, 65535, 0), n.TYPED_ARRAY_SUPPORT ? (this[i] = 255 & A, this[i + 1] = A >>> 8) : K(this, A, i, !0), i + 2
        }, n.prototype.writeUInt16BE = function(A, i, e) {
            return A = +A, i |= 0, e || R(this, A, i, 2, 65535, 0), n.TYPED_ARRAY_SUPPORT ? (this[i] = A >>> 8, this[i + 1] = 255 & A) : K(this, A, i, !1), i + 2
        }, n.prototype.writeUInt32LE = function(A, i, e) {
            return A = +A, i |= 0, e || R(this, A, i, 4, 4294967295, 0), n.TYPED_ARRAY_SUPPORT ? (this[i + 3] = A >>> 24, this[i + 2] = A >>> 16, this[i + 1] = A >>> 8, this[i] = 255 & A) : v(this, A, i, !0), i + 4
        }, n.prototype.writeUInt32BE = function(A, i, e) {
            return A = +A, i |= 0, e || R(this, A, i, 4, 4294967295, 0), n.TYPED_ARRAY_SUPPORT ? (this[i] = A >>> 24, this[i + 1] = A >>> 16, this[i + 2] = A >>> 8, this[i + 3] = 255 & A) : v(this, A, i, !1), i + 4
        }, n.prototype.writeIntLE = function(A, i, e, t) {
            if (A = +A, i |= 0, !t) {
                var I = Math.pow(2, 8 * e - 1);
                R(this, A, i, e, I - 1, -I)
            }
            var g = 0,
                r = 1,
                o = 0;
            for (this[i] = 255 & A; ++g < e && (r *= 256);) A < 0 && 0 === o && 0 !== this[i + g - 1] && (o = 1), this[i + g] = (A / r >> 0) - o & 255;
            return i + e
        }, n.prototype.writeIntBE = function(A, i, e, t) {
            if (A = +A, i |= 0, !t) {
                var I = Math.pow(2, 8 * e - 1);
                R(this, A, i, e, I - 1, -I)
            }
            var g = e - 1,
                r = 1,
                o = 0;
            for (this[i + g] = 255 & A; --g >= 0 && (r *= 256);) A < 0 && 0 === o && 0 !== this[i + g + 1] && (o = 1), this[i + g] = (A / r >> 0) - o & 255;
            return i + e
        }, n.prototype.writeInt8 = function(A, i, e) {
            return A = +A, i |= 0, e || R(this, A, i, 1, 127, -128), n.TYPED_ARRAY_SUPPORT || (A = Math.floor(A)), A < 0 && (A = 255 + A + 1), this[i] = 255 & A, i + 1
        }, n.prototype.writeInt16LE = function(A, i, e) {
            return A = +A, i |= 0, e || R(this, A, i, 2, 32767, -32768), n.TYPED_ARRAY_SUPPORT ? (this[i] = 255 & A, this[i + 1] = A >>> 8) : K(this, A, i, !0), i + 2
        }, n.prototype.writeInt16BE = function(A, i, e) {
            return A = +A, i |= 0, e || R(this, A, i, 2, 32767, -32768), n.TYPED_ARRAY_SUPPORT ? (this[i] = A >>> 8, this[i + 1] = 255 & A) : K(this, A, i, !1), i + 2
        }, n.prototype.writeInt32LE = function(A, i, e) {
            return A = +A, i |= 0, e || R(this, A, i, 4, 2147483647, -2147483648), n.TYPED_ARRAY_SUPPORT ? (this[i] = 255 & A, this[i + 1] = A >>> 8, this[i + 2] = A >>> 16, this[i + 3] = A >>> 24) : v(this, A, i, !0), i + 4
        }, n.prototype.writeInt32BE = function(A, i, e) {
            return A = +A, i |= 0, e || R(this, A, i, 4, 2147483647, -2147483648), A < 0 && (A = 4294967295 + A + 1), n.TYPED_ARRAY_SUPPORT ? (this[i] = A >>> 24, this[i + 1] = A >>> 16, this[i + 2] = A >>> 8, this[i + 3] = 255 & A) : v(this, A, i, !1), i + 4
        }, n.prototype.writeFloatLE = function(A, i, e) {
            return q(this, A, i, !0, e)
        }, n.prototype.writeFloatBE = function(A, i, e) {
            return q(this, A, i, !1, e)
        }, n.prototype.writeDoubleLE = function(A, i, e) {
            return P(this, A, i, !0, e)
        }, n.prototype.writeDoubleBE = function(A, i, e) {
            return P(this, A, i, !1, e)
        }, n.prototype.copy = function(A, i, e, t) {
            if (e || (e = 0), t || 0 === t || (t = this.length), i >= A.length && (i = A.length), i || (i = 0), t > 0 && t < e && (t = e), t === e) return 0;
            if (0 === A.length || 0 === this.length) return 0;
            if (i < 0) throw new RangeError("targetStart out of bounds");
            if (e < 0 || e >= this.length) throw new RangeError("sourceStart out of bounds");
            if (t < 0) throw new RangeError("sourceEnd out of bounds");
            t > this.length && (t = this.length), A.length - i < t - e && (t = A.length - i + e);
            var I, g = t - e;
            if (this === A && e < i && i < t)
                for (I = g - 1; I >= 0; --I) A[I + i] = this[I + e];
            else if (g < 1e3 || !n.TYPED_ARRAY_SUPPORT)
                for (I = 0; I < g; ++I) A[I + i] = this[I + e];
            else Uint8Array.prototype.set.call(A, this.subarray(e, e + g), i);
            return g
        }, n.prototype.fill = function(A, i, e, t) {
            if ("string" == typeof A) {
                if ("string" == typeof i ? (t = i, i = 0, e = this.length) : "string" == typeof e && (t = e, e = this.length), 1 === A.length) {
                    var I = A.charCodeAt(0);
                    I < 256 && (A = I)
                }
                if (void 0 !== t && "string" != typeof t) throw new TypeError("encoding must be a string");
                if ("string" == typeof t && !n.isEncoding(t)) throw new TypeError("Unknown encoding: " + t)
            } else "number" == typeof A && (A &= 255);
            if (i < 0 || this.length < i || this.length < e) throw new RangeError("Out of range index");
            if (e <= i) return this;
            var g;
            if (i >>>= 0, e = void 0 === e ? this.length : e >>> 0, A || (A = 0), "number" == typeof A)
                for (g = i; g < e; ++g) this[g] = A;
            else {
                var r = n.isBuffer(A) ? A : U(new n(A, t).toString()),
                    o = r.length;
                for (g = 0; g < e - i; ++g) this[g + i] = r[g % o]
            }
            return this
        };
        var T = /[^+\/0-9A-Za-z-_]/g;

        function J(A) {
            return A < 16 ? "0" + A.toString(16) : A.toString(16)
        }

        function U(A, i) {
            var e;
            i = i || 1 / 0;
            for (var t = A.length, I = null, g = [], r = 0; r < t; ++r) {
                if ((e = A.charCodeAt(r)) > 55295 && e < 57344) {
                    if (!I) {
                        if (e > 56319) {
                            (i -= 3) > -1 && g.push(239, 191, 189);
                            continue
                        }
                        if (r + 1 === t) {
                            (i -= 3) > -1 && g.push(239, 191, 189);
                            continue
                        }
                        I = e;
                        continue
                    }
                    if (e < 56320) {
                        (i -= 3) > -1 && g.push(239, 191, 189), I = e;
                        continue
                    }
                    e = 65536 + (I - 55296 << 10 | e - 56320)
                } else I && (i -= 3) > -1 && g.push(239, 191, 189);
                if (I = null, e < 128) {
                    if ((i -= 1) < 0) break;
                    g.push(e)
                } else if (e < 2048) {
                    if ((i -= 2) < 0) break;
                    g.push(e >> 6 | 192, 63 & e | 128)
                } else if (e < 65536) {
                    if ((i -= 3) < 0) break;
                    g.push(e >> 12 | 224, e >> 6 & 63 | 128, 63 & e | 128)
                } else {
                    if (!(e < 1114112)) throw new Error("Invalid code point");
                    if ((i -= 4) < 0) break;
                    g.push(e >> 18 | 240, e >> 12 & 63 | 128, e >> 6 & 63 | 128, 63 & e | 128)
                }
            }
            return g
        }

        function Y(A) {
            return t.toByteArray(function(A) {
                if ((A = function(A) {
                        return A.trim ? A.trim() : A.replace(/^\s+|\s+$/g, "")
                    }(A).replace(T, "")).length < 2) return "";
                for (; A.length % 4 != 0;) A += "=";
                return A
            }(A))
        }

        function b(A, i, e, t) {
            for (var I = 0; I < t && !(I + e >= i.length || I >= A.length); ++I) i[I + e] = A[I];
            return I
        }
    }).call(this, e(1))
}, function(A, i) {
    var e;
    e = function() {
        return this
    }();
    try {
        e = e || Function("return this")() || (0, eval)("this")
    } catch (A) {
        "object" == typeof window && (e = window)
    }
    A.exports = e
}, function(A, i) {
    A.exports = function(A) {
        let i = A.Buffer,
            e = (A.defArgs, A.getBuffer, i.from, i.concat, A.OPCODE, A.defArgs);
        class t {
            constructor(i = {}) {
                e(i, {
                    from: null,
                    passphrase: "",
                    path: null,
                    testnet: !1,
                    strength: 256,
                    threshold: 1,
                    shares: 1,
                    wordList: A.BIP39_WORDLIST,
                    addressType: null,
                    hardenedAddresses: !1,
                    account: 0,
                    chain: 0
                }), this.account = i.account, this.chain = i.chain, this.hardenedAddresses = i.hardenedAddresses, "BIP84" === i.path ? (this.pathType = "BIP84", this.path = `m/84'/0'/${this.account}'/${this.chain}`, this.__account_path = `m/84'/0'/${this.account}'`) : "BIP49" === i.path ? (this.pathType = "BIP49", this.path = `m/49'/0'/${this.account}'/${this.chain}`, this.__account_path = `m/49'/0'/${this.account}'`) : "BIP44" === i.path ? (this.pathType = "BIP44", this.path = `m/44'/0'/${this.account}'/${this.chain}`, this.__account_path = `m/44'/0'/${this.account}'`) : null !== i.path ? (this.pathType = "custom", this.path = i.path) : (this.pathType = null, this.path = null);
                let t = i.from;
                this.from = t;
                let I = null;
                if (null === t) {
                    let e = A.generateEntropy({
                        strength: i.strength
                    });
                    this.mnemonic = A.entropyToMnemonic(e, {
                        wordList: i.wordList
                    }), this.seed = A.mnemonicToSeed(this.mnemonic, {
                        hex: !0,
                        wordList: i.wordList,
                        passphrase: i.passphrase
                    }), this.passphrase = i.passphrase, t = A.createMasterXPrivateKey(this.seed, {
                        testnet: i.testnet
                    }), null === this.pathType && (this.pathType = "BIP84", this.path = `m/84'/0'/${this.account}'/${this.chain}`, this.__account_path = `m/84'/0'/${this.account}'`), null !== this.pathType && "custom" !== this.pathType && (t = A.BIP32_XKeyToPathXKey(t, this.pathType)), I = "xPriv"
                } else {
                    if (!A.isString(t)) throw new Error("invalid initial data");
                    if (A.isXPrivateKeyValid(t)) null === this.pathType && (this.pathType = A.xKeyDerivationType(t), "BIP84" === this.pathType ? (this.path = `m/84'/0'/${this.account}'/${this.chain}`, this.__account_path = `m/84'/0'/${this.account}'`) : "BIP49" === this.pathType ? (this.path = `m/49'/0'/${this.account}'/${this.chain}`, this.__account_path = `m/49'/0'/${this.account}'`) : "BIP44" === this.pathType ? (this.path = `m/44'/0'/${this.account}'/${this.chain}`, this.__account_path = `m/44'/0'/${this.account}'`) : this.path = "m"), null !== this.pathType && "custom" !== this.pathType && (t = A.BIP32_XKeyToPathXKey(A.pathXKeyTo_BIP32_XKey(t), this.pathType)), I = "xPriv";
                    else if (A.isXPublicKeyValid(t)) null === this.pathType && (this.pathType = A.xKeyDerivationType(t), "BIP84" === this.pathType ? (this.path = `m/84'/0'/${this.account}'/${this.chain}`, this.__account_path = `m/84'/0'/${this.account}'`) : "BIP49" === this.pathType ? (this.path = `m/49'/0'/${this.account}'/${this.chain}`, this.__account_path = `m/49'/0'/${this.account}'`) : "BIP44" === this.pathType ? (this.path = `m/44'/0'/${this.account}'/${this.chain}`, this.__account_path = `m/44'/0'/${this.account}'`) : this.path = "m"), "custom" !== this.pathType && (t = A.BIP32_XKeyToPathXKey(A.pathXKeyTo_BIP32_XKey(t), this.pathType), I = "xPub", 3 === this.depth && (this.__path = ""));
                    else {
                        if (!A.isMnemonicValid(t, {
                                wordList: i.BIP39_WORDLIST
                            })) throw new Error("invalid mnemonic");
                        this.mnemonic = t, this.seed = A.mnemonicToSeed(this.mnemonic, {
                            hex: !0,
                            wordList: i.wordList,
                            passphrase: i.passphrase
                        }), this.passphrase = i.passphrase, t = A.createMasterXPrivateKey(this.seed, {
                            testnet: i.testnet
                        }), null === this.pathType && (this.pathType = "BIP84", this.path = `m/84'/0'/${this.account}'/${this.chain}`, this.__account_path = `m/84'/0'/${this.account}'`), null !== this.pathType && "custom" !== this.pathType && (t = A.BIP32_XKeyToPathXKey(t, this.pathType)), I = "xPriv"
                    }
                }
                let g = A.decodeBase58(t, {
                    checkSum: !0,
                    hex: !1
                });
                if (this.testnet = "testnet" === A.xKeyNetworkType(g), this.version = g.slice(0, 4).hex(), this.depth = g[4], "custom" !== this.pathType)
                    if (0 === this.depth || 3 === this.depth) {
                        let A = this.path.split("/");
                        this.__path = A.slice(this.depth, 4).join("/")
                    } else this.pathType = "custom", this.path = "m";
                if (this.fingerprint = g.slice(5, 9).hex(), this.child = g.readUIntBE(9, 4), this.chainCode = g.slice(9, 4).hex(), "xPriv" === I ? (0 === this.depth && (this.masterXPrivateKey = t), "custom" !== this.pathType ? (this.accountXPrivateKey = A.deriveXKey(t, this.__path, {
                        subPath: !0
                    }), this.accountXPublicKey = A.xPrivateToXPublicKey(this.accountXPrivateKey), this.accountXPrivateKey = A.deriveXKey(t, this.__path, {
                        subPath: !0
                    }), this.accountXPublicKey = A.xPrivateToXPublicKey(this.accountXPrivateKey), this.externalChainXPrivateKey = A.deriveXKey(t, this.__path + `/${this.chain}`, {
                        subPath: !0
                    }), this.externalChainXPublicKey = A.xPrivateToXPublicKey(this.externalChainXPrivateKey), this.internalChainXPrivateKey = A.deriveXKey(t, this.__path + `/${this.chain+1}`, {
                        subPath: !0
                    }), this.internalChainXPublicKey = A.xPrivateToXPublicKey(this.internalChainXPrivateKey)) : (this.chainXPrivateKey = A.deriveXKey(t, this.path), this.chainXPublicKey = A.xPrivateToXPublicKey(this.chainXPrivateKey))) : "custom" !== this.pathType ? (this.accountXPublicKey = t, this.externalChainXPublicKey = A.deriveXKey(t, this.__path + `/${this.chain}`, {
                        subPath: !0
                    }), this.internalChainXPrivateKey = A.deriveXKey(t, this.__path + `/${this.chain+1}`, {
                        subPath: !0
                    })) : this.chainXPublicKey = A.deriveXKey(t, this.path), null !== this.mnemonic) {
                    if (this.sharesThreshold = i.threshold, this.sharesTotal = i.shares, this.sharesThreshold > this.sharesTotal) throw new Error("Threshold invalid");
                    if (this.sharesTotal > 1) {
                        let e = this.mnemonic.trim().split(/\s+/),
                            t = 11 * e.length % 32;
                        if (this.sharesTotal > 2 ** t - 1) throw new Error(`Maximum ${2**t-1} shares allowed for ${e.length} mnemonic words`);
                        this.mnemonicShares = A.splitMnemonic(i.threshold, i.shares, this.mnemonic, {
                            wordList: i.BIP39_WORDLIST,
                            embeddedIndex: !0
                        })
                    }
                }
                null !== i.addressType ? this.addressType = i.addressType : "BIP84" === this.pathType ? this.addressType = "P2WPKH" : "BIP49" === this.pathType ? this.addressType = "P2SH_P2WPKH" : this.addressType = "P2PKH"
            }
        }
        t.prototype.setChain = function(A) {
            this.chain = A
        }, t.prototype.getAddress = function(i, e = !0) {
            let t = {},
                I = this.hardenedAddresses ? "'" : "";
            if ("custom" !== this.pathType) {
                let g = "m/" + i + I;
                if (t.path = `${this.__account_path}/${this.chain+!e}/${i}${I}`, e)
                    if (void 0 !== this.externalChainXPrivateKey) {
                        let i = A.deriveXKey(this.externalChainXPrivateKey, g);
                        t.privateKey = A.privateFromXPrivateKey(i), t.publicKey = A.privateToPublicKey(t.privateKey)
                    } else {
                        let i = A.deriveXKey(this.externalChainXPublicKey, g);
                        t.publicKey = A.publicFromXPublicKey(i)
                    }
                else if (void 0 !== this.internalChainXPrivateKey) {
                    let i = A.deriveXKey(this.internalChainXPrivateKey, g);
                    t.privateKey = A.privateFromXPrivateKey(i), t.publicKey = A.privateToPublicKey(t.privateKey)
                } else {
                    let i = A.deriveXKey(this.internalChainXPublicKey, g);
                    t.publicKey = A.publicFromXPublicKey(i)
                }
            } else {
                let e = "m/" + i + I;
                if (t.path = this.path + "/" + i + I, void 0 !== this.chainXPrivateKey) {
                    let i = A.deriveXKey(this.chainXPrivateKey, e);
                    t.privateKey = A.privateFromXPrivateKey(i), t.publicKey = A.privateToPublicKey(t.privateKey)
                } else {
                    let i = A.deriveXKey(this.chainXPublicKey, e);
                    t.publicKey = A.publicFromXPublicKey(i)
                }
            }
            return "P2WPKH" === this.addressType ? t.address = A.publicKeyToAddress(t.publicKey, {
                testnet: this.testnet
            }) : "P2SH_P2WPKH" === this.addressType ? t.address = A.publicKeyToAddress(t.publicKey, {
                p2sh_p2wpkh: !0,
                testnet: this.testnet
            }) : "P2PKH" === this.addressType && (t.address = A.publicKeyToAddress(t.publicKey, {
                witnessVersion: null,
                testnet: this.testnet
            })), t
        }, A.Wallet = t
    }
}, function(A, i) {
    A.exports = function(A) {
        let i = A.s2rh,
            e = A.rh2s,
            t = A.Buffer,
            I = (A.BN, A.Buffer.isBuffer),
            g = A.defArgs,
            r = A.getBuffer,
            o = t.from,
            n = t.alloc,
            B = t.concat,
            a = A.OPCODE,
            s = A.isString;
        class E {
            constructor(i = {}) {
                if (g(i, {
                        rawTx: null,
                        format: "decoded",
                        version: 1,
                        lockTime: 0,
                        testnet: !1,
                        autoCommit: !0,
                        keepRawTx: !1
                    }), !["decoded", "raw"].includes(i.format)) throw new Error("format error, raw or decoded allowed");
                if (this.autoCommit = i.autoCommit, this.format = i.format, this.testnet = i.testnet, this.segwit = !1, this.txId = null, this.hash = null, this.version = i.version, this.size = 0, this.vSize = 0, this.bSize = 0, this.vIn = {}, this.vOut = {}, this.rawTx = null, this.blockHash = null, this.confirmations = null, this.time = null, this.blockTime = null, this.blockIndex = null, this.coinbase = !1, this.fee = null, this.data = null, this.amount = null, null === i.rawTx) return;
                let e = r(i.rawTx);
                this.amount = 0;
                let I = 0,
                    o = 0,
                    n = void 0 === e.__offset ? 0 : e.__offset;
                this.version = e.readInt(4);
                let a = e.readVarInt();
                0 === a[0] && (I = 1, this.flag = e.read(1), a = e.readVarInt());
                let s = A.varIntToInt(a);
                for (let i = 0; i < s; i++) this.vIn[i] = {
                    txId: e.read(32),
                    vOut: e.readInt(4),
                    scriptSig: e.read(A.varIntToInt(e.readVarInt())),
                    sequence: e.readInt(4)
                };
                let E = A.varIntToInt(e.readVarInt());
                for (let i = 0; i < E; i++) {
                    this.vOut[i] = {}, this.vOut[i].value = e.readInt(8), this.amount += this.vOut[i].value, this.vOut[i].scriptPubKey = e.read(A.varIntToInt(e.readVarInt()));
                    let t = A.parseScript(this.vOut[i].scriptPubKey);
                    this.vOut[i].nType = t.nType, this.vOut[i].type = t.type, null === this.data && 3 === t.type && (this.data = t.data), void 0 !== t.addressHash && (this.vOut[i].addressHash = t.addressHash, this.vOut[i].reqSigs = t.reqSigs)
                }
                if (I) {
                    I = e.__offset - n;
                    for (let i = 0; i < s; i++) {
                        this.vIn[i].txInWitness = [];
                        let t = A.varIntToInt(e.readVarInt());
                        for (let I = 0; I < t; I++) this.vIn[i].txInWitness.push(e.read(A.varIntToInt(e.readVarInt())))
                    }
                    o = e.__offset - n - I + 2
                }
                this.lockTime = e.readInt(4);
                let C = e.__offset;
                this.rawTx = e.slice(n, C), this.size = C - n, this.bSize = C - n - o, this.weight = 3 * this.bSize + this.size, this.vSize = Math.ceil(this.weight / 4), this.coinbase = !(1 !== s || !this.vIn[0].txId.equals(t(32)) || 4294967295 !== this.vIn[0].vOut), I > 0 ? (this.segwit = !0, this.hash = A.doubleSha256(this.rawTx), this.txId = A.doubleSha256(B([this.rawTx.slice(0, 4), this.rawTx.slice(6, I), this.rawTx.slice(this.rawTx.length - 4, this.rawTx.length)]))) : (this.txId = A.doubleSha256(this.rawTx), this.hash = this.txId, this.segwit = !1), i.keepRawTx || (this.rawTx = null), "decoded" === i.format && this.decode()
            }
        }
        E.prototype.decode = function(i) {
            this.format = "decoded", void 0 !== i && (this.testnet = i), I(this.txId) && (this.txId = e(this.txId)), I(this.hash) && (this.hash = e(this.hash)), I(this.flag) && (this.flag = e(this.flag)), I(this.rawTx) && (this.rawTx = this.rawTx.hex());
            for (let i in this.vIn) {
                if (I(this.vIn[i].txId) && (this.vIn[i].txId = e(this.vIn[i].txId)), I(this.vIn[i].scriptSig) && (this.vIn[i].scriptSig = this.vIn[i].scriptSig.hex()), this.vIn[i].amount instanceof A.BN && (this.vIn[i].amount = this.vIn[i].amount.toString(16)), void 0 !== this.vIn[i].txInWitness) {
                    let A = [];
                    for (let e of this.vIn[i].txInWitness) A.push(I(e) ? e.hex() : e);
                    this.vIn[i].txInWitness = A
                }
                if (I(this.vIn[i].addressHash)) {
                    let e = this.vIn[i].nType < 5 ? null : this.vIn[i].addressHash[0];
                    this.vIn[i].addressHash = this.vIn[i].addressHash.hex();
                    let t = [1, 5].includes(this.vIn[i].nType);
                    this.vIn[i].address = A.hashToAddress(this.vIn[i].addressHash, {
                        testnet: this.testnet,
                        scriptHash: t,
                        witnessVersion: e
                    })
                }
                I(this.vIn[i].scriptPubKey) && (this.vIn[i].scriptPubKey = this.vIn[i].scriptPubKey.hex(), this.vIn[i].scriptPubKeyOpcodes = A.decodeScript(this.vIn[i].scriptPubKey), this.vIn[i].scriptPubKeyAsm = A.decodeScript(this.vIn[i].scriptPubKey, {
                    asm: !0
                })), I(this.vIn[i].redeemScript) && (this.vIn[i].redeemScript = this.vIn[i].redeemScript.hex(), this.vIn[i].redeemScriptOpcodes = A.decodeScript(this.vIn[i].redeemScript), this.vIn[i].redeemScriptAsm = A.decodeScript(this.vIn[i].redeemScript, {
                    asm: !0
                })), this.coinbase || (I(this.vIn[i].scriptSig) && (this.vIn[i].scriptSig = this.vIn[i].scriptSig.hex()), this.vIn[i].scriptSigOpcodes = A.decodeScript(this.vIn[i].scriptSig), this.vIn[i].scriptSigAsm = A.decodeScript(this.vIn[i].scriptSig, {
                    asm: !0
                }))
            }
            for (let i in this.vOut) {
                if (I(this.vOut[i].addressHash)) {
                    let e = this.vOut[i].nType < 5 ? null : this.vOut[i].scriptPubKey[0];
                    this.vOut[i].addressHash = this.vOut[i].addressHash.hex();
                    let t = [1, 5].includes(this.vOut[i].nType);
                    this.vOut[i].address = A.hashToAddress(this.vOut[i].addressHash, {
                        testnet: this.testnet,
                        scriptHash: t,
                        witnessVersion: e
                    })
                }
                I(this.vOut[i].scriptPubKey) && (this.vOut[i].scriptPubKey = this.vOut[i].scriptPubKey.hex(), this.vOut[i].scriptPubKeyOpcodes = A.decodeScript(this.vOut[i].scriptPubKey), this.vOut[i].scriptPubKeyAsm = A.decodeScript(this.vOut[i].scriptPubKey, {
                    asm: !0
                }))
            }
            return I(this.data) && (this.data = this.data.hex()), this
        }, E.prototype.encode = function() {
            s(this.txId) && (this.txId = i(this.txId)), s(this.flag) && (this.flag = i(this.flag)), s(this.hash) && (this.hash = i(this.hash)), s(this.rawTx) && (this.rawTx = o(this.hash, "hex"));
            for (let A in this.vIn) {
                if (s(this.vIn[A].txId) && (this.vIn[A].txId = i(this.vIn[A].txId)), s(this.vIn[A].scriptSig) && (this.vIn[A].scriptSig = o(this.vIn[A].scriptSig, "hex")), void 0 !== this.vIn[A].txInWitness) {
                    let i = [];
                    for (let e of this.vIn[A].txInWitness) i.push(s(e) ? o(e, "hex") : e);
                    this.vIn[A].txInWitness = i
                }
                s(this.vIn[A].addressHash) && (this.vIn[A].addressHash = o(this.vIn[A].addressHash, "hex")), s(this.vIn[A].scriptPubKey) && (this.vIn[A].scriptPubKey = o(this.vIn[A].scriptPubKey, "hex")), s(this.vIn[A].redeemScript) && (this.vIn[A].redeemScript = o(this.vIn[A].redeemScript, "hex")), s(this.vIn[A].addressHash) && (this.vIn[A].addressHash = o(this.vIn[A].addressHash, "hex")), delete this.vIn[A].scriptSigAsm, delete this.vIn[A].scriptSigOpcodes, delete this.vIn[A].scriptPubKeyOpcodes, delete this.vIn[A].scriptPubKeyAsm, delete this.vIn[A].redeemScriptOpcodes, delete this.vIn[A].redeemScriptAsm, delete this.vIn[A].address
            }
            for (let A in this.vOut) s(this.vOut[A].scriptPubKey) && (this.vOut[A].scriptPubKey = o(this.vOut[A].scriptPubKey, "hex")), s(this.vOut[A].addressHash) && (this.vOut[A].addressHash = o(this.vOut[A].addressHash, "hex")), delete this.address, delete this.vOut[A].scriptPubKeyOpcodes, delete this.vOut[A].scriptPubKeyAsm;
            return s(this.data) && (this.data = o(this.data, "hex")), this.format = "raw", this
        }, E.prototype.serialize = function(e = {}) {
            g(e, {
                segwit: !0,
                hex: !0
            });
            let t = [];
            t.push(o(A.intToBytes(this.version, 4))), e.segwit && this.segwit && t.push(o([0, 1])), t.push(o(A.intToVarInt(Object.keys(this.vIn).length)));
            for (let e in this.vIn) {
                s(this.vIn[e].txId) ? t.push(i(this.vIn[e].txId)) : t.push(this.vIn[e].txId), t.push(o(A.intToBytes(this.vIn[e].vOut, 4)));
                let I = s(this.vIn[e].scriptSig) ? o(this.vIn[e].scriptSig, "hex") : this.vIn[e].scriptSig;
                t.push(o(A.intToVarInt(I.length))), t.push(I), t.push(o(A.intToBytes(this.vIn[e].sequence, 4)))
            }
            t.push(o(A.intToVarInt(Object.keys(this.vOut).length)));
            for (let i in this.vOut) {
                t.push(o(A.intToBytes(this.vOut[i].value, 8)));
                let e = s(this.vOut[i].scriptPubKey) ? o(this.vOut[i].scriptPubKey, "hex") : this.vOut[i].scriptPubKey;
                t.push(o(A.intToVarInt(e.length))), t.push(e)
            }
            if (e.segwit && this.segwit)
                for (let i in this.vIn) {
                    t.push(o(A.intToVarInt(this.vIn[i].txInWitness.length)));
                    for (let e of this.vIn[i].txInWitness) {
                        let i = s(e) ? o(e, "hex") : e;
                        t.push(o(A.intToVarInt(i.length))), t.push(i)
                    }
                }
            t.push(o(A.intToBytes(this.lockTime, 4)));
            let I = B(t);
            return e.hex ? I.hex() : I
        }, E.prototype.json = function() {
            let A;
            return "raw" === this.format ? (this.decode(), A = JSON.stringify(this), this.encode()) : A = JSON.stringify(this), A
        }, E.prototype.addInput = function(r = {}) {
            g(r, {
                txId: null,
                vOut: 0,
                sequence: 4294967295,
                scriptSig: "",
                txInWitness: null,
                value: null,
                scriptPubKey: null,
                address: null,
                privateKey: null,
                redeemScript: null,
                inputVerify: !0
            });
            let n, B = [];
            if (null === r.txId && (r.txId = t(32), r.vOut = 4294967295, (4294967295 !== r.sequence || Object.keys(this.vOut).length) && r.inputVerify)) throw new Error("invalid coinbase transaction");
            if (s(r.txId)) {
                if (!A.isHex(r.txId)) throw new Error("txId invalid");
                r.txId = i(r.txId)
            }
            if (!I(r.txId) || 32 !== r.txId.length) throw new Error("txId invalid");
            if (0 === r.scriptSig.length && (r.scriptSig = o([])), s(r.scriptSig)) {
                if (!A.isHex(r.scriptSig)) throw new Error("scriptSig invalid");
                r.scriptSig = o(r.scriptSig, "hex")
            }
            if (!I(r.scriptSig) || r.scriptSig.length > 520 && r.inputVerify) throw new Error("scriptSig invalid");
            if (r.vOut < 0 || r.vOut > 4294967295) throw new Error("vOut invalid");
            if (r.sequence < 0 || r.sequence > 4294967295) throw new Error("vOut invalid");
            if (null === r.privateKey || r.privateKey instanceof A.PrivateKey || (r.privateKey = A.PrivateKey(r.privateKey)), null !== r.value && (r.value < 0 || r.value > A.MAX_AMOUNT)) throw new Error("amount invalid");
            if (null !== r.txInWitness) {
                let A = 0;
                for (let i of r.txInWitness) s(i) ? B.push("raw" === this.format ? o(i, "hex") : i) : B.push("raw" === this.format ? i : o(i, "hex")), A += 1 + i.length
            }
            if (r.txId.equals(t.alloc(32))) {
                if (!(4294967295 === r.vOut && 4294967295 === r.sequence && r.scriptSig.length <= 100) && r.inputVerify) throw new Error("coinbase tx invalid");
                this.coinbase = !0
            }
            if (null !== r.scriptPubKey && (s(r.scriptPubKey) && (r.scriptPubKey = o(r.scriptPubKey, "hex")), !I(r.scriptPubKey))) throw new Error("scriptPubKey invalid");
            if (null !== r.redeemScript && (s(r.redeemScript) && (r.redeemScript = o(r.redeemScript, "hex")), !I(r.redeemScript))) throw new Error("scriptPubKey invalid");
            if (null !== r.address) {
                if (s(r.address)) {
                    if ("mainnet" === A.addressNetType(r.address) === this.testnet) throw new Error("address invalid");
                    n = A.addressToScript(r.address)
                } else {
                    if (void 0 === r.address.address) throw new Error("address invalid");
                    n = A.addressToScript(r.address.address)
                }
                if (null !== r.scriptPubKey) {
                    if (!r.scriptPubKey.equals(n)) throw new Error("address not match script")
                } else r.scriptPubKey = n
            }
            let a = Object.keys(this.vIn).length;
            return this.vIn[a] = {}, this.vIn[a].vOut = r.vOut, this.vIn[a].sequence = r.sequence, "raw" === this.format ? (this.vIn[a].txId = r.txId, this.vIn[a].scriptSig = r.scriptSig, null !== r.scriptPubKey && (this.vIn[a].scriptPubKey = r.scriptPubKey), null !== r.redeemScript && (this.vIn[a].redeemScript = r.redeemScript)) : (this.vIn[a].txId = e(r.txId), this.vIn[a].scriptSig = r.scriptSig.hex(), this.vIn[a].scriptSigOpcodes = A.decodeScript(r.scriptSig), this.vIn[a].scriptSigAsm = A.decodeScript(r.scriptSig, {
                asm: !0
            }), null !== r.scriptPubKey && (this.vIn[a].scriptPubKey = r.scriptPubKey.hex(), this.vIn[a].scriptPubKeyOpcodes = A.decodeScript(r.scriptPubKey), this.vIn[a].scriptPubKeyAsm = A.decodeScript(r.scriptPubKey, {
                asm: !0
            })), null !== r.redeemScript && (this.vIn[a].redeemScript = r.redeemScript.hex(), this.vIn[a].redeemScriptOpcodes = A.decodeScript(r.redeemScript), this.vIn[a].redeemScriptAsm = A.decodeScript(r.redeemScript, {
                asm: !0
            }))), null !== r.txInWitness && (this.segwit = !0, this.vIn[a].txInWitness = B), null !== r.value && (this.vIn[a].value = r.value), 0 !== r.privateKey && (this.vIn[a].privateKey = r.privateKey), this.autoCommit && this.commit(), this
        }, E.prototype.addOutput = function(i = {}) {
            if (g(i, {
                    value: 0,
                    address: null,
                    scriptPubKey: null
                }), null === i.address && null === i.scriptPubKey) throw new Error("unable to add output, address or script required");
            if (i.value < 0 || i.value > A.MAX_AMOUNT) throw new Error(" amount value error");
            null !== i.scriptPubKey && (s(i.scriptPubKey) ? i.scriptPubKey = o(i.scriptPubKey, "hex") : null !== i.address && void 0 !== i.address.address && (i.address = i.address.address)), null !== i.address && (i.scriptPubKey = A.addressToScript(i.address));
            let e = Object.keys(this.vOut).length;
            this.vOut[e] = {}, this.vOut[e].value = i.value;
            let t = A.parseScript(i.scriptPubKey, {
                segwit: !0
            });
            if (this.vOut[e].nType = t.nType, this.vOut[e].type = t.type, "raw" === this.format) this.vOut[e].scriptPubKey = i.scriptPubKey, null === this.data && 3 === t.nType && (this.data = t.data), [3, 4, 7, 8].includes(t.nType) || (this.vOut[e].addressHash = t.addressHash, this.vOut[e].reqSigs = t.reqSigs);
            else {
                this.vOut[e].scriptPubKey = i.scriptPubKey.hex(), null === this.data && 3 === t.nType && (this.data = t.data.hex()), [3, 4, 7, 8].includes(t.nType) || (this.vOut[e].addressHash = t.addressHash.hex(), this.vOut[e].reqSigs = t.reqSigs), this.vOut[e].scriptPubKeyOpcodes = A.decodeScript(i.scriptPubKey), this.vOut[e].scriptPubKeyAsm = A.decodeScript(i.scriptPubKey, {
                    asm: !0
                });
                let I = [1, 5].includes(t.nType),
                    g = t.nType < 5 ? null : i.scriptPubKey[0];
                void 0 !== this.vOut[e].addressHash && (this.vOut[e].address = A.hashToAddress(this.vOut[e].addressHash, {
                    testnet: this.testnet,
                    scriptHash: I,
                    witnessVersion: g
                }))
            }
            return this.autoCommit && this.commit(), this
        }, E.prototype.delOutput = function(A) {
            let i = Object.keys(this.vOut).length;
            if (0 === i) return this;
            void 0 === A && (A = i - 1);
            let e = {},
                t = 0;
            for (let I = 0; I < i; I++) I !== A && (e[t] = this.vOut[I], t++);
            return this.vOut = e, this.autoCommit && this.commit(), this
        }, E.prototype.delInput = function(A) {
            let i = Object.keys(this.vIn).length;
            if (0 === i) return this;
            void 0 === A && (A = i - 1);
            let e = {},
                t = 0;
            for (let I = 0; I < i; I++) I !== A && (e[t] = this.vIn[I], t++);
            return this.vOut = e, this.autoCommit && this.commit(), this
        }, E.prototype.commit = function() {
            if (0 === Object.keys(this.vIn).length || 0 === Object.keys(this.vOut).length) return this;
            if (this.segwit)
                for (let A in this.vIn) void 0 === this.vIn[A].txInWitness && (this.vIn[A].txInWitness = []);
            let i = this.serialize({
                segwit: !1,
                hex: !1
            });
            this.txId = A.doubleSha256(i), this.rawTx = this.serialize({
                segwit: !0,
                hex: !1
            }), this.hash = A.doubleSha256(this.rawTx), this.size = this.rawTx.length, this.bSize = i.length, this.weight = 3 * this.bSize + this.size, this.vSize = Math.ceil(this.weight / 4), "raw" !== this.format && (this.txId = e(this.txId), this.hash = e(this.hash), this.rawTx = this.rawTx.hex());
            let t = 0,
                I = 0;
            for (let A in this.vIn) {
                if (void 0 === this.vIn[A].value) {
                    t = null;
                    break
                }
                t += this.vIn[A].value;
                for (let A in this.vOut) void 0 !== this.vOut[A].value && (I += this.vOut[A].value)
            }
            return this.amount = I, this.fee = I && t ? t - I : null, this
        }, E.prototype.sigHash = function(t, I = {}) {
            if (g(I, {
                    scriptPubKey: null,
                    sigHashType: A.SIGHASH_ALL,
                    preImage: !1
                }), void 0 === this.vIn[t]) throw new Error("input not exist");
            let E;
            if (null !== I.scriptPubKey) E = I.scriptPubKey;
            else {
                if (void 0 === this.vIn[t].scriptPubKey) throw new Error("scriptPubKey required");
                E = this.vIn[t].scriptPubKey
            }
            if (E = r(E), (31 & I.sigHashType) === A.SIGHASH_SINGLE && t >= Object.keys(this.vOut).length) {
                let A = B([o([1]), n(31)]);
                return "raw" === this.format ? A : e(A)
            }
            E = A.deleteFromScript(E, o([a.OP_CODESEPARATOR]));
            let C, Q = [o(A.intToBytes(this.version, 4))];
            Q.push(I.sigHashType & A.SIGHASH_ANYONECANPAY ? o([1]) : o(A.intToVarInt(Object.keys(this.vIn).length)));
            for (let e in this.vIn) {
                if (e = parseInt(e), I.sigHashType & A.SIGHASH_ANYONECANPAY && t !== e) continue;
                let g = this.vIn[e].sequence;
                [A.SIGHASH_SINGLE, A.SIGHASH_NONE].includes(31 & I.sigHashType) && t !== e && (g = 0);
                let r = s(this.vIn[e].txId) ? i(this.vIn[e].txId) : this.vIn[e].txId;
                Q.push(r), Q.push(o(A.intToBytes(this.vIn[e].vOut, 4))), t === e ? (Q.push(o(A.intToVarInt(E.length))), Q.push(E), Q.push(o(A.intToBytes(g, 4)))) : (Q.push(o([0])), Q.push(o(A.intToBytes(g, 4))))
            }
            if ((31 & I.sigHashType) === A.SIGHASH_NONE ? Q.push(o([0])) : (31 & I.sigHashType) === A.SIGHASH_SINGLE ? Q.push(o(A.intToVarInt(t + 1))) : Q.push(o(A.intToVarInt(Object.keys(this.vOut).length))), (31 & I.sigHashType) !== A.SIGHASH_NONE)
                for (let i in this.vOut) i = parseInt(i), C = this.vOut[i].scriptPubKey, C = s(C) ? o(C, "hex") : C, i > t && (31 & I.sigHashType) === A.SIGHASH_SINGLE || ((31 & I.sigHashType) === A.SIGHASH_SINGLE && t !== i ? (Q.push(n(8, 255)), Q.push(n(1, 0))) : (Q.push(o(A.intToBytes(this.vOut[i].value, 8))), Q.push(o(A.intToVarInt(C.length))), Q.push(C)));
            return Q.push(o(A.intToBytes(this.lockTime, 4))), Q.push(o(A.intToBytes(I.sigHashType, 4))), Q = B(Q), I.preImage ? "raw" === this.format ? Q : Q.hex() : (Q = A.doubleSha256(Q), "raw" === this.format ? Q : e(Q))
        }, E.prototype.sigHashSegwit = function(e, t = {}) {
            if (g(t, {
                    value: null,
                    scriptPubKey: null,
                    sigHashType: A.SIGHASH_ALL,
                    preImage: !1
                }), void 0 === this.vIn[e]) throw new Error("input not exist");
            let I, a;
            if (null !== t.scriptPubKey) I = t.scriptPubKey;
            else {
                if (void 0 === this.vIn[e].scriptPubKey) throw new Error("scriptPubKey required");
                I = this.vIn[e].scriptPubKey
            }
            if (I = r(I), null !== t.value) a = t.value;
            else {
                if (void 0 === this.vIn[e].value) throw new Error("value required");
                a = this.vIn[e].value
            }
            let E, C, Q = [],
                h = [],
                c = [];
            for (let I in this.vIn) {
                I = parseInt(I);
                let g = this.vIn[I].txId;
                s(g) && (g = i(g));
                let r = o(A.intToBytes(this.vIn[I].vOut, 4));
                t.sigHashType & A.SIGHASH_ANYONECANPAY || (Q.push(g), Q.push(r), (31 & t.sigHashType) !== A.SIGHASH_SINGLE && (31 & t.sigHashType) !== A.SIGHASH_NONE && h.push(o(A.intToBytes(this.vIn[I].sequence, 4)))), I === e && (E = B([g, r]), C = o(A.intToBytes(this.vIn[I].sequence, 4)))
            }
            let l = Q.length > 0 ? A.doubleSha256(B(Q)) : n(32, 0),
                u = h.length > 0 ? A.doubleSha256(B(h)) : n(32, 0);
            a = o(A.intToBytes(a, 8));
            for (let i in this.vOut) {
                i = parseInt(i);
                let I = r(this.vOut[i].scriptPubKey);
                [A.SIGHASH_SINGLE, A.SIGHASH_NONE].includes(31 & t.sigHashType) ? (31 & t.sigHashType) === A.SIGHASH_SINGLE && e < Object.keys(this.vOut).length && i === e && (c.push(o(A.intToBytes(this.vOut[i].value, 8))), c.push(o(A.intToVarInt(I.length))), c.push(I)) : (c.push(o(A.intToBytes(this.vOut[i].value, 8))), c.push(o(A.intToVarInt(I.length))), c.push(I))
            }
            let d = c.length > 0 ? A.doubleSha256(B(c)) : n(32, 0),
                p = B([o(A.intToBytes(this.version, 4)), l, u, E, I, a, C, d, o(A.intToBytes(this.lockTime, 4)), o(A.intToBytes(t.sigHashType, 4))]);
            return t.preImage ? "raw" === this.format ? p.hex() : p : A.doubleSha256(p, {
                hex: "raw" !== this.format
            })
        }, E.prototype.signInput = function(i, e = {}) {
            if (g(e, {
                    privateKey: null,
                    scriptPubKey: null,
                    redeemScript: null,
                    sigHashType: A.SIGHASH_ALL,
                    address: null,
                    value: null,
                    witnessVersion: 0,
                    p2sh_p2wsh: !1
                }), void 0 === this.vIn[i]) throw new Error("input not exist");
            if (null === e.privateKey) {
                if (void 0 === this.vIn[i].privateKey) throw new Error("no private key");
                e.privateKey = this.vIn[i].privateKey
            }
            if (e.privateKey instanceof Array) {
                e.publicKey = [];
                let i = [];
                for (let t of e.privateKey) void 0 !== t.key && (t = t.wif), e.publicKey.push(A.privateToPublicKey(t, {
                    hex: !1
                })), i.push(new A.PrivateKey(t).key);
                e.privateKey = i
            } else {
                if (void 0 === e.privateKey.key) {
                    let i = new A.PrivateKey(e.privateKey);
                    e.privateKey = i.key, e.privateKeyCompressed = i.compressed
                } else e.privateKeyCompressed = e.privateKey.compressed, e.privateKey = e.privateKey.key;
                e.publicKey = [A.privateToPublicKey(e.privateKey, {
                    hex: !1,
                    compressed: e.privateKeyCompressed
                })], e.privateKey = [e.privateKey]
            }
            if (null === e.address && void 0 !== this.vIn[i].address && (e.address = this.vIn[i].address), null !== e.address) {
                if (void 0 !== e.address.address && (e.address = e.address.address), this.testnet !== ("testnet" === A.addressNetType(e.address))) throw new Error("address network invalid");
                e.scriptPubKey = A.addressToScript(e.address)
            }
            let t, I = null;
            if (null === e.redeemScript && void 0 !== this.vIn[i].redeemScript && (e.redeemScript = this.vIn[i].redeemScript), null !== e.redeemScript && (e.redeemScript = r(e.redeemScript)), null === e.scriptPubKey && void 0 !== this.vIn[i].scriptPubKey) e.scriptPubKey = this.vIn[i].scriptPubKey;
            else if (null === e.scriptPubKey && null === e.redeemScript) throw new Error("no scriptPubKey key");
            if (null !== e.scriptPubKey) {
                e.scriptPubKey = r(e.scriptPubKey);
                let i = A.parseScript(e.scriptPubKey);
                I = i.type, [5, 6].includes(i.nType) && (e.witnessVersion = e.scriptPubKey[0])
            } else null !== e.redeemScript && (I = null === e.witnessVersion || e.p2sh_p2wsh ? "P2SH" : "P2WSH");
            switch (I) {
                case "PUBKEY":
                    t = this.__sign_PUBKEY(i, e);
                    break;
                case "P2PKH":
                    t = this.__sign_P2PKH(i, e);
                    break;
                case "P2SH":
                    t = this.__sign_P2SH(i, e);
                    break;
                case "P2WPKH":
                    t = this.__sign_P2WPKH(i, e);
                    break;
                case "P2WSH":
                    t = this.__sign_P2WSH(i, e);
                    break;
                case "MULTISIG":
                    t = this.__sign_MULTISIG(i, e);
                    break;
                default:
                    throw new Error("not implemented")
            }
            return "raw" === this.format ? this.vIn[i].scriptSig = t : (this.vIn[i].scriptSig = t.hex(), this.vIn[i].scriptSigOpcodes = A.decodeScript(t), this.vIn[i].scriptSigAsm = A.decodeScript(t, {
                asm: !0
            })), this.autoCommit && this.commit(), this
        }, E.prototype.__sign_PUBKEY = function(e, t) {
            let I = this.sigHash(e, t);
            s(I) && (I = i(I));
            let g = B([A.signMessage(I, t.privateKey[0]).signature, o(A.intToBytes(t.sigHashType, 1))]);
            return "raw" === this.format ? this.vIn[e].signatures = [g] : this.vIn[e].signatures = [g.hex()], B([o([g.length]), g])
        }, E.prototype.__sign_P2PKH = function(e, t) {
            let I = this.sigHash(e, t);
            s(I) && (I = i(I));
            let g = B([A.signMessage(I, t.privateKey[0]).signature, o(A.intToBytes(t.sigHashType, 1))]);
            return "raw" === this.format ? this.vIn[e].signatures = [g] : this.vIn[e].signatures = [g.hex()], B([o([g.length]), g, o([t.publicKey[0].length]), t.publicKey[0]])
        }, E.prototype.__sign_P2SH = function(i, e) {
            if (null === e.redeemScript) throw new Error("no redeem script");
            if (e.p2sh_p2wsh) return this.__sign_P2SH_P2WSH(i, e);
            switch (A.parseScript(e.redeemScript).type) {
                case "MULTISIG":
                    return this.__sign_P2SH_MULTISIG(i, e);
                case "P2WPKH":
                    return this.__sign_P2SH_P2WPKH(i, e);
                default:
                    throw new Error("not implemented")
            }
        }, E.prototype.__sign_P2SH_MULTISIG = function(e, t) {
            let I = this.sigHash(e, {
                scriptPubKey: t.redeemScript,
                sigHashType: t.sigHashType
            });
            s(I) && (I = i(I));
            let g = [];
            this.vIn[e].signatures = [];
            for (let i of t.privateKey) {
                let r = B([A.signMessage(I, i).signature, o(A.intToBytes(t.sigHashType, 1))]);
                g.push(r), this.vIn[e].signatures.push("raw" === this.format ? r : r.hex())
            }
            return this.__get_MULTISIG_scriptSig(e, t.publicKey, g, t.redeemScript, t.redeemScript)
        }, E.prototype.__sign_P2SH_P2WPKH = function(i, e) {
            let t = B([o([25]), o([a.OP_DUP, a.OP_HASH160]), A.opPushData(A.hash160(e.publicKey[0])), o([a.OP_EQUALVERIFY, a.OP_CHECKSIG])]);
            if (null === e.value) {
                if (void 0 === this.vIn[i].value) throw new Error("no input amount");
                e.value = this.vIn[i].value
            }
            let I = this.sigHashSegwit(i, {
                scriptPubKey: t,
                sigHashType: e.sigHashType,
                value: e.value
            });
            I = r(I);
            let g = B([A.signMessage(I, e.privateKey[0]).signature, o(A.intToBytes(e.sigHashType, 1))]);
            return this.segwit = !0, "raw" === this.format ? this.vIn[i].txInWitness = [g, e.publicKey[0]] : this.vIn[i].txInWitness = [g.hex(), e.publicKey[0].hex()], this.vIn[i].signatures = "raw" === this.format ? [g] : [g.hex()], A.opPushData(e.redeemScript)
        }, E.prototype.__sign_P2SH_P2WSH = function(i, e) {
            switch (A.parseScript(e.redeemScript).type) {
                case "MULTISIG":
                    return this.__sign_P2SH_P2WSH_MULTISIG(i, e);
                default:
                    throw new Error("not implemented")
            }
        }, E.prototype.__sign_P2SH_P2WSH_MULTISIG = function(i, e) {
            this.segwit = !0;
            let t = B([o(A.intToVarInt(e.redeemScript.length)), e.redeemScript]),
                I = this.sigHashSegwit(i, {
                    scriptPubKey: t,
                    sigHashType: e.sigHashType,
                    value: e.value
                });
            I = r(I), this.vIn[i].signatures = [];
            let g = [];
            for (let t of e.privateKey) {
                let r = B([A.signMessage(I, t).signature, o(A.intToBytes(e.sigHashType, 1))]);
                g.push(r), this.vIn[i].signatures.push("raw" === this.format ? r : r.hex())
            }
            let n = this.__get_MULTISIG_scriptSig(i, e.publicKey, g, t, e.redeemScript, e.value);
            if ("raw" === this.format) this.vIn[i].txInWitness = n;
            else {
                this.vIn[i].txInWitness = [];
                for (let A of n) this.vIn[i].txInWitness.push(A.hex())
            }
            return A.opPushData(B([o([0]), A.opPushData(A.sha256(e.redeemScript))]))
        }, E.prototype.__sign_P2WPKH = function(i, e) {
            let t = B([o([25]), o([a.OP_DUP, a.OP_HASH160]), e.scriptPubKey.slice(1), o([a.OP_EQUALVERIFY, a.OP_CHECKSIG])]);
            if (null === e.value) {
                if (void 0 === this.vIn[i].value) throw new Error("no input amount");
                e.value = this.vIn[i].value
            }
            let I = this.sigHashSegwit(i, {
                scriptPubKey: t,
                sigHashType: e.sigHashType,
                value: e.value
            });
            I = r(I);
            let g = B([A.signMessage(I, e.privateKey[0]).signature, o(A.intToBytes(e.sigHashType, 1))]);
            return this.segwit = !0, "raw" === this.format ? this.vIn[i].txInWitness = [g, e.publicKey[0]] : this.vIn[i].txInWitness = [g.hex(), e.publicKey[0].hex()], this.vIn[i].signatures = "raw" === this.format ? [g] : [g.hex()], o([])
        }, E.prototype.__sign_P2WSH = function(i, e) {
            if (this.segwit = !0, null === e.value) {
                if (void 0 === this.vIn[i].value) throw new Error("no input amount");
                e.value = this.vIn[i].value
            }
            switch (A.parseScript(e.redeemScript).type) {
                case "MULTISIG":
                    return this.__sign_P2WSH_MULTISIG(i, e);
                default:
                    throw new Error("not implemented")
            }
        }, E.prototype.__sign_P2WSH_MULTISIG = function(i, e) {
            let t = B([o(A.intToVarInt(e.redeemScript.length)), e.redeemScript]),
                I = this.sigHashSegwit(i, {
                    scriptPubKey: t,
                    sigHashType: e.sigHashType,
                    value: e.value
                });
            I = r(I);
            let g = [];
            this.vIn[i].signatures = [];
            for (let t of e.privateKey) {
                let r = B([A.signMessage(I, t).signature, o(A.intToBytes(e.sigHashType, 1))]);
                g.push(r), this.vIn[i].signatures.push("raw" === this.format ? r : r.hex())
            }
            let n = this.__get_MULTISIG_scriptSig(i, e.publicKey, g, t, e.redeemScript, e.value);
            if ("raw" === this.format) this.vIn[i].txInWitness = n;
            else {
                this.vIn[i].txInWitness = [];
                for (let A of n) this.vIn[i].txInWitness.push(A.hex())
            }
            return o([])
        }, E.prototype.__sign_MULTISIG = function(e, t) {
            let I = this.sigHash(e, {
                scriptPubKey: t.scriptPubKey,
                sigHashType: t.sigHashType
            });
            s(I) && (I = i(I));
            let g = [];
            this.vIn[e].signatures = [];
            for (let i of t.privateKey) {
                let r = B([A.signMessage(I, i).signature, o(A.intToBytes(t.sigHashType, 1))]);
                g.push(r), this.vIn[e].signatures.push("raw" === this.format ? r : r.hex())
            }
            return this.__get_bare_multisig_script_sig__(e, t.publicKey, g, t.scriptPubKey)
        }, E.prototype.__get_bare_multisig_script_sig__ = function(e, t, I, g) {
            let n = {};
            for (let A in t) n[t[A]] = I[A];
            g.seek(0);
            let E = A.getMultiSigPublicKeys(g),
                C = r(this.vIn[e].scriptSig);
            C.seek(0);
            let Q = A.readOpCode(C);
            for (; null !== Q[0];)
                if (Q = A.readOpCode(C), null !== Q[1] && A.isValidSignatureEncoding(Q[1])) {
                    let t = this.sigHash(e, {
                        scriptPubKey: g,
                        sigHashType: Q[1][Q[1].length - 1]
                    });
                    s(t) && (t = i(t));
                    for (let i = 0; i < 4; i++) {
                        let e = A.publicKeyRecovery(Q[1].slice(0, Q[1].length - 1), t, i, {
                            hex: !1
                        });
                        if (null !== e)
                            for (let A of E)
                                if (e.equals(A)) {
                                    n[e] = Q[1];
                                    break
                                }
                    }
                }
            Q = [o([a.OP_0])];
            for (let i of E) void 0 !== n[i] && Q.push(A.opPushData(n[i]));
            return B(Q)
        }, E.prototype.__get_MULTISIG_scriptSig = function(e, t, I, g, n, E = null) {
            let C = {};
            for (let A in t) C[t[A]] = I[A];
            n.seek(0);
            let Q = A.getMultiSigPublicKeys(n);
            if (!(null !== E)) {
                let t = r(this.vIn[e].scriptSig);
                t.seek(0);
                let I = A.readOpCode(t);
                for (; null !== I[0];)
                    if (I = A.readOpCode(t), null !== I[1] && A.isValidSignatureEncoding(I[1])) {
                        let t = this.sigHash(e, {
                            scriptPubKey: g,
                            sigHashType: I[1][I[1].length - 1]
                        });
                        s(t) && (t = i(t));
                        for (let i = 0; i < 4; i++) {
                            let e = A.publicKeyRecovery(I[1].slice(0, I[1].length - 1), t, i, {
                                hex: !1
                            });
                            if (null !== e)
                                for (let A of Q)
                                    if (e.equals(A)) {
                                        C[e] = I[1];
                                        break
                                    }
                        }
                    }
                I = [o([a.OP_0])];
                for (let i of Q) void 0 !== C[i] && I.push(A.opPushData(C[i]));
                return I.push(A.opPushData(n)), B(I)
            }
            if (void 0 !== this.vIn[e].txInWitness)
                for (let i of this.vIn[e].txInWitness)
                    if (i = r(i), i.length > 0 && A.isValidSignatureEncoding(i)) {
                        let t = this.sigHashSegwit(e, {
                            scriptPubKey: g,
                            sigHashType: i[i.length - 1],
                            value: E
                        });
                        t = r(t);
                        for (let e = 0; e < 4; e++) {
                            let I = A.publicKeyRecovery(i.slice(0, i.length - 1), t, e, {
                                hex: !1
                            });
                            if (null !== I)
                                for (let A of Q)
                                    if (I.equals(A)) {
                                        C[I] = i;
                                        break
                                    }
                        }
                    }
            let h = [o([])];
            for (let A of Q) void 0 !== C[A] && h.push(C[A]);
            return h.push(n), h
        }, A.Transaction = E
    }
}, function(A, i) {
    A.exports = function(A) {
        let i = A.Buffer,
            e = A.defArgs,
            t = A.getBuffer,
            I = i.from,
            g = i.concat,
            r = A.OPCODE;
        class o {
            constructor(i, t = {}) {
                if (e(t, {
                        compressed: null,
                        testnet: !1
                    }), void 0 === i) null === t.compressed && (t.compressed = !0), this.compressed = t.compressed, this.testnet = t.testnet, this.key = A.createPrivateKey({
                    wif: !1
                }), this.hex = this.key.hex(), this.wif = A.privateKeyToWif(this.key, t);
                else if (A.isString(i)) A.isHex(i) ? (null === t.compressed && (t.compressed = !0), this.key = I(i, "hex"), this.compressed = t.compressed, this.testnet = t.testnet, this.hex = this.key.hex(), this.wif = A.privateKeyToWif(this.key, t)) : (this.wif = i, this.key = A.wifToPrivateKey(i, {
                    hex: !1
                }), this.hex = this.key.hex(), this.compressed = ![A.MAINNET_PRIVATE_KEY_UNCOMPRESSED_PREFIX, A.TESTNET_PRIVATE_KEY_UNCOMPRESSED_PREFIX].includes(i[0]), this.testnet = [A.TESTNET_PRIVATE_KEY_COMPRESSED_PREFIX, A.TESTNET_PRIVATE_KEY_UNCOMPRESSED_PREFIX].includes(i[0]));
                else {
                    if (32 !== (i = I(i)).length) throw new Error("private key invalid");
                    null === t.compressed && (t.compressed = !0), this.compressed = t.compressed, this.testnet = t.testnet, this.key = i, this.hex = this.key.hex(), this.wif = A.privateKeyToWif(this.key, t)
                }
            }
        }
        o.prototype.toString = function() {
            return `${this.wif}`
        };
        class n {
            constructor(i, t = {}) {
                if (e(t, {
                        compressed: null,
                        testnet: !1
                    }), this.compressed = t.compressed, this.testnet = t.testnet, i instanceof o && (t.testnet = i.testnet, t.compressed = i.compressed, i = i.wif), A.isString(i))
                    if (A.isHex(i)) i = I(i, "hex"), null === t.compressed && (t.compressed = !0);
                    else {
                        if (!A.isWifValid(i)) throw new Error("private/public key invalid");
                        this.compressed = ![A.MAINNET_PRIVATE_KEY_UNCOMPRESSED_PREFIX, A.TESTNET_PRIVATE_KEY_UNCOMPRESSED_PREFIX].includes(i[0]), this.testnet = [A.TESTNET_PRIVATE_KEY_COMPRESSED_PREFIX, A.TESTNET_PRIVATE_KEY_UNCOMPRESSED_PREFIX].includes(i[0]), i = A.privateToPublicKey(i, {
                            compressed: this.compressed,
                            testnet: this.testnet,
                            hex: !1
                        })
                    }
                else i = I(i);
                if (32 === i.length) null === t.compressed && (t.compressed = !0), this.key = A.privateToPublicKey(i, {
                    compressed: t.compressed,
                    testnet: t.testnet,
                    hex: !1
                }), this.compressed = t.compressed, this.testnet = t.testnet, this.hex = this.key.hex();
                else {
                    if (!A.isPublicKeyValid(i)) throw new Error("private/public key invalid");
                    this.hex = i.hex(), this.key = i, this.compressed = 33 === this.key.length, this.testnet = t.testnet
                }
            }
        }
        n.prototype.toString = function() {
            return `${this.hex}`
        };
        class B {
            constructor(t, B = {}) {
                if (e(B, {
                        addressType: null,
                        testnet: !1,
                        compressed: null
                    }), void 0 === t) null === B.compressed && (B.compressed = !0), this.privateKey = new o(void 0, B), this.publicKey = new n(this.privateKey, B);
                else if (A.isString(t))
                    if (A.isWifValid(t)) this.privateKey = new o(t, B), B.compressed = this.privateKey.compressed, this.publicKey = new n(this.privateKey, B), B.testnet = this.privateKey.testnet;
                    else {
                        if (!A.isHex(t)) throw new Error("private/public key invalid");
                        null === B.compressed && (B.compressed = !0), t = I(t, "hex")
                    }
                else t instanceof o ? (this.privateKey = t, B.testnet = t.testnet, B.compressed = t.compressed, this.publicKey = new n(this.privateKey, B)) : t instanceof n ? (B.testnet = t.testnet, B.compressed = t.compressed, this.publicKey = t) : i.isBuffer(t) || (t = I(t));
                if (i.isBuffer(t))
                    if (32 === t.length) null === B.compressed && (B.compressed = !0), this.privateKey = new o(t, B), this.publicKey = new n(this.privateKey, B);
                    else {
                        if (!A.isPublicKeyValid(t)) throw new Error("private/public key invalid");
                        this.publicKey = new n(t, B), B.compressed = this.publicKey.compressed
                    }
                if (this.testnet = B.testnet, null === B.addressType && (!1 === B.compressed ? B.addressType = "P2PKH" : B.addressType = "P2WPKH"), !["P2PKH", "PUBKEY", "P2WPKH", "P2SH_P2WPKH"].includes(B.addressType)) throw new Error("address type invalid");
                this.type = B.addressType, "PUBKEY" === this.type && (this.publicKeyScript = g([A.opPushData(this.publicKey.key), I([r.OP_CHECKSIG])]), this.publicKeyScriptHex = this.publicKeyScript.hex()), this.witnessVersion = "P2WPKH" === this.type ? 0 : null, "P2SH_P2WPKH" === this.type ? (this.scriptHash = !0, this.redeemScript = A.publicKeyTo_P2SH_P2WPKH_Script(this.publicKey.key), this.redeemScriptHex = this.redeemScript.hex(), this.hash = A.hash160(this.redeemScript), this.witnessVersion = null) : (this.scriptHash = !1, this.hash = A.hash160(this.publicKey.key)), this.hashHex = this.hash.hex(), this.testnet = B.testnet, this.address = A.hashToAddress(this.hash, {
                    scriptHash: this.scriptHash,
                    witnessVersion: this.witnessVersion,
                    testnet: this.testnet
                })
            }
        }
        B.prototype.toString = function() {
            return `${this.address}`
        };
        class a {
            constructor(i, I = {}) {
                e(I, {
                    witnessVersion: 0,
                    testnet: !1
                }), this.witnessVersion = I.witnessVersion, this.testnet = I.testnet, i = t(i), this.script = i, this.scriptHex = i.hex(), null === this.witnessVersion ? this.hash = A.hash160(this.script) : this.hash = A.sha256(this.script), this.scriptOpcodes = A.decodeScript(this.script), this.scriptOpcodesAsm = A.decodeScript(this.script, {
                    asm: !0
                }), this.address = A.hashToAddress(this.hash, {
                    scriptHash: !0,
                    witnessVersion: this.witnessVersion,
                    testnet: this.testnet
                })
            }
            static multisig(e, t, n, s = {}) {
                if (e > 15 || t > 15 || e > t || e < 1 || t < 1) throw new Error("invalid n of m maximum 15 of 15 multisig allowed");
                if (n.length !== t) throw new Error("invalid address list count");
                let E = [I([80 + e])];
                for (let e of n) {
                    if (A.isString(e))
                        if (A.isHex(e)) e = I(e, "hex");
                        else {
                            if (!A.isWifValid(e)) throw new Error("invalid key in key list");
                            e = A.privateToPublicKey(e, {
                                hex: !1
                            })
                        }
                    if (e instanceof B && (e = e.publicKey.key), e instanceof o && (e = A.privateToPublicKey(e.publicKey.key)), i.isBuffer(e) || (e = I(e)), 32 === e.length && (e = A.privateToPublicKey(e)), 33 !== e.length) throw new Error("invalid public key list element size");
                    E.push(g([I(A.intToVarInt(e.length)), e]))
                }
                return E.push(I([80 + t, r.OP_CHECKMULTISIG])), E = g(E), new a(E, s)
            }
        }
        a.prototype.toString = function() {
            return `${this.address}`
        }, A.PrivateKey = o, A.PublicKey = n, A.ScriptAddress = a, A.Address = B
    }
}, function(A, i) {
    A.exports = function(A) {
        let i = A.Buffer,
            e = A.defArgs,
            t = A.getBuffer,
            I = i.from,
            g = i.concat,
            r = A.OPCODE,
            o = A.RAW_OPCODE,
            n = A.__bitcoin_core_crypto.module,
            B = n._malloc,
            a = n._free,
            s = n.getValue;
        A.hashToScript = (i, o, n = {}) => {
            let B;
            switch (e(n, {
                hex: !1
            }), A.isString(o) && (o = A.SCRIPT_TYPES[o]), i = t(i), o) {
                case 0:
                    B = g([I([r.OP_DUP, r.OP_HASH160, 20]), i, I([r.OP_EQUALVERIFY, r.OP_CHECKSIG])]);
                    break;
                case 1:
                    B = g([I([r.OP_HASH160, 20]), i, I([r.OP_EQUAL])]);
                    break;
                case 5:
                case 6:
                    B = g([I([0, 20]), i]);
                    break;
                default:
                    throw new Error("unsupported script type")
            }
            return n.hex ? B.hex() : B
        }, A.publicKeyTo_P2SH_P2WPKH_Script = (i, r = {}) => {
            if (e(r, {
                    hex: !1
                }), 33 !== (i = t(i)).length) throw new Error("public key len invalid");
            let o = g([I([0, 20]), A.hash160(i)]);
            return r.hex ? o.hex() : o
        }, A.publicKeyTo_PUBKEY_Script = (A, i = {}) => {
            e(i, {
                hex: !1
            }), A = t(A);
            let o = g([I([A.length]), A, I([r.OP_CHECKSIG])]);
            return i.hex ? o.hex() : o
        }, A.parseScript = (i, I = {}) => {
            e(I, {
                segwit: !0
            });
            let g = (i = t(i)).length;
            if (0 === g) return {
                nType: 7,
                type: "NON_STANDARD",
                reqSigs: 0,
                script: i
            };
            if (I.segwit) {
                if (22 === g && 0 === i[0]) return {
                    nType: 5,
                    type: "P2WPKH",
                    reqSigs: 1,
                    addressHash: i.slice(2)
                };
                if (34 === g && 0 === i[0]) return {
                    nType: 6,
                    type: "P2WSH",
                    reqSigs: null,
                    addressHash: i.slice(2)
                }
            }
            if (25 === g && 118 === i[0] && 169 === i[1] && 136 === i[g - 2] && 172 === i[g - 1]) return {
                nType: 0,
                type: "P2PKH",
                reqSigs: 1,
                addressHash: i.slice(3, -2)
            };
            if (23 === g && 169 === i[0] && 135 === i[g - 1]) return {
                nType: 1,
                type: "P2SH",
                reqSigs: null,
                addressHash: i.slice(2, -1)
            };
            if ((67 === g || 35 === g) && 172 === i[g - 1]) return {
                nType: 2,
                type: "PUBKEY",
                reqSigs: 1,
                addressHash: A.hash160(i.slice(1, -1))
            };
            if (i[0] === r.OP_RETURN) return 1 === g ? {
                nType: 3,
                type: "NULL_DATA",
                reqSigs: 0,
                data: i.slice(1)
            } : i[1] < r.OP_PUSHDATA1 && i[1] === g - 2 ? {
                nType: 3,
                type: "NULL_DATA",
                reqSigs: 0,
                data: i.slice(2)
            } : i[1] === r.OP_PUSHDATA1 && g > 2 && i[2] === g - 3 && i[2] <= 80 ? {
                nType: 3,
                type: "NULL_DATA",
                reqSigs: 0,
                data: i.slice(3)
            } : {
                nType: 8,
                type: "NULL_DATA_NON_STANDARD",
                reqSigs: 0,
                script: i
            };
            if (i[0] >= 81 && i[0] <= 96 && 174 === i[g - 1] && i[g - 2] >= 81 && i[g - 2] <= 96 && i[g - 2] >= i[0]) {
                let A = 0,
                    e = 1;
                for (; g - e - 2 > 0;) {
                    if (!(i[e] < 76)) {
                        e = 0;
                        break
                    }
                    e += i[e], A++, e++
                }
                if (A === i[g - 2] - 80) return {
                    nType: 4,
                    type: "MULTISIG",
                    reqSigs: i[0] - 80,
                    pubKeys: A,
                    script: i
                }
            }
            let o = 0,
                n = 0,
                B = 0,
                a = 0,
                s = 0;
            for (; g - o > 0;) {
                if (i[o] >= 81 && i[o] <= 96) B ? 0 === n || n > B ? (B = i[o] - 80, n = 0) : n === i[o] - 80 && (a = a ? 0 : 2) : B = i[o] - 80;
                else if (i[o] < 76) o += i[o], n++, n > 16 && (n = 0, B = 0);
                else if (i[o] === r.OP_PUSHDATA1) {
                    if (void 0 === i[o + 1]) break;
                    o += 1 + i[o + 1]
                } else if (i[o] === r.OP_PUSHDATA2) {
                    if (void 0 === i[o + 1]) break;
                    o += 2 + i.readIntLE(o, 2)
                } else if (i[o] === r.OP_PUSHDATA4) {
                    if (void 0 === i[o + 3]) break;
                    o += 4 + i.readIntLE(o, 4)
                } else i[o] === r.OP_CHECKSIG ? s++ : i[o] === r.OP_CHECKSIGVERIFY ? s++ : [r.OP_CHECKMULTISIG, r.OP_CHECKMULTISIGVERIFY].includes(i[o]) && (s += a ? B : 20), B = 0, n = 0;
                a && a--, o++
            }
            return {
                nType: 7,
                type: "NON_STANDARD",
                reqSigs: s,
                script: i
            }
        }, A.scriptToAddress = (i, t = {}) => {
            if (e(t, {
                    testnet: !1
                }), void 0 !== (i = A.parseScript(i)).addressHash) {
                let e = 5 === i.nType || 6 === i.nType ? 0 : null,
                    I = 1 === i.nType || 6 === i.nType;
                return A.hashToAddress(i.addressHash, {
                    testnet: t.testnet,
                    scriptHash: I,
                    witnessVersion: e
                })
            }
            return null
        }, A.decodeScript = (A, i = {}) => {
            e(i, {
                asm: !1
            });
            let I = (A = t(A)).length,
                g = 0,
                n = [];
            if (0 === I) return "";
            try {
                for (; I - g > 0;)
                    if (A[g] < 76 && A[g]) i.asm ? (n.push(`OP_PUSHBYTES[${A[g]}]`), n.push(A.slice(g + 1, g + 1 + A[g]).hex())) : n.push(`[${A[g]}]`), g += A[g] + 1;
                    else if (A[g] !== r.OP_PUSHDATA1)
                    if (A[g] !== r.OP_PUSHDATA2)
                        if (A[g] !== r.OP_PUSHDATA4) n.push(o[A[g]]), g++;
                        else {
                            let e = A.readIntLE(g + 1, 4);
                            i.asm ? (n.push(`OP_PUSHDATA4[${e}]`), n.push(A.slice(g + 5, g + 5 + e).hex())) : (n.push(o[A[g]]), n.push(`[${A[e]}]`)), g += e + 6
                        }
                else {
                    let e = A.readIntLE(g + 1, 2);
                    i.asm ? (n.push(`OP_PUSHDATA2[${e}]`), n.push(A.slice(g + 3, g + 3 + e).hex())) : (n.push(o[A[g]]), n.push(`[${A[e]}]`)), g += e + 3
                } else i.asm ? (n.push(`OP_PUSHDATA1[${A[g+1]}]`), n.push(A.slice(g + 2, g + 2 + A[g + 1]).hex())) : (n.push(o[A[g]]), n.push(`[${A[g+1]}]`)), g += 1 + A[g + 1] + 1
            } catch (A) {
                n.push("[SCRIPT_DECODE_FAILED]")
            }
            return n.join(" ")
        }, A.deleteFromScript = (A, i, I = {}) => {
            if (e(I, {
                    hex: !1
                }), void 0 === i) return A;
            if (0 === i.length) return A;
            let o = t(A),
                n = t(i),
                B = o.length,
                a = n.length,
                s = 0,
                E = 0,
                C = [],
                Q = [];
            for (; B - s > 0;) {
                if (o[s] < 76 && o[s]) C.push(o[s] + 1), s += o[s] + 1;
                else if (o[s] === r.OP_PUSHDATA1) C.push(1 + o[s + 1]), s += 1 + o[s + 1];
                else if (o[s] === r.OP_PUSHDATA2) {
                    let A = o.readIntLE(s, 2);
                    C.push(2 + A), s += 2 + A
                } else if (o[s] === r.OP_PUSHDATA4) {
                    let A = o.readIntLE(s, 4);
                    C.push(4 + A), s += 4 + A
                } else C.push(1), s += 1;
                if (s - E >= a)
                    if (o.slice(E, s).slice(0, a).equals(n)) {
                        s - E > a && Q.push(o.slice(E + a, s));
                        let A = 0;
                        for (; A !== s - E;) A += C.shift();
                        E = s
                    } else {
                        let A = C.shift();
                        Q.push(o.slice(E, E + A)), E += A
                    }
            }
            o.slice(E, s).slice(0, a).equals(n) ? s - E > a && Q.push(o.slice(E + a, s)) : Q.push(o.slice(E, E + a));
            let h = g(Q);
            return I.hex ? h.hex() : h
        }, A.scriptToHash = (i, t = {}) => (e(t, {
            witness: !1,
            hex: !0
        }), t.witness ? A.sha256(i, t) : A.hash160(i, t)), A.opPushData = i => i.length <= 75 ? g([I([i.length]), i]) : i.length <= 255 ? g([I([r.OP_PUSHDATA1, i.length]), i]) : i.length <= 65535 ? g([I([r.OP_PUSHDATA2].concat(A.intToBytes(i.length, 2, "little"))), i]) : g([I([r.OP_PUSHDATA4].concat(A.intToBytes(i.length, 4, "little"))), i]), A.readOpCode = A => {
            let i = A.read(1);
            return i.length ? i[0] <= 75 ? [i, A.read(i[0])] : i[0] === r.OP_PUSHDATA1 ? [i, A.read(A.read(1)[0])] : i[0] === r.OP_PUSHDATA2 ? [i, A.read(A.read(2).readIntLE(0, 2))] : i[0] === r.OP_PUSHDATA4 ? [i, A.read(A.read(4).readIntLE(0, 4))] : [i, null] : [null, null]
        }, A.getMultiSigPublicKeys = i => {
            let e = [],
                t = A.readOpCode(i);
            for (; null !== t[0];) t = A.readOpCode(i), null !== t[1] && e.push(t[1]);
            return e
        }, A.signMessage = (g, r, o = {}) => {
            if (e(o, {
                    encoding: "hex|utf8",
                    hex: !1
                }), g = t(g, o.encoding), A.isString(r))
                if (A.isHex(r)) r = I(r, "hex");
                else {
                    if (!A.isWifValid(r)) throw new Error("private key invalid");
                    r = A.wifToPrivateKey(r, {
                        hex: !1
                    })
                }
            else i.isBuffer(r) || (r = I(r));
            if (32 !== r.length) throw new Error("private key length invalid");
            if (32 !== g.length) throw new Error("message length invalid");
            let E, C, Q, h, c, l, u, d = 0;
            try {
                if (E = B(32), C = B(32), Q = B(65), l = B(72), h = B(1), n.HEAPU8.set(g, E), n.HEAPU8.set(r, C), d = n._secp256k1_ecdsa_sign_recoverable(A.secp256k1PrecompContextSign, Q, E, C, null, null), d && (u = s(Q + 64, "i8"), d = n._secp256k1_ecdsa_signature_serialize_der(A.secp256k1PrecompContextSign, l, h, Q), d)) {
                    let A = s(h, "i8");
                    c = new i.alloc(A);
                    for (let i = 0; i < A; i++) c[i] = s(l + i, "i8")
                }
            } finally {
                a(E), a(C), a(Q), a(l), a(h)
            }
            return d ? {
                signature: o.hex ? c.hex() : c,
                recId: u
            } : null
        }, A.verifySignature = (i, e, I) => {
            i = t(i), e = t(e), I = t(I);
            let g, r, o, s, E, C = 0;
            try {
                g = B(I.length), r = B(e.length), o = B(i.length), s = B(64), E = B(65), n.HEAPU8.set(I, g), n.HEAPU8.set(e, r), n.HEAPU8.set(i, o), C = n._secp256k1_ecdsa_signature_parse_der(A.secp256k1PrecompContextSign, s, o, i.length), C && (C = n._secp256k1_ec_pubkey_parse(A.secp256k1PrecompContextVerify, E, r, e.length), C && (C = n._secp256k1_ecdsa_verify(A.secp256k1PrecompContextVerify, s, g, E)))
            } finally {
                a(g), a(r), a(o), a(s)
            }
            return Boolean(C)
        }, A.publicKeyRecovery = (I, g, r, o = {}) => {
            e(o, {
                compressed: !0,
                hex: !0,
                der: !0
            }), I = t(I), g = t(g);
            let E, C, Q, h, c, l, u, d, p, f, y, D = 0;
            try {
                if (E = B(g.length), Q = B(I.length), C = B(64), h = B(64), c = B(65), d = B(65), u = B(65), l = B(1), n.HEAPU8.set(g, E), n.HEAPU8.set(I, Q), o.der ? (D = n._secp256k1_ecdsa_signature_parse_der(A.secp256k1PrecompContextSign, C, Q, I.length), D && (D = n._secp256k1_ecdsa_signature_serialize_compact(A.secp256k1PrecompContextSign, h, C)), D && (D = n._secp256k1_ecdsa_recoverable_signature_parse_compact(A.secp256k1PrecompContextSign, c, h, r))) : D = n._secp256k1_ecdsa_recoverable_signature_parse_compact(A.secp256k1PrecompContextSign, c, Q, r), D && (D = n._secp256k1_ecdsa_recover(A.secp256k1PrecompContextVerify, d, c, E)), D && (o.compressed ? (f = 33, y = A.SECP256K1_EC_COMPRESSED) : (f = 65, y = A.SECP256K1_EC_UNCOMPRESSED), n.HEAP8.set([f], l), D = n._secp256k1_ec_pubkey_serialize(A.secp256k1PrecompContextVerify, u, l, d, y)), D) {
                    p = new i.alloc(f);
                    for (let A = 0; A < f; A++) p[A] = s(u + A, "i8")
                }
            } finally {
                a(E), a(Q), a(C), a(h), a(c), a(d), a(u), a(l)
            }
            return D ? o.hex ? p.hex() : p : null
        }, A.isValidSignatureEncoding = A => {
            let i = (A = t(A)).length;
            if (i < 9 || i > 73 || 48 !== A[0] || A[1] !== i - 3) return !1;
            let e = A[3];
            if (5 + e >= i) return !1;
            let I = A[5 + e];
            return e + I + 7 === i && 2 === A[2] && 0 !== e && 128 !== A[4] && (!(e > 1 && 0 === A[4] && !(128 & A[5]) || 2 !== A[e + 4] || 0 === I || 128 & A[e + 6]) && !(I > 1 && 0 === A[e + 6] && !(128 & A[e + 7])))
        }, A.parseSignature = function(A, i = {}) {
            e(i, {
                hex: !1
            });
            (A = t(A)).length;
            if (!this.isValidSignatureEncoding(A)) throw new Error("invalid signature");
            let I = A[3],
                g = A.slice(5, 4 + I),
                r = A[5 + I];
            return A = A.slice(I + 6, r), [i.hex ? g.hex() : g, i.hex ? A.hex() : A]
        }, A.bitcoinMessage = function(i) {
            return A.doubleSha256(g([A.Buffer.from("Bitcoin Signed Message:\n", "utf8"), I(A.intToVarInt(i.length)), A.Buffer.from(i, "utf8")]), {
                hex: !1
            })
        }, A.signBitcoinMessage = (t, g, r = {}) => {
            e(r, {
                base64: !0
            }), t = A.bitcoinMessage(t);
            let o = 1;
            if (A.isString(g))
                if (A.isHex(g)) g = I(g, "hex");
                else {
                    if (!A.isWifValid(g)) throw new Error("private key invalid");
                    g[0] !== A.MAINNET_PRIVATE_KEY_UNCOMPRESSED_PREFIX && g[0] !== A.TESTNET_PRIVATE_KEY_UNCOMPRESSED_PREFIX || (o = 0), g = A.wifToPrivateKey(g, {
                        hex: !1
                    })
                }
            else i.isBuffer(g) || (g = I(g));
            if (32 !== g.length) throw new Error("private key length invalid");
            let E, C, Q, h, c, l = 0;
            try {
                if (E = B(32), C = B(32), Q = B(65), c = B(65), n.HEAPU8.set(t, E), n.HEAPU8.set(g, C), l = n._secp256k1_ecdsa_sign_recoverable(A.secp256k1PrecompContextSign, Q, E, C, null, null), l && (l = n._secp256k1_ecdsa_recoverable_signature_serialize_compact(A.secp256k1PrecompContextSign, c + 1, c, Q), l)) {
                    h = new i.alloc(65);
                    for (let A = 0; A < 65; A++) h[A] = s(c + A, "i8");
                    h[0] = h[0] + 27 + 4 * o
                }
            } finally {
                a(E), a(C), a(Q), a(c)
            }
            return l ? r.base64 ? h.toString("base64") : h : null
        }, A.bitcoinSignedMessageAddresses = (i, t, g = {}) => {
            e(g, {
                testnet: !1
            }), A.isString(t) && (t = I(t, "base64"));
            let r = t.readInt8([0]);
            if (r < 27 || r >= 35) return [];
            let o = !0;
            r >= 31 ? r -= 4 : o = !1, r -= 27, i = A.bitcoinMessage(i);
            let n = A.publicKeyRecovery(t.slice(1), i, r, {
                compressed: o,
                hex: !0,
                der: !1
            });
            return null !== n ? o ? [A.publicKeyToAddress(n, {
                testnet: g.testnet,
                p2sh_p2wpkh: !1,
                witnessVersion: 0
            }), A.publicKeyToAddress(n, {
                testnet: g.testnet,
                p2sh_p2wpkh: !1,
                witnessVersion: null
            }), A.publicKeyToAddress(n, {
                testnet: g.testnet,
                p2sh_p2wpkh: !0,
                witnessVersion: 0
            })] : [A.publicKeyToAddress(n, {
                testnet: g.testnet,
                p2sh_p2wpkh: !1,
                witnessVersion: null
            })] : []
        }, A.verifyBitcoinMessage = (i, t, I, g = {}) => (e(g, {
            testnet: !1
        }), A.bitcoinSignedMessageAddresses(i, t, g).includes(I))
    }
}, function(A, i) {
    A.exports = function(A) {
        let i = A.__bitcoin_core_crypto.module,
            e = (i._malloc, i._free, A.Buffer.alloc),
            t = A.Buffer.concat,
            I = A.Buffer.from,
            g = A.defArgs,
            r = (A.getBuffer, A.BN);
        i.getValue;
        A.createMasterXPrivateKey = (i, I = {}) => {
            g(I, {
                testnet: !1,
                base58: !0
            });
            let o = A.hmacSha512("Bitcoin seed", i),
                n = o.slice(0, 32),
                B = o.slice(32),
                a = new r(n);
            if (a.gte(A.ECDSA_SEC256K1_ORDER) || a.lte(1)) return null;
            let s = I.testnet ? A.TESTNET_XPRIVATE_KEY_PREFIX : A.MAINNET_XPRIVATE_KEY_PREFIX;
            return s = t([s, e(9, 0), B, e(1, 0), n]), I.base58 ? A.encodeBase58(t([s, A.doubleSha256(s).slice(0, 4)])) : s
        }, A.xPrivateToXPublicKey = (i, e = {}) => {
            if (g(e, {
                    base58: !0
                }), A.isString(i) && (i = A.decodeBase58(i, {
                    hex: !1
                }).slice(0, -4)), !A.isBuffer(i)) throw new Error("invalid xPrivateKey");
            if (78 !== i.length) throw new Error("invalid xPrivateKey");
            let I;
            if (i.slice(0, 4).equals(A.TESTNET_XPRIVATE_KEY_PREFIX)) I = A.TESTNET_XPUBLIC_KEY_PREFIX;
            else if (i.slice(0, 4).equals(A.MAINNET_XPRIVATE_KEY_PREFIX)) I = A.MAINNET_XPUBLIC_KEY_PREFIX;
            else if (i.slice(0, 4).equals(A.MAINNET_M49_XPRIVATE_KEY_PREFIX)) I = A.MAINNET_M49_XPUBLIC_KEY_PREFIX;
            else if (i.slice(0, 4).equals(A.TESTNET_M49_XPRIVATE_KEY_PREFIX)) I = A.TESTNET_M49_XPUBLIC_KEY_PREFIX;
            else if (i.slice(0, 4).equals(A.MAINNET_M84_XPRIVATE_KEY_PREFIX)) I = A.MAINNET_M84_XPUBLIC_KEY_PREFIX;
            else {
                if (!i.slice(0, 4).equals(A.TESTNET_M84_XPRIVATE_KEY_PREFIX)) throw new Error("invalid xPrivateKey");
                I = A.TESTNET_M84_XPUBLIC_KEY_PREFIX
            }
            let r = t([I, i.slice(4, 45), A.privateToPublicKey(i.slice(46), {
                hex: !1
            })]);
            return e.base58 ? A.encodeBase58(t([r, A.doubleSha256(r).slice(0, 4)])) : r
        }, A.__decodePath = (i, e = !1) => {
            if (i = i.split("/"), !e && "m" !== i[0]) throw new Error("invalid path");
            let t = [];
            for (let e = 1; e < i.length; e++) {
                let I = parseInt(i[e]);
                "'" === i[e][i[e].length - 1] && I < A.HARDENED_KEY && (I += A.HARDENED_KEY), t.push(I)
            }
            return t
        }, A.deriveXKey = (i, e, t = {}) => {
            if (g(t, {
                    base58: !0,
                    subPath: !1
                }), A.isString(i) && (i = A.decodeBase58(i, {
                    checkSum: !0,
                    hex: !1
                })), e = A.__decodePath(e, t.subPath), "private" === A.xKeyType(i))
                for (let t of e) i = A.__deriveChildXPrivateKey(i, t);
            else
                for (let t of e) i = A.__deriveChildXPublicKey(i, t);
            return t.base58 ? A.encodeBase58(i, {
                checkSum: !0
            }) : i
        }, A.__deriveChildXPrivateKey = (i, g) => {
            let o = i.slice(13, 45),
                n = i.slice(45),
                B = i[4] + 1;
            if (B > 255) throw new Error("path depth should be <= 255");
            let a = I(n.slice(1)),
                s = A.privateToPublicKey(a, {
                    hex: !1
                }),
                E = A.hash160(s).slice(0, 4),
                C = A.hmacSha512(o, t([g >= A.HARDENED_KEY ? n : s, I(A.intToBytes(g, 4, "big"))])),
                Q = new r(C.slice(0, 32));
            if (Q.gte(A.ECDSA_SEC256K1_ORDER)) return null;
            let h = new r(n.slice(1));
            if (h = h.add(Q), h = h.mod(A.ECDSA_SEC256K1_ORDER), h.isZero()) return null;
            let c = h.toArrayLike(A.Buffer, "be", 32);
            return t([i.slice(0, 4), I([B]), E, I(A.intToBytes(g, 4, "big")), C.slice(32), e(1, 0), c])
        }, A.__deriveChildXPublicKey = (i, e) => {
            let g = i.slice(13, 45),
                o = i.slice(45),
                n = i[4] + 1;
            if (n > 255) throw new Error("path depth should be <= 255");
            if (e >= A.HARDENED_KEY) throw new Error("derivation from extended public key impossible");
            let B = A.hash160(o).slice(0, 4),
                a = A.hmacSha512(g, t([o, I(A.intToBytes(e, 4, "big"))]));
            if (new r(a.slice(0, 32)).gte(A.ECDSA_SEC256K1_ORDER)) return null;
            let s = A.publicKeyAdd(o, a.slice(0, 32), {
                hex: !1
            });
            return t([i.slice(0, 4), I([n]), B, I(A.intToBytes(e, 4, "big")), a.slice(32), s])
        }, A.publicFromXPublicKey = (i, e = {}) => {
            if (g(e, {
                    hex: !0
                }), A.isString(i) && (i = A.decodeBase58(i, {
                    checkSum: !0,
                    hex: !1
                })), 78 !== i.length) throw new Error("invalid extended public key");
            return e.hex ? i.slice(45).hex() : i.slice(45)
        }, A.privateFromXPrivateKey = (i, e = {}) => {
            if (g(e, {
                    wif: !0
                }), A.isString(i) && (i = A.decodeBase58(i, {
                    checkSum: !0,
                    hex: !1
                })), 78 !== i.length) throw new Error("invalid extended public key");
            let t, I = i.slice(0, 4);
            if (I.equals(A.MAINNET_XPRIVATE_KEY_PREFIX)) t = !1;
            else if (I.equals(A.TESTNET_XPRIVATE_KEY_PREFIX)) t = !0;
            else if (I.equals(A.MAINNET_M49_XPRIVATE_KEY_PREFIX)) t = !1;
            else if (I.equals(A.TESTNET_M49_XPRIVATE_KEY_PREFIX)) t = !0;
            else if (I.equals(A.MAINNET_M84_XPRIVATE_KEY_PREFIX)) t = !1;
            else {
                if (!I.equals(A.TESTNET_M84_XPRIVATE_KEY_PREFIX)) throw new Error("invalid extended public key");
                t = !0
            }
            return e.wif ? A.privateKeyToWif(i.slice(46), {
                testnet: t,
                wif: !0
            }) : i.slice(46)
        }, A.isXPrivateKeyValid = i => {
            if (A.isString(i) && (i = A.decodeBase58(i, {
                    checkSum: !0,
                    hex: !1
                })), 78 !== i.length) return !1;
            let e = i.slice(0, 4);
            return !!e.equals(A.MAINNET_XPRIVATE_KEY_PREFIX) || (!!e.equals(A.TESTNET_XPRIVATE_KEY_PREFIX) || (!!e.equals(A.MAINNET_M49_XPRIVATE_KEY_PREFIX) || (!!e.equals(A.TESTNET_M49_XPRIVATE_KEY_PREFIX) || (!!e.equals(A.MAINNET_M84_XPRIVATE_KEY_PREFIX) || e.equals(A.TESTNET_M84_XPRIVATE_KEY_PREFIX)))))
        }, A.isXPublicKeyValid = i => {
            if (A.isString(i) && (i = A.decodeBase58(i, {
                    checkSum: !0,
                    hex: !1
                })), 78 !== i.length) return !1;
            let e = i.slice(0, 4);
            return !!e.equals(A.MAINNET_XPUBLIC_KEY_PREFIX) || (!!e.equals(A.TESTNET_XPUBLIC_KEY_PREFIX) || (!!e.equals(A.MAINNET_M49_XPUBLIC_KEY_PREFIX) || (!!e.equals(A.TESTNET_M49_XPUBLIC_KEY_PREFIX) || (!!e.equals(A.MAINNET_M84_XPUBLIC_KEY_PREFIX) || e.equals(A.TESTNET_M84_XPUBLIC_KEY_PREFIX)))))
        }, A.xKeyNetworkType = i => {
            if (A.isString(i) && (i = A.decodeBase58(i, {
                    checkSum: !0,
                    hex: !1
                })), 78 !== i.length) return !1;
            let e = i.slice(0, 4);
            if (e.equals(A.MAINNET_XPRIVATE_KEY_PREFIX)) return "mainnet";
            if (e.equals(A.TESTNET_XPRIVATE_KEY_PREFIX)) return "testnet";
            if (e.equals(A.MAINNET_M49_XPRIVATE_KEY_PREFIX)) return "mainnet";
            if (e.equals(A.TESTNET_M49_XPRIVATE_KEY_PREFIX)) return "testnet";
            if (e.equals(A.MAINNET_M84_XPRIVATE_KEY_PREFIX)) return "mainnet";
            if (e.equals(A.TESTNET_M84_XPRIVATE_KEY_PREFIX)) return "testnet";
            if (e.equals(A.MAINNET_XPUBLIC_KEY_PREFIX)) return "mainnet";
            if (e.equals(A.TESTNET_XPUBLIC_KEY_PREFIX)) return "testnet";
            if (e.equals(A.MAINNET_M49_XPUBLIC_KEY_PREFIX)) return "mainnet";
            if (e.equals(A.TESTNET_M49_XPUBLIC_KEY_PREFIX)) return "testnet";
            if (e.equals(A.MAINNET_M84_XPUBLIC_KEY_PREFIX)) return "mainnet";
            if (e.equals(A.TESTNET_M84_XPUBLIC_KEY_PREFIX)) return "testnet";
            throw new Error("invalid extended key")
        }, A.xKeyType = i => {
            if (A.isString(i) && (i = A.decodeBase58(i, {
                    checkSum: !0,
                    hex: !1
                })), 78 !== i.length) return !1;
            let e = i.slice(0, 4);
            if (e.equals(A.MAINNET_XPRIVATE_KEY_PREFIX)) return "private";
            if (e.equals(A.TESTNET_XPRIVATE_KEY_PREFIX)) return "private";
            if (e.equals(A.MAINNET_M49_XPRIVATE_KEY_PREFIX)) return "private";
            if (e.equals(A.TESTNET_M49_XPRIVATE_KEY_PREFIX)) return "private";
            if (e.equals(A.MAINNET_M84_XPRIVATE_KEY_PREFIX)) return "private";
            if (e.equals(A.TESTNET_M84_XPRIVATE_KEY_PREFIX)) return "private";
            if (e.equals(A.MAINNET_XPUBLIC_KEY_PREFIX)) return "public";
            if (e.equals(A.TESTNET_XPUBLIC_KEY_PREFIX)) return "public";
            if (e.equals(A.MAINNET_M49_XPUBLIC_KEY_PREFIX)) return "public";
            if (e.equals(A.TESTNET_M49_XPUBLIC_KEY_PREFIX)) return "public";
            if (e.equals(A.MAINNET_M84_XPUBLIC_KEY_PREFIX)) return "public";
            if (e.equals(A.TESTNET_M84_XPUBLIC_KEY_PREFIX)) return "public";
            throw new Error("invalid extended key")
        }, A.xKeyDerivationType = i => {
            if (A.isString(i) && (i = A.decodeBase58(i, {
                    checkSum: !0,
                    hex: !1
                })), 78 !== i.length) return !1;
            let e = i.slice(0, 4);
            return e.equals(A.MAINNET_XPRIVATE_KEY_PREFIX) ? "BIP44" : e.equals(A.TESTNET_XPRIVATE_KEY_PREFIX) ? "BIP44" : e.equals(A.MAINNET_M49_XPRIVATE_KEY_PREFIX) ? "BIP49" : e.equals(A.TESTNET_M49_XPRIVATE_KEY_PREFIX) ? "BIP49" : e.equals(A.MAINNET_M84_XPRIVATE_KEY_PREFIX) ? "BIP84" : e.equals(A.TESTNET_M84_XPRIVATE_KEY_PREFIX) ? "BIP84" : e.equals(A.MAINNET_XPUBLIC_KEY_PREFIX) ? "BIP44" : e.equals(A.TESTNET_XPUBLIC_KEY_PREFIX) ? "BIP44" : e.equals(A.MAINNET_M49_XPUBLIC_KEY_PREFIX) ? "BIP49" : e.equals(A.TESTNET_M49_XPUBLIC_KEY_PREFIX) ? "BIP49" : e.equals(A.MAINNET_M84_XPUBLIC_KEY_PREFIX) ? "BIP84" : e.equals(A.TESTNET_M84_XPUBLIC_KEY_PREFIX) ? "BIP84" : "custom"
        }, A.pathXKeyTo_BIP32_XKey = (i, e = {}) => {
            if (g(e, {
                    base58: !0
                }), A.isString(i) && (i = A.decodeBase58(i, {
                    checkSum: !0,
                    hex: !1
                })), 78 !== i.length) throw new Error("invalid extended key");
            let I, r = i.slice(0, 4);
            if (r.equals(A.MAINNET_XPUBLIC_KEY_PREFIX)) I = r;
            else if (r.equals(A.TESTNET_XPUBLIC_KEY_PREFIX)) I = r;
            else if (r.equals(A.MAINNET_XPRIVATE_KEY_PREFIX)) I = r;
            else if (r.equals(A.TESTNET_XPRIVATE_KEY_PREFIX)) I = r;
            else if (r.equals(A.MAINNET_M49_XPUBLIC_KEY_PREFIX)) I = A.MAINNET_XPUBLIC_KEY_PREFIX;
            else if (r.equals(A.MAINNET_M84_XPUBLIC_KEY_PREFIX)) I = A.MAINNET_XPUBLIC_KEY_PREFIX;
            else if (r.equals(A.TESTNET_M49_XPUBLIC_KEY_PREFIX)) I = A.TESTNET_XPUBLIC_KEY_PREFIX;
            else if (r.equals(A.TESTNET_M84_XPUBLIC_KEY_PREFIX)) I = A.TESTNET_XPUBLIC_KEY_PREFIX;
            else if (r.equals(A.MAINNET_M49_XPRIVATE_KEY_PREFIX)) I = A.MAINNET_XPRIVATE_KEY_PREFIX;
            else if (r.equals(A.TESTNET_M49_XPRIVATE_KEY_PREFIX)) I = A.TESTNET_XPRIVATE_KEY_PREFIX;
            else if (r.equals(A.TESTNET_M84_XPRIVATE_KEY_PREFIX)) I = A.TESTNET_XPRIVATE_KEY_PREFIX;
            else {
                if (!r.equals(A.MAINNET_M84_XPRIVATE_KEY_PREFIX)) throw new Error("invalid extended key");
                I = A.MAINNET_XPRIVATE_KEY_PREFIX
            }
            return e.base58 ? A.encodeBase58(t([I, i.slice(4)]), {
                checkSum: !0
            }) : t([I, i.slice(4)])
        }, A.BIP32_XKeyToPathXKey = (i, e, I = {}) => {
            if (g(I, {
                    base58: !0
                }), !["BIP44", "BIP49", "BIP84"].includes(e)) throw new Error("unsupported path type " + e);
            if (A.isString(i) && (i = A.decodeBase58(i, {
                    checkSum: !0,
                    hex: !1
                })), 78 !== i.length) throw new Error("invalid extended key");
            let r, o = i.slice(0, 4);
            if (o.equals(A.TESTNET_XPRIVATE_KEY_PREFIX)) switch (e) {
                case "BIP44":
                    r = A.TESTNET_M44_XPRIVATE_KEY_PREFIX;
                    break;
                case "BIP49":
                    r = A.TESTNET_M49_XPRIVATE_KEY_PREFIX;
                    break;
                case "BIP84":
                    r = A.TESTNET_M84_XPRIVATE_KEY_PREFIX
            } else if (o.equals(A.MAINNET_XPRIVATE_KEY_PREFIX)) switch (e) {
                    case "BIP44":
                        r = A.MAINNET_M44_XPRIVATE_KEY_PREFIX;
                        break;
                    case "BIP49":
                        r = A.MAINNET_M49_XPRIVATE_KEY_PREFIX;
                        break;
                    case "BIP84":
                        r = A.MAINNET_M84_XPRIVATE_KEY_PREFIX
                } else if (o.equals(A.TESTNET_XPUBLIC_KEY_PREFIX)) switch (e) {
                    case "BIP44":
                        r = A.TESTNET_M44_XPUBLIC_KEY_PREFIX;
                        break;
                    case "BIP49":
                        r = A.TESTNET_M49_XPUBLIC_KEY_PREFIX;
                        break;
                    case "BIP84":
                        r = A.TESTNET_M84_XPUBLIC_KEY_PREFIX
                } else {
                    if (!o.equals(A.MAINNET_XPUBLIC_KEY_PREFIX)) throw new Error("invalid extended key");
                    switch (e) {
                        case "BIP44":
                            r = A.MAINNET_M44_XPUBLIC_KEY_PREFIX;
                            break;
                        case "BIP49":
                            r = A.MAINNET_M49_XPUBLIC_KEY_PREFIX;
                            break;
                        case "BIP84":
                            r = A.MAINNET_M84_XPUBLIC_KEY_PREFIX
                    }
                }
                return I.base58 ? A.encodeBase58(t([r, i.slice(4)]), {
                    checkSum: !0
                }) : t([r, i.slice(4)])
        }
    }
}, function(A, i) {
    A.exports = function(A) {
        let i = A.Buffer,
            e = A.defArgs,
            t = A.getBuffer,
            I = i.from,
            g = i.concat,
            r = A.OPCODE;
        A.hashToAddress = (i, r = {}) => {
            let o, n;
            if (e(r, {
                    testnet: !1,
                    scriptHash: !1,
                    witnessVersion: 0
                }), i = t(i), !r.scriptHash) {
                if (null === r.witnessVersion) {
                    if (20 !== i.length) throw new Error("address hash length incorrect");
                    o = r.testnet ? I(A.TESTNET_ADDRESS_BYTE_PREFIX) : I(A.MAINNET_ADDRESS_BYTE_PREFIX);
                    let e = g([o, i]);
                    return e = g([e, A.doubleSha256(e, {
                        hex: !1
                    }).slice(0, 4)]), A.encodeBase58(e)
                }
                if (20 !== i.length && 32 !== i.length) throw new Error("address hash length incorrect")
            }
            if (null === r.witnessVersion) {
                o = r.testnet ? I(A.TESTNET_SCRIPT_ADDRESS_BYTE_PREFIX) : I(A.MAINNET_SCRIPT_ADDRESS_BYTE_PREFIX);
                let e = g([o, i]);
                return e = g([e, A.doubleSha256(e, {
                    hex: !1
                }).slice(0, 4)]), A.encodeBase58(e)
            }
            r.testnet ? (o = A.TESTNET_SEGWIT_ADDRESS_BYTE_PREFIX, n = A.TESTNET_SEGWIT_ADDRESS_PREFIX) : (o = A.MAINNET_SEGWIT_ADDRESS_BYTE_PREFIX, n = A.MAINNET_SEGWIT_ADDRESS_PREFIX), (i = A.rebase_8_to_5(Array.from(i))).unshift(r.witnessVersion);
            let B = A.bech32Polymod(o.concat(i.concat([0, 0, 0, 0, 0, 0])));
            return B = A.rebase_8_to_5(A.intToBytes(B, 5, "big")).slice(2), n + "1" + A.rebase_5_to_32(i.concat(B), !1)
        }, A.addressToHash = (i, t = {}) => {
            if (e(t, {
                    hex: !1
                }), !A.isString(i)) throw new Error("address invalid");
            let g;
            if (A.ADDRESS_PREFIX_LIST.includes(i[0])) g = A.decodeBase58(i, {
                hex: !1
            }), g = g.slice(1, g.length - 4);
            else {
                if (![A.MAINNET_SEGWIT_ADDRESS_PREFIX, A.TESTNET_SEGWIT_ADDRESS_PREFIX].includes(i.split("1")[0])) return null; {
                    let e = A.rebase_32_to_5(i.split("1")[1]);
                    g = I(A.rebase_5_to_8(e.slice(1, e.length - 6), !1))
                }
            }
            return t.hex ? g.hex() : g
        }, A.publicKeyToAddress = (i, r = {}) => {
            let o;
            if (e(r, {
                    testnet: !1,
                    p2sh_p2wpkh: !1,
                    witnessVersion: 0
                }), i = t(i), r.p2sh_p2wpkh) {
                if (33 !== i.length) throw new Error("public key length invalid");
                o = A.hash160(g([I([0, 20]), A.hash160(i)])), r.witnessVersion = null
            } else {
                if (null !== r.witnessVersion && 33 !== i.length) throw new Error("public key length invalid");
                o = A.hash160(i)
            }
            return r.scriptHash = r.p2sh_p2wpkh, A.hashToAddress(o, r)
        }, A.addressType = (i, t = {}) => {
            if (e(t, {
                    num: !1
                }), [A.TESTNET_SCRIPT_ADDRESS_PREFIX, A.MAINNET_SCRIPT_ADDRESS_PREFIX].includes(i[0])) return t.num ? A.SCRIPT_TYPES.P2SH : "P2SH";
            if ([A.MAINNET_ADDRESS_PREFIX, A.TESTNET_ADDRESS_PREFIX, A.TESTNET_ADDRESS_PREFIX_2].includes(i[0])) return t.num ? A.SCRIPT_TYPES.P2PKH : "P2PKH";
            if ([A.MAINNET_SEGWIT_ADDRESS_PREFIX, A.TESTNET_SEGWIT_ADDRESS_PREFIX].includes(i.slice(0, 2))) {
                if (42 === i.length) return t.num ? A.SCRIPT_TYPES.P2WPKH : "P2WPKH";
                if (62 === i.length) return t.num ? A.SCRIPT_TYPES.P2WSH : "P2WSH"
            }
            return t.num ? A.SCRIPT_TYPES.NON_STANDARD : "NON_STANDARD"
        }, A.addressNetType = i => [A.MAINNET_SCRIPT_ADDRESS_PREFIX, A.MAINNET_ADDRESS_PREFIX].includes(i[0]) ? "mainnet" : i.slice(0, 2) === A.MAINNET_SEGWIT_ADDRESS_PREFIX ? "mainnet" : [A.TESTNET_SCRIPT_ADDRESS_PREFIX, A.TESTNET_ADDRESS_PREFIX, A.TESTNET_ADDRESS_PREFIX_2].includes(i[0]) ? "testnet" : i.slice(0, 2) === A.TESTNET_SEGWIT_ADDRESS_PREFIX ? "testnet" : null, A.addressToScript = (i, t = {}) => {
            if (e(t, {
                    hex: !1
                }), !A.isString(i)) throw new Error("address invalid");
            let o;
            if ([A.TESTNET_SCRIPT_ADDRESS_PREFIX, A.MAINNET_SCRIPT_ADDRESS_PREFIX].includes(i[0])) return o = g([I([r.OP_HASH160, 20]), A.addressToHash(i), I([r.OP_EQUAL])]), t.hex ? o.hex() : o;
            if ([A.MAINNET_ADDRESS_PREFIX, A.TESTNET_ADDRESS_PREFIX, A.TESTNET_ADDRESS_PREFIX_2].includes(i[0])) return o = g([I([r.OP_DUP, r.OP_HASH160, 20]), A.addressToHash(i), I([r.OP_EQUALVERIFY, r.OP_CHECKSIG])]), t.hex ? o.hex() : o;
            if ([A.TESTNET_SEGWIT_ADDRESS_PREFIX, A.MAINNET_SEGWIT_ADDRESS_PREFIX].includes(i.split("1")[0])) {
                let e = A.addressToHash(i);
                return o = g([I([r.OP_0, e.length]), A.addressToHash(i)]), t.hex ? o.hex() : o
            }
            throw new Error("address invalid")
        }, A.getWitnessVersion = i => A.rebase_32_to_5(i.split(1)[1])[0], A.isAddressValid = (i, t = {}) => {
            if (e(t, {
                    testnet: !1
                }), !A.isString(i)) return !1;
            if ([A.MAINNET_ADDRESS_PREFIX, A.MAINNET_SCRIPT_ADDRESS_PREFIX, A.TESTNET_ADDRESS_PREFIX, A.TESTNET_ADDRESS_PREFIX_2, A.TESTNET_SCRIPT_ADDRESS_PREFIX].includes(i[0])) {
                if (!0 === t.testnet) {
                    if (![A.TESTNET_ADDRESS_PREFIX, A.TESTNET_ADDRESS_PREFIX_2, A.TESTNET_SCRIPT_ADDRESS_PREFIX].includes(i[0])) return !1
                } else if (![A.MAINNET_ADDRESS_PREFIX, A.MAINNET_SCRIPT_ADDRESS_PREFIX].includes(i[0])) return !1;
                let e = A.decodeBase58(i, {
                    hex: !1
                });
                if (25 !== e.length) return !1;
                let I = e.slice(-4),
                    g = A.doubleSha256(e.slice(0, -4)).slice(0, 4);
                return I.equals(g)
            } {
                let e, I;
                if ([A.TESTNET_SEGWIT_ADDRESS_PREFIX, A.MAINNET_SEGWIT_ADDRESS_PREFIX].includes(i.split("1")[0].toLowerCase())) {
                    if (42 !== i.length && 62 !== i.length) return !1;
                    let g, r, o = i.split("1");
                    e = o[0], I = o[1], g = e[0] !== e[0].toLowerCase();
                    for (let i = 0; i < I.length; i++)
                        if (!0 === g) {
                            if (-1 === A.BASE32CHARSET_UPCASE.indexOf(I[i])) return !1
                        } else if (-1 === A.BASE32CHARSET.indexOf(I[i])) return !1;
                    if (I = I.toLowerCase(), e = e.toLowerCase(), !0 === t.testnet) {
                        if (e !== A.TESTNET_SEGWIT_ADDRESS_PREFIX) return !1;
                        r = A.TESTNET_SEGWIT_ADDRESS_BYTE_PREFIX
                    } else {
                        if (e !== A.MAINNET_SEGWIT_ADDRESS_PREFIX) return !1;
                        r = A.MAINNET_SEGWIT_ADDRESS_BYTE_PREFIX
                    }
                    let n = A.rebase_32_to_5(I),
                        B = n.slice(0, -6),
                        a = n.slice(-6);
                    r = r.concat(B).concat([0, 0, 0, 0, 0, 0]);
                    let s = A.bech32Polymod(r);
                    return s = A.rebase_8_to_5(A.intToBytes(s, 5, "big")).slice(2), A.bytesToString(a) === A.bytesToString(s)
                }
                return !1
            }
        }
    }
}, function(A, i) {
    A.exports = function(A) {
        let i = A.Buffer,
            e = i.from,
            t = i.concat,
            I = i.alloc,
            g = A.isBuffer,
            r = A.getBuffer,
            o = A.defArgs,
            n = A.__bitcoin_core_crypto.module,
            B = n._malloc,
            a = n._free,
            s = n.getValue;
        A.createPrivateKey = (i = {}) => (o(i, {
            compressed: !0,
            testnet: !1,
            wif: !0,
            hex: !1
        }), i.wif ? A.privateKeyToWif(A.generateEntropy({
            hex: !1
        }), i) : i.hex ? A.generateEntropy({
            hex: !0
        }) : A.generateEntropy({
            hex: !1
        })), A.privateKeyToWif = (I, g = {}) => {
            if (o(g, {
                    compressed: !0,
                    testnet: !1
                }), 32 !== (I = r(I)).length) throw new Error("invalid byte string");
            let n;
            return n = g.testnet ? e(A.TESTNET_PRIVATE_KEY_BYTE_PREFIX) : e(A.MAINNET_PRIVATE_KEY_BYTE_PREFIX), I = g.compressed ? t([n, I, i.from([1])]) : t([n, I]), I = t([I, A.doubleSha256(I).slice(0, 4)]), A.encodeBase58(I)
        }, A.wifToPrivateKey = (i, e = {}) => {
            if (o(e, {
                    hex: !0
                }), i = A.decodeBase58(i, {
                    hex: !1
                }), !A.doubleSha256(i.slice(0, i.length - 4), {
                    hex: !1
                }).slice(0, 4).equals(i.slice(i.length - 4, i.length))) throw new Error("invalid byte string");
            return e.hex ? i.slice(1, 33).hex() : i.slice(1, 33)
        }, A.isWifValid = i => {
            if (!A.isString(i)) return !1;
            if (!A.PRIVATE_KEY_PREFIX_LIST.includes(i[0])) return !1;
            try {
                let e = A.decodeBase58(i, {
                        hex: !1
                    }),
                    t = e.slice(e.length - 4, e.length);
                if ([A.MAINNET_PRIVATE_KEY_UNCOMPRESSED_PREFIX, A.TESTNET_PRIVATE_KEY_UNCOMPRESSED_PREFIX].includes(i[0])) {
                    if (37 !== e.length) return !1
                } else if (38 !== e.length) return !1;
                return A.doubleSha256(e.slice(0, e.length - 4), {
                    hex: !1
                }).slice(0, 4).equals(t)
            } catch (A) {}
            return !1
        }, A.privateToPublicKey = (e, t = {}) => {
            if (o(t, {
                    compressed: !0,
                    hex: !0
                }), !g(e)) {
                if (!A.isString(e)) throw new Error("invalid private key string");
                if (A.isHex(e)) e = i.from(e, "hex");
                else {
                    [A.MAINNET_PRIVATE_KEY_UNCOMPRESSED_PREFIX, A.TESTNET_PRIVATE_KEY_UNCOMPRESSED_PREFIX].includes(e[0]) && (t.compressed = !1), e = A.wifToPrivateKey(e, {
                        hex: !1
                    })
                }
            }
            if (32 !== e.length) throw new Error("private key length invalid");
            let r = B(32),
                E = B(64);
            n.HEAPU8.set(e, r), n._secp256k1_ec_pubkey_create(A.secp256k1PrecompContextSign, E, r), a(r);
            let C = new I(64);
            for (let A = 0; A < 64; A++) C[A] = s(E + A, "i8");
            let Q = t.compressed ? 33 : 65,
                h = B(65),
                c = B(1);
            n.HEAPU8.set([Q], c);
            let l, u = t.compressed ? A.SECP256K1_EC_COMPRESSED : A.SECP256K1_EC_UNCOMPRESSED;
            if (n._secp256k1_ec_pubkey_serialize(A.secp256k1PrecompContextVerify, h, c, E, u)) {
                l = new I(Q);
                for (let A = 0; A < Q; A++) l[A] = s(h + A, "i8")
            } else l = !1;
            if (a(E), a(c), a(h), !1 === l) throw new Error("privateToPublicKey failed");
            return t.hex ? l.hex() : l
        }, A.isPublicKeyValid = i => {
            if (A.isString(i)) {
                if (!A.isHex(i)) return !1;
                i = e(i, "hex")
            }
            return !(i.length < 33) && ((4 !== i[0] || 65 === i.length) && ((2 !== i[0] && 3 !== i[0] || 33 === i.length) && !(i[0] < 2 || i[0] > 4)))
        }, A.publicKeyAdd = (i, e, t = {}) => {
            o(t, {
                compressed: !0,
                hex: !0
            }), i = A.getBuffer(i), e = A.getBuffer(e);
            let g = B(65),
                r = B(e.length);
            n.HEAPU8.set(i, g), n.HEAPU8.set(e, r);
            let E = B(65),
                C = n._secp256k1_ec_pubkey_parse(A.secp256k1PrecompContextVerify, E, g, i.length);
            if (!C) throw new Error("publicKeyAdd failed");
            if (C = n._secp256k1_ec_pubkey_tweak_add(A.secp256k1PrecompContextVerify, E, r), a(r), !C) throw new Error("publicKeyAdd failed");
            let Q, h = t.compressed ? A.SECP256K1_EC_COMPRESSED : A.SECP256K1_EC_UNCOMPRESSED,
                c = t.compressed ? 33 : 65,
                l = B(65),
                u = B(1);
            if (n.HEAPU8.set([c], u), C = n._secp256k1_ec_pubkey_serialize(A.secp256k1PrecompContextVerify, l, u, E, h), a(E), a(g), C) {
                Q = new I(c);
                for (let A = 0; A < c; A++) Q[A] = s(l + A, "i8")
            } else Q = !1;
            if (a(u), a(l), !1 === Q) throw new Error("publicKeyAdd failed");
            return t.hex ? Q.hex() : Q
        }
    }
}, function(A, i) {
    A.exports = function(A) {
        let i = A.BN,
            e = A.__nodeCrypto,
            t = A.getWindow(),
            I = A.defArgs;
        A.getRandomValues = A => {
            if (t.crypto && t.crypto.getRandomValues) return t.crypto.getRandomValues(A);
            if ("object" == typeof t.msCrypto && "function" == typeof t.msCrypto.getRandomValues) return t.msCrypto.getRandomValues(A);
            if (!1 !== e) {
                if (!(A instanceof Uint8Array)) throw new TypeError("expected Uint8Array");
                if (A.length > 65536) {
                    let i = new Error;
                    throw i.code = 22, i.message = "Failed to execute 'getRandomValues' on 'Crypto': The ArrayBufferView's byte length (" + A.length + ") exceeds the number of bytes of entropy available via this API (65536).", i.name = "QuotaExceededError", i
                }
                let i = e.randomBytes(A.length);
                return A.set(i), A
            }
            throw new Error("No secure random number generator available.")
        }, A.lngamma = i => {
            if (i < 0) return null;
            let e = A.GAMMA_TABLE_LN[0];
            for (let t = A.GAMMA_TABLE_LN.length - 1; t > 0; --t) e += A.GAMMA_TABLE_LN[t] / (i + t);
            let t = i + A.GAMMA_NUM_LN + .5;
            return .5 * Math.log(2 * Math.PI) + (i + .5) * Math.log(t) - t + Math.log(e) - Math.log(i)
        }, A.igam = (i, e) => {
            if (e <= 0 || i <= 0) return 0;
            if (e > 1 && e > i) return 1 - A.igamc(i, e);
            let t, I, g, r;
            if (I = i * Math.log(e) - e - A.lngamma(i), I < -A.MAXLOG) return 0;
            I = Math.exp(I), r = i, g = 1, t = 1;
            do {
                r += 1, g *= e / r, t += g
            } while (g / t > A.MACHEP);
            return t * I / i
        }, A.igamc = (i, e) => {
            if (e <= 0 || i <= 0) return 1;
            if (e < 1 || e < i) return 1 - igam(i, e);
            let t, I, g, r, o, n, B, a, s, E, C, Q, h, c, l = 2220446049250313e-31;
            if (I = i * Math.log(e) - e - A.lngamma(i), I < -A.MAXLOG) return 0;
            I = Math.exp(I), B = 1 - i, a = e + B + 1, g = 0, C = 1, c = e, E = e + 1, h = a * e, t = E / h;
            do {
                g += 1, B += 1, a += 2, r = B * g, s = E * a - C * r, Q = h * a - c * r, 0 !== Q ? (o = s / Q, n = Math.abs((t - o) / o), t = o) : n = 1, C = E, E = s, c = h, h = Q, Math.abs(s) > 4503599627370496 && (C *= l, E *= l, c *= l, h *= l)
            } while (n > A.MACHEP);
            return t * I
        }, A.erfc = A => {
            let i = Math.abs(A),
                e = 1 / (1 + i / 2),
                t = e * Math.exp(-i * i - 1.26551223 + e * (1.00002368 + e * (.37409196 + e * (.09678418 + e * (e * (.27886807 + e * (e * (1.48851587 + e * (.17087277 * e - .82215223)) - 1.13520398)) - .18628806)))));
            return A >= 0 ? t : 2 - t
        }, A.randomnessTest = e => {
            let t = new i(e).toString(2).padStart(256, "0"),
                I = t.length,
                g = (t.match(/0/g) || []).length,
                r = (t.match(/1/g) || []).length,
                o = Math.abs(r - g) / Math.sqrt(2 * I);
            if (!(A.erfc(o) > .01)) throw new Error("Frequency (Monobit) Test failed.");
            let n = r / I;
            if (!(Math.abs(n - .5) < 2 / Math.sqrt(I))) throw new Error("Runs Test failed.");
            let B = 1;
            for (let A = 0; A < I - 1; A++) B += t[A] === t[A + 1] ? 0 : 1;
            let a = B - 2 * I * n * (1 - n),
                s = 2 * Math.sqrt(2 * I) * n * (1 - n);
            if (!(A.erfc(Math.abs(a) / s) > .01)) throw new Error("Runs Test failed.");
            t = [t.substring(0, 128).match(/.{1,8}/g), t.substring(128, 256).match(/.{1,8}/g)];
            for (let i = 0; i < 2; i++) {
                let e = t[i];
                B = [0, 0, 0, 0];
                for (let A = 0; A < e.length; A++) {
                    switch (e[A].split("0").reduce((function(A, i) {
                        return A.length > i.length ? A : i
                    })).length) {
                        case 0:
                        case 1:
                            B[0] += 1;
                            break;
                        case 2:
                            B[1] += 1;
                            break;
                        case 3:
                            B[2] += 1;
                            break;
                        default:
                            B[3] += 1
                    }
                }
                let I = 3,
                    g = 16;
                n = [.2148, .3672, .2305, .1875];
                let r = Math.pow(B[0] - g * n[0], 2) / (g * n[0]);
                if (r += Math.pow(B[1] - g * n[1], 2) / (g * n[1]), r += Math.pow(B[2] - g * n[2], 2) / (g * n[2]), r += Math.pow(B[3] - g * n[3], 2) / (g * n[3]), !(A.igamc(I / 2, r / 2) > .01)) throw new Error("Test for the Longest Run of Ones in a Block failed.")
            }
        }, A.generateEntropy = (e = {}) => {
            if (I(e, {
                    strength: 256,
                    hex: !0,
                    sec256k1Order: !0
                }), ![128, 160, 192, 224, 256].includes(e.strength)) throw new TypeError("strength should be one of the following [128, 160, 192, 224, 256]");
            let t, g, r = A.Buffer.alloc(32),
                o = 0;
            do {
                if (g = !0, o++ > 100) throw new Error("Generate randomness failed");
                if (A.getRandomValues(r), !e.sec256k1Order || (t = new i(r), !t.gte(A.ECDSA_SEC256K1_ORDER))) try {
                    A.randomnessTest(r)
                } catch (A) {
                    g = !1
                }
            } while (!g);
            return r = r.slice(0, e.strength / 8), e.hex ? r.hex() : r
        }, A.entropyToMnemonic = (e, t = {}) => {
            I(t, {
                wordList: A.BIP39_WORDLIST,
                data: !1
            }), e = A.getBuffer(e);
            let g = new i(e, 16);
            if (![16, 20, 24, 28, 32].includes(e.length)) throw new TypeError("entropy length should be one of the following: [16, 20, 24, 28, 32]");
            if (!(t.wordList instanceof Array) || 2048 !== t.wordList.length) throw new TypeError("invalid wordlist");
            let r = Math.ceil(8 * e.length / 32);
            if (!1 !== t.data) {
                if (t.data > 2 ** r - 1) throw new TypeError("embedded data bits too long");
                g = g.shln(r).or(new i(t.data))
            } else g = g.shln(r).or(new i(A.sha256(e)[0] >> 8 - r));
            let o = [];
            for (let A = (8 * e.length + 8) / 11 | 0; A > 0; A--) o.push(t.wordList[g.shrn(11 * (A - 1)).and(new i(2047)).toNumber()]);
            return o.join(" ")
        }, A.mnemonicToEntropy = (e, t = {}) => {
            if (I(t, {
                    wordList: A.BIP39_WORDLIST,
                    checkSum: !1,
                    hex: !0
                }), e = e.trim().split(/\s+/), !A.isMnemonicValid(e, t)) throw new TypeError("invalid mnemonic words");
            let g = new i(0);
            for (let A of e) g = g.shln(11).or(new i(t.wordList.indexOf(A)));
            let r = 11 * e.length,
                o = r % 32;
            return g = g.shrn(o), g = g.toArrayLike(A.Buffer, "be", Math.ceil((r - o) / 8)), t.hex ? g.hex() : g
        }, A.mnemonicToSeed = (i, e = {}) => {
            if (I(e, {
                    passphrase: "",
                    checkSum: !1,
                    hex: !0
                }), !A.isString(i)) throw new Error("mnemonic should be string");
            if (!A.isString(e.passphrase)) throw new Error("passphrase should be string");
            let t = A.pbdkdf2HmacSha512(i, "mnemonic" + e.passphrase, 2048);
            return e.hex ? t.hex() : t
        }, A.isMnemonicValid = (i, e = {}) => {
            I(e, {
                wordList: A.BIP39_WORDLIST
            }), A.isString(i) && (i = i.trim().split(/\s+/));
            for (let A of i)
                if (!e.wordList.includes(A)) return !1;
            return !0
        }, A.isMnemonicCheckSumValid = (i, e = {}) => {
            let t;
            I(e, {
                wordList: A.BIP39_WORDLIST
            });
            try {
                t = A.mnemonicToEntropy(i, {
                    wordList: e.wordList,
                    hex: !1
                })
            } catch (t) {
                return !1
            }
            let g = 11 * (i = i.trim().split(/\s+/)).length % 32;
            return A.sha256(t)[0] >> 8 - g === (A.intToBytes(e.wordList.indexOf(i.pop()), 1) & 2 ** g - 1)
        }, A.getMnemonicCheckSumData = (i, e = {}) => {
            I(e, {
                wordList: A.BIP39_WORDLIST
            });
            let t = 11 * (i = i.trim().split(/\s+/)).length % 32;
            return A.intToBytes(e.wordList.indexOf(i.pop()), 1) & 2 ** t - 1
        }, A.__combinations = (A, i) => {
            let e, t = [],
                I = Math.pow(2, A.length);
            for (let g = i; g < I; g++) {
                let I = [];
                e = A.length - 1;
                do {
                    0 != (g & 1 << e) && I.push(A[e])
                } while (e--);
                I.length >= i && t.push(I)
            }
            return t
        }, A.splitMnemonic = (i, e, t, g = {}) => {
            I(g, {
                wordList: A.BIP39_WORDLIST,
                checkSumVerify: !1,
                sharesVerify: !1,
                embeddedIndex: !1,
                hex: !0
            });
            let r, o = A.mnemonicToEntropy(t, {
                wordList: g.wordList,
                checkSum: g.checkSumVerify,
                hex: !1
            });
            r = g.embeddedIndex ? Math.ceil(Math.log2(e)) + 1 : 8;
            let n, B = A.__split_secret(i, e, o, r);
            if (g.sharesVerify) {
                let e = [];
                for (let A in B) A = parseInt(A), e.push([A, B[A]]);
                let t = A.__combinations(e, i);
                for (let i of t) {
                    let e = {};
                    for (let A of i) e[A[0]] = A[1];
                    if (!A.__restore_secret(e).equals(o)) throw new Error("split secret failed")
                }
            }
            if (!1 === g.embeddedIndex) {
                n = {};
                for (let i in B) n[i] = A.entropyToMnemonic(B[i], g)
            } else {
                n = [];
                for (let i in B) g.data = i, n.push(A.entropyToMnemonic(B[i], g))
            }
            return n
        }, A.combineMnemonic = (i, e = {}) => {
            let t = {};
            if (i.constructor === Array)
                for (let I of i) {
                    let i = A.mnemonicToEntropy(I, {
                            wordList: e.wordList,
                            checkSum: !1,
                            hex: !1
                        }),
                        g = A.getMnemonicCheckSumData(I);
                    if (void 0 !== t[g]) throw new Error("Non unique or invalid shares");
                    t[g] = i
                } else
                    for (let I in i) t[I] = A.mnemonicToEntropy(i[I], {
                        wordList: e.wordList,
                        checkSum: e.checkSum,
                        hex: !1
                    });
            return A.entropyToMnemonic(A.__restore_secret(t), e)
        }
    }
}, function(A, i) {
    A.exports = function(A) {
        A.BIP39_WORDLIST = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"]
    }
}, function(A, i) {
    A.exports = function(A) {
        let i = A.Buffer.alloc,
            e = A.Buffer.from,
            t = A.Buffer.concat;
        A.__precompute_GF256_expLog = A => {
            let e = i(255, 0),
                t = i(256, 0),
                I = 1;
            for (let A = 0; A < 255; A++) e[A] = I, t[I] = A, I ^= I << 1, 256 & I && (I ^= 283);
            A.GF256_EXP_TABLE = e, A.GF256_LOG_TABLE = t
        }, A.__GF256_mul = (i, e) => 0 === i || 0 === e ? 0 : A.GF256_EXP_TABLE[A.__mod(A.GF256_LOG_TABLE[i] + A.GF256_LOG_TABLE[e], 255)], A.__GF256_pow = (i, e) => {
            if (0 === e) return 1;
            if (0 === i) return 0;
            let t = i;
            for (let I = 0; I < e - 1; I++) t = A.__GF256_mul(t, i);
            return t
        }, A.__mod = (A, i) => (A % i + i) % i, A.__GF256_add = (A, i) => A ^ i, A.__GF256_sub = (A, i) => A ^ i, A.__GF256_inverse = i => {
            if (0 === i) throw new Error("Zero division");
            return A.GF256_EXP_TABLE[A.__mod(-1 * A.GF256_LOG_TABLE[i], 255)]
        }, A.__GF256_div = (i, e) => {
            if (0 === e) throw new Error("Zero division");
            if (0 === i) return 0;
            let t = A.GF256_EXP_TABLE[A.__mod(A.GF256_LOG_TABLE[i] - A.GF256_LOG_TABLE[e], 255)];
            if (i !== A.__GF256_mul(t, e)) throw new Error("failed");
            return t
        }, A.__shamirFn = (i, e) => {
            let t = 0;
            for (let I of e) t = A.__GF256_add(t, A.__GF256_mul(I, A.__GF256_pow(i, e.indexOf(I))));
            return t
        }, A.__shamirInterpolation = i => {
            let e = i.length;
            if (e < 2) throw new Error("Minimum 2 points required");
            i.sort((A, i) => A[0] - i[0]);
            let t = new Set;
            for (let A of i) t.add(A[0]);
            if (t.size !== i.length) throw new Error("Unique points required");
            let I = 0;
            for (let t = 0; t < e; t++) {
                let g = 1;
                for (let I = 0; I < e; I++) {
                    if (I === t) continue;
                    let e = i[I][0],
                        r = A.__GF256_add(i[t][0], i[I][0]),
                        o = A.__GF256_div(e, r);
                    g = A.__GF256_mul(g, o)
                }
                g = A.__GF256_mul(i[t][1], g), I = A.__GF256_add(I, g)
            }
            return I
        }, A.__split_secret = (i, I, g, r = 8) => {
            if (i > 255) throw new Error("threshold limit 255");
            if (I > 255) throw new Error("total limit 255");
            let o = 2 ** r - 1;
            if (I > o) throw new Error("index bits is to low");
            if (i > I) throw new Error("invalid threshold");
            let n, B, a = {},
                s = [],
                E = A.generateEntropy({
                    hex: !1
                }),
                C = 0,
                Q = 0;
            do {
                C >= E.length && (E = A.generateEntropy({
                    hex: !1
                }), C = 0), n = E[C] & o, void 0 === a[n] && 0 !== n && (Q++, a[n] = e([]), s.push(n)), C++
            } while (Q !== I);
            E = A.generateEntropy({
                hex: !1
            }), C = 0;
            for (let I = 0; I < g.length; I++) {
                let r = [g[I]];
                for (let e = 0; e < i - 1; e++) {
                    do {
                        C >= E.length && (C = 0, E = A.generateEntropy({
                            hex: !1
                        })), B = E[C++]
                    } while (r.includes(B));
                    r.push(B)
                }
                for (let i of s) a[i] = t([a[i], e([A.__shamirFn(i, r)])])
            }
            return a
        }, A.__restore_secret = i => {
            let I = e([]),
                g = null;
            for (let A in i) {
                if (A = parseInt(A), A < 1 || A > 255) throw new Error("Invalid share index " + A);
                if (null === g && (g = i[A].length), g !== i[A].length || 0 === g) throw new Error("Invalid shares")
            }
            for (let r = 0; r < g; r++) {
                let g = [];
                for (let A in i) A = parseInt(A), g.push([A, i[A][r]]);
                I = t([I, e([A.__shamirInterpolation(g)])])
            }
            return I
        }, A.__precompute_GF256_expLog(A)
    }
}, function(A, i, e) {
    (function(i) {
        A.exports = function(A) {
            let e = A.__bitcoin_core_crypto.module,
                t = i.alloc,
                I = i.concat,
                g = A.getBuffer,
                r = A.defArgs,
                o = e._malloc,
                n = e._free,
                B = e.getValue;
            A.encodeBase58 = (i, a = {}) => {
                if (r(a, {
                        encoding: "hex|utf8",
                        checkSum: !1
                    }), i = g(i, a.encoding), a.checkSum && (i = I([i, A.doubleSha256(i).slice(0, 4)])), i.length > 1073741823) throw new Error("encodeBase58 message is too long");
                let s = o(i.length),
                    E = 138 * i.length / 100 + 1,
                    C = o(138 * i.length / 100 + 1);
                e.HEAPU8.set(i, s), e._EncodeBase58(s, s + i.length, C);
                let Q, h = new t(E);
                for (Q = 0; Q <= E && (h[Q] = B(C + Q, "i8"), 0 !== h[Q]); Q++);
                return n(s), n(C), h.slice(0, Q).toString()
            }, A.decodeBase58 = (i, I = {}) => {
                if (r(I, {
                        hex: !0,
                        checkSum: !1
                    }), !A.isString(i)) throw new Error("decodeBase58 string required");
                if (i.length > 2147483647) throw new Error("decodeBase58 string is too long");
                let g = new t(i.length + 1);
                g.write(i), g.writeInt8(0, i.length);
                let a = o(g.length),
                    s = o(4),
                    E = o(Math.ceil(733 * i.length / 1e3) + 2);
                e.HEAPU8.set(g, a);
                let C = e._DecodeBase58(a, E, s);
                if (n(a), C) {
                    let A = e.getValue(s, "i32");
                    n(s);
                    let i = new t(A);
                    for (let e = 0; e <= A; e++) i[e] = B(E + e, "i8");
                    return n(E), I.checkSum && (i = i.slice(0, -4)), I.hex ? i.hex() : i
                }
                return n(E), n(s), ""
            }, A.rebaseBits = (A, i, e, t) => {
                void 0 === t && (t = !0);
                let I = 0,
                    g = 0,
                    r = [],
                    o = (1 << e) - 1,
                    n = (1 << i + e - 1) - 1;
                for (let t = 0; t < A.length; t++) {
                    let B = A[t];
                    if (B < 0 || B >> i) throw "invalid bytes";
                    for (I = (I << i | B) & n, g += i; g >= e;) g -= e, r.push(I >> g & o)
                }
                if (!0 === t) g && r.push(I << e - g & o);
                else if (g >= i || I << e - g & o) throw "invalid padding";
                return r
            }, A.rebase_5_to_8 = function(i, e) {
                return void 0 === e && (e = !0), A.rebaseBits(i, 5, 8, e)
            }, A.rebase_8_to_5 = (i, e) => (void 0 === e && (e = !0), A.rebaseBits(i, 8, 5, e)), A.rebase_32_to_5 = i => {
                "string" != typeof i && (i = A.bytesToString(i));
                let e = [];
                try {
                    for (let t = 0; t < i.length; t++) e.push(A.INT_BASE32_MAP[i[t]])
                } catch (A) {
                    throw "Non base32 characters"
                }
                return e
            }, A.rebase_5_to_32 = (i, e) => {
                void 0 === e && (e = !0);
                let t = [];
                for (let e = 0; e < i.length; e++) t.push(A.BASE32_INT_MAP[i[e]]);
                return !0 === e ? t : A.bytesToString(t)
            }, A.bech32Polymod = A => {
                let i = [996825010, 642813549, 513874426, 1027748829, 705979059],
                    e = 1;
                for (let t = 0; t < A.length; t++) {
                    let I = e >> 25;
                    e = (33554431 & e) << 5 ^ A[t];
                    for (let A = 0; A < 5; A++) e ^= I >> A & 1 ? i[A] : 0
                }
                return 1 ^ e
            }
        }
    }).call(this, e(0).Buffer)
}, function(A, i) {
    A.exports = function(A) {
        let i = A.__bitcoin_core_crypto.module,
            e = i._malloc,
            t = i._free,
            I = A.Buffer.alloc,
            g = A.defArgs,
            r = A.getBuffer,
            o = A.BN,
            n = i.getValue;
        A.sha256 = (A, o = {}) => {
            g(o, {
                encoding: "hex|utf8",
                hex: !1
            }), A = r(A, o.encoding);
            let B = e(A.length),
                a = e(32);
            i.HEAPU8.set(A, B), i._single_sha256(B, A.length, a);
            let s = new I(32);
            for (let A = 0; A < 32; A++) s[A] = n(a + A, "i8");
            return t(B), t(a), o.hex ? s.hex() : s
        }, A.SHA256 = class {
            constructor() {
                return this.ptr = new i.CSHA256, this.result = new I(32), this
            }
            update(A, I = {}) {
                g(I, {
                    encoding: "hex|utf8"
                }), A = r(A, I.encoding);
                let o = e(A.length);
                return i.HEAPU8.set(A, o), this.ptr.Write(o, A.length), t(o), this
            }
            digest() {
                let A = e(32);
                this.ptr.Finalize(A);
                for (let i = 0; i < 32; i++) this.result[i] = n(A + i, "i8");
                return t(A), this.result
            }
            hexdigest() {
                let A = e(32);
                this.ptr.Finalize(A);
                for (let i = 0; i < 32; i++) this.result[i] = n(A + i, "i8");
                return t(A), this.result.hex()
            }
        }, A.doubleSha256 = (A, o = {}) => {
            g(o, {
                encoding: "hex|utf8",
                hex: !1
            }), A = r(A, o.encoding);
            let B = e(A.length),
                a = e(32);
            i.HEAPU8.set(A, B), i._double_sha256(B, A.length, a);
            let s = new I(32);
            for (let A = 0; A < 32; A++) s[A] = n(a + A, "i8");
            return t(B), t(a), o.hex ? s.hex() : s
        }, A.siphash = (B, a = {}) => {
            if (g(a, {
                    encoding: "hex|utf8",
                    v0: A.BNZerro,
                    v1: A.BNZerro
                }), !(a.v1 instanceof o && a.v0 instanceof o)) throw new Error("siphash init vectors v0, v1 must be BN instance");
            B = r(B, a.encoding);
            let s = a.v0.toArrayLike(Uint8Array, "le", 8),
                E = a.v1.toArrayLike(Uint8Array, "le", 8),
                C = e(B.length),
                Q = e(8),
                h = e(8),
                c = e(8);
            i.HEAPU8.set(B, C), i.HEAPU8.set(s, Q), i.HEAPU8.set(E, h), i._siphash(Q, h, C, B.length, c);
            let l = new I(9);
            for (let A = 0; A < 8; A++) l[8 - A] = n(c + A, "i8");
            return t(C), t(c), new o(l)
        }, A.ripemd160 = (A, o = {}) => {
            g(o, {
                encoding: "hex|utf8",
                hex: !1
            }), A = r(A, o.encoding);
            let B = e(A.length),
                a = e(32);
            i.HEAPU8.set(A, B), i.__ripemd160(B, A.length, a);
            let s = new I(20);
            for (let A = 0; A < 20; A++) s[A] = n(a + A, "i8");
            return t(B), t(a), o.hex ? s.hex() : s
        }, A.md5 = (A, o = {}) => {
            g(o, {
                encoding: "hex|utf8",
                hex: !1
            }), A = r(A, o.encoding);
            let B = e(A.length),
                a = e(16);
            i.HEAPU8.set(A, B), i._md5sum(B, A.length, a);
            let s = new I(16);
            for (let A = 0; A < 16; A++) s[A] = n(a + A, "i8");
            return t(B), t(a), o.hex ? s.hex() : s
        }, A.hash160 = (i, e = {}) => (g(e, {
            encoding: "hex|utf8",
            hex: !1
        }), A.ripemd160(A.sha256(i, {
            hex: !1,
            encoding: e.encoding
        }), {
            hex: e.hex
        })), A.hmacSha512 = (A, o, B = {}) => {
            g(B, {
                encoding: "hex|utf8",
                hex: !1
            }), A = r(A, B.encoding), o = r(o, B.encoding);
            let a = e(A.length),
                s = e(o.length),
                E = e(64);
            i.HEAPU8.set(A, a), i.HEAPU8.set(o, s), i._hmac_sha512_oneline(a, A.length, s, o.length, E);
            let C = new I(64);
            for (let A = 0; A < 64; A++) C[A] = n(E + A, "i8");
            return t(a), t(s), t(E), B.hex ? C.hex() : C
        }, A.pbdkdf2HmacSha512 = (A, o, B, a = {}) => {
            g(a, {
                encoding: "utf8",
                hex: !1
            });
            let s = r(A, a.encoding),
                E = r(o, a.encoding),
                C = e(s.length),
                Q = e(E.length),
                h = e(64);
            i.HEAPU8.set(s, C), i.HEAPU8.set(E, Q), i._pbkdf2_hmac_sha512(C, s.length, Q, E.length, B, h, 64);
            let c = new I(64);
            for (let A = 0; A < 64; A++) c[A] = n(h + A, "i8");
            return t(C), t(Q), t(h), a.hex ? c.hex() : c
        }
    }
}, function(A, i) {
    const e = {
        OP_FALSE: 0,
        OP_0: 0,
        OP_PUSHDATA1: 76,
        OP_PUSHDATA2: 77,
        OP_PUSHDATA4: 78,
        OP_1NEGATE: 79,
        OP_RESERVED: 80,
        OP_TRUE: 81,
        OP_1: 81,
        OP_2: 82,
        OP_3: 83,
        OP_4: 84,
        OP_5: 85,
        OP_6: 86,
        OP_7: 87,
        OP_8: 88,
        OP_9: 89,
        OP_10: 90,
        OP_11: 91,
        OP_12: 92,
        OP_13: 93,
        OP_14: 94,
        OP_15: 95,
        OP_16: 96,
        OP_NOP: 97,
        OP_VER: 98,
        OP_IF: 99,
        OP_NOTIF: 100,
        OP_VERIF: 101,
        OP_ELSE: 103,
        OP_ENDIF: 104,
        OP_VERIFY: 105,
        OP_RETURN: 106,
        OP_TOALTSTACK: 107,
        OP_FROMALTSTACK: 108,
        OP_2DROP: 109,
        OP_2DUP: 110,
        OP_3DUP: 111,
        OP_2OVER: 112,
        OP_2ROT: 113,
        OP_2SWAP: 114,
        OP_IFDUP: 115,
        OP_DEPTH: 116,
        OP_DROP: 117,
        OP_DUP: 118,
        OP_NIP: 119,
        OP_OVER: 120,
        OP_PICK: 121,
        OP_ROLL: 122,
        OP_ROT: 123,
        OP_SWA: 124,
        OP_TUCK: 125,
        OP_CAT: 126,
        OP_SUBSTR: 127,
        OP_LEFT: 128,
        OP_RIGHT: 129,
        OP_SIZE: 130,
        OP_INVERT: 131,
        OP_AND: 132,
        OP_OR: 133,
        OP_XOR: 134,
        OP_EQUAL: 135,
        OP_EQUALVERIFY: 136,
        OP_RESERVED1: 137,
        OP_RESERVED2: 138,
        OP_1ADD: 139,
        OP_1SUB: 140,
        OP_2MUL: 141,
        OP_2DIV: 142,
        OP_NEGATE: 143,
        OP_ABS: 144,
        OP_NOT: 145,
        OP_NOTEQUAL: 146,
        OP_ADD: 147,
        OP_SUB: 148,
        OP_MUL: 149,
        OP_DIV: 150,
        OP_MOD: 151,
        OP_LSHIFT: 152,
        OP_RSHIFT: 153,
        OP_BOOLAND: 154,
        OP_BOOLOR: 155,
        OP_NUMEQUAL: 156,
        OP_NUMEQUALVERIFY: 157,
        OP_NUMNOTEQUAL: 158,
        OP_LESSTHAN: 159,
        OP_GREATERTHAN: 160,
        OP_LESSTHANOREQUAL: 161,
        OP_GREATERTHANOREQUAL: 162,
        OP_MIN: 163,
        OP_MAX: 164,
        OP_WITHIN: 165,
        OP_RIPEMD160: 166,
        OP_SHA1: 167,
        OP_SHA256: 168,
        OP_HASH160: 169,
        OP_HASH256: 170,
        OP_CODESEPARATOR: 171,
        OP_CHECKSIG: 172,
        OP_CHECKSIGVERIFY: 173,
        OP_CHECKMULTISIG: 174,
        OP_CHECKMULTISIGVERIFY: 175,
        OP_NOP1: 176,
        OP_CHECKLOCKTIMEVERIFY: 177,
        OP_CHECKSEQUENCEVERIFY: 178,
        OP_NOP4: 179,
        OP_NOP5: 180,
        OP_NOP6: 181,
        OP_NOP7: 182,
        OP_NOP8: 183,
        OP_NOP9: 184,
        OP_NOP10: 185,
        OP_SMALLINTEGER: 250,
        OP_PUBKEYS: 251,
        OP_PUBKEYHASH: 253,
        OP_PUBKEY: 254,
        OP_INVALIDOPCODE: 255
    };
    let t = {};
    for (let A in e) t[e[A]] = A;
    A.exports = function(A) {
        A.OPCODE = e, A.RAW_OPCODE = t
    }
}, function(A, i) {
    "use strict";
    i.randomBytes = i.rng = i.pseudoRandomBytes = i.prng = require("randombytes"), i.createHash = i.Hash = require("create-hash"), i.createHmac = i.Hmac = require("create-hmac");
    var e = require("browserify-sign/algos"),
        t = Object.keys(e),
        I = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(t);
    i.getHashes = function() {
        return I
    };
    var g = require("pbkdf2");
    i.pbkdf2 = g.pbkdf2, i.pbkdf2Sync = g.pbkdf2Sync;
    var r = require("browserify-cipher");
    i.Cipher = r.Cipher, i.createCipher = r.createCipher, i.Cipheriv = r.Cipheriv, i.createCipheriv = r.createCipheriv, i.Decipher = r.Decipher, i.createDecipher = r.createDecipher, i.Decipheriv = r.Decipheriv, i.createDecipheriv = r.createDecipheriv, i.getCiphers = r.getCiphers, i.listCiphers = r.listCiphers;
    var o = require("diffie-hellman");
    i.DiffieHellmanGroup = o.DiffieHellmanGroup, i.createDiffieHellmanGroup = o.createDiffieHellmanGroup, i.getDiffieHellman = o.getDiffieHellman, i.createDiffieHellman = o.createDiffieHellman, i.DiffieHellman = o.DiffieHellman;
    var n = require("browserify-sign");
    i.createSign = n.createSign, i.Sign = n.Sign, i.createVerify = n.createVerify, i.Verify = n.Verify, i.createECDH = require("create-ecdh");
    var B = require("public-encrypt");
    i.publicEncrypt = B.publicEncrypt, i.privateEncrypt = B.privateEncrypt, i.publicDecrypt = B.publicDecrypt, i.privateDecrypt = B.privateDecrypt;
    var a = require("randomfill");
    i.randomFill = a.randomFill, i.randomFillSync = a.randomFillSync, i.createCredentials = function() {
        throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join("\n"))
    }, i.constants = {
        DH_CHECK_P_NOT_SAFE_PRIME: 2,
        DH_CHECK_P_NOT_PRIME: 1,
        DH_UNABLE_TO_CHECK_GENERATOR: 4,
        DH_NOT_SUITABLE_GENERATOR: 8,
        NPN_ENABLED: 1,
        ALPN_ENABLED: 1,
        RSA_PKCS1_PADDING: 1,
        RSA_SSLV23_PADDING: 2,
        RSA_NO_PADDING: 3,
        RSA_PKCS1_OAEP_PADDING: 4,
        RSA_X931_PADDING: 5,
        RSA_PKCS1_PSS_PADDING: 6,
        POINT_CONVERSION_COMPRESSED: 2,
        POINT_CONVERSION_UNCOMPRESSED: 4,
        POINT_CONVERSION_HYBRID: 6
    }
}, function(A, i) {}, function(A, i) {
    A.exports = function(A) {
        return A.webpackPolyfill || (A.deprecate = function() {}, A.paths = [], A.children || (A.children = []), Object.defineProperty(A, "loaded", {
            enumerable: !0,
            get: function() {
                return A.l
            }
        }), Object.defineProperty(A, "id", {
            enumerable: !0,
            get: function() {
                return A.i
            }
        }), A.webpackPolyfill = 1), A
    }
}, function(A, i, e) {
    (function(A) {
        ! function(A, i) {
            "use strict";

            function t(A, i) {
                if (!A) throw new Error(i || "Assertion failed")
            }

            function I(A, i) {
                A.super_ = i;
                var e = function() {};
                e.prototype = i.prototype, A.prototype = new e, A.prototype.constructor = A
            }

            function g(A, i, e) {
                if (g.isBN(A)) return A;
                this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== A && ("le" !== i && "be" !== i || (e = i, i = 10), this._init(A || 0, i || 10, e || "be"))
            }
            var r;
            "object" == typeof A ? A.exports = g : i.BN = g, g.BN = g, g.wordSize = 26;
            try {
                r = e(16).Buffer
            } catch (A) {}

            function o(A, i, e) {
                for (var I = 0, g = Math.min(A.length, e), r = 0, o = i; o < g; o++) {
                    var n, B = A.charCodeAt(o) - 48;
                    I <<= 4, I |= n = B >= 49 && B <= 54 ? B - 49 + 10 : B >= 17 && B <= 22 ? B - 17 + 10 : B, r |= n
                }
                return t(!(240 & r), "Invalid character in " + A), I
            }

            function n(A, i, e, I) {
                for (var g = 0, r = 0, o = Math.min(A.length, e), n = i; n < o; n++) {
                    var B = A.charCodeAt(n) - 48;
                    g *= I, r = B >= 49 ? B - 49 + 10 : B >= 17 ? B - 17 + 10 : B, t(B >= 0 && r < I, "Invalid character"), g += r
                }
                return g
            }

            function B(A, i) {
                A.words = i.words, A.length = i.length, A.negative = i.negative, A.red = i.red
            }

            function a() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            }
            g.isBN = function(A) {
                return A instanceof g || null !== A && "object" == typeof A && A.constructor.wordSize === g.wordSize && Array.isArray(A.words)
            }, g.max = function(A, i) {
                return A.cmp(i) > 0 ? A : i
            }, g.min = function(A, i) {
                return A.cmp(i) < 0 ? A : i
            }, g.prototype._init = function(A, i, e) {
                if ("number" == typeof A) return this._initNumber(A, i, e);
                if ("object" == typeof A) return this._initArray(A, i, e);
                "hex" === i && (i = 16), t(i === (0 | i) && i >= 2 && i <= 36);
                var I = 0;
                "-" === (A = A.toString().replace(/\s+/g, ""))[0] && I++, 16 === i ? this._parseHex(A, I) : this._parseBase(A, i, I), "-" === A[0] && (this.negative = 1), this._strip(), "le" === e && this._initArray(this.toArray(), i, e)
            }, g.prototype._initNumber = function(A, i, e) {
                A < 0 && (this.negative = 1, A = -A), A < 67108864 ? (this.words = [67108863 & A], this.length = 1) : A < 4503599627370496 ? (this.words = [67108863 & A, A / 67108864 & 67108863], this.length = 2) : (t(A < 9007199254740992), this.words = [67108863 & A, A / 67108864 & 67108863, 1], this.length = 3), "le" === e && this._initArray(this.toArray(), i, e)
            }, g.prototype._initArray = function(A, i, e) {
                if (t("number" == typeof A.length), A.length <= 0) return this.words = [0], this.length = 1, this;
                this.length = Math.ceil(A.length / 3), this.words = new Array(this.length);
                for (var I = 0; I < this.length; I++) this.words[I] = 0;
                var g, r, o = 0;
                if ("be" === e)
                    for (I = A.length - 1, g = 0; I >= 0; I -= 3) r = A[I] | A[I - 1] << 8 | A[I - 2] << 16, this.words[g] |= r << o & 67108863, this.words[g + 1] = r >>> 26 - o & 67108863, (o += 24) >= 26 && (o -= 26, g++);
                else if ("le" === e)
                    for (I = 0, g = 0; I < A.length; I += 3) r = A[I] | A[I + 1] << 8 | A[I + 2] << 16, this.words[g] |= r << o & 67108863, this.words[g + 1] = r >>> 26 - o & 67108863, (o += 24) >= 26 && (o -= 26, g++);
                return this._strip()
            }, g.prototype._parseHex = function(A, i) {
                this.length = Math.ceil((A.length - i) / 6), this.words = new Array(this.length);
                for (var e = 0; e < this.length; e++) this.words[e] = 0;
                var t, I, g = 0;
                for (e = A.length - 6, t = 0; e >= i; e -= 6) I = o(A, e, e + 6), this.words[t] |= I << g & 67108863, this.words[t + 1] |= I >>> 26 - g & 4194303, (g += 24) >= 26 && (g -= 26, t++);
                e + 6 !== i && (I = o(A, i, e + 6), this.words[t] |= I << g & 67108863, this.words[t + 1] |= I >>> 26 - g & 4194303), this._strip()
            }, g.prototype._parseBase = function(A, i, e) {
                this.words = [0], this.length = 1;
                for (var t = 0, I = 1; I <= 67108863; I *= i) t++;
                t--, I = I / i | 0;
                for (var g = A.length - e, r = g % t, o = Math.min(g, g - r) + e, B = 0, a = e; a < o; a += t) B = n(A, a, a + t, i), this.imuln(I), this.words[0] + B < 67108864 ? this.words[0] += B : this._iaddn(B);
                if (0 !== r) {
                    var s = 1;
                    for (B = n(A, a, A.length, i), a = 0; a < r; a++) s *= i;
                    this.imuln(s), this.words[0] + B < 67108864 ? this.words[0] += B : this._iaddn(B)
                }
            }, g.prototype.copy = function(A) {
                A.words = new Array(this.length);
                for (var i = 0; i < this.length; i++) A.words[i] = this.words[i];
                A.length = this.length, A.negative = this.negative, A.red = this.red
            }, g.prototype._move = function(A) {
                B(A, this)
            }, g.prototype.clone = function() {
                var A = new g(null);
                return this.copy(A), A
            }, g.prototype._expand = function(A) {
                for (; this.length < A;) this.words[this.length++] = 0;
                return this
            }, g.prototype._strip = function() {
                for (; this.length > 1 && 0 === this.words[this.length - 1];) this.length--;
                return this._normSign()
            }, g.prototype._normSign = function() {
                return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this
            }, "undefined" != typeof Symbol && "function" == typeof Symbol.for ? g.prototype[Symbol.for("nodejs.util.inspect.custom")] = a : g.prototype.inspect = a;
            var s = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
                E = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
                C = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
            g.prototype.toString = function(A, i) {
                var e;
                if (i = 0 | i || 1, 16 === (A = A || 10) || "hex" === A) {
                    e = "";
                    for (var I = 0, g = 0, r = 0; r < this.length; r++) {
                        var o = this.words[r],
                            n = (16777215 & (o << I | g)).toString(16);
                        e = 0 !== (g = o >>> 24 - I & 16777215) || r !== this.length - 1 ? s[6 - n.length] + n + e : n + e, (I += 2) >= 26 && (I -= 26, r--)
                    }
                    for (0 !== g && (e = g.toString(16) + e); e.length % i != 0;) e = "0" + e;
                    return 0 !== this.negative && (e = "-" + e), e
                }
                if (A === (0 | A) && A >= 2 && A <= 36) {
                    var B = E[A],
                        a = C[A];
                    e = "";
                    var Q = this.clone();
                    for (Q.negative = 0; !Q.isZero();) {
                        var h = Q.modrn(a).toString(A);
                        e = (Q = Q.idivn(a)).isZero() ? h + e : s[B - h.length] + h + e
                    }
                    for (this.isZero() && (e = "0" + e); e.length % i != 0;) e = "0" + e;
                    return 0 !== this.negative && (e = "-" + e), e
                }
                t(!1, "Base should be between 2 and 36")
            }, g.prototype.toNumber = function() {
                var A = this.words[0];
                return 2 === this.length ? A += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? A += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && t(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -A : A
            }, g.prototype.toJSON = function() {
                return this.toString(16, 2)
            }, r && (g.prototype.toBuffer = function(A, i) {
                return this.toArrayLike(r, A, i)
            }), g.prototype.toArray = function(A, i) {
                return this.toArrayLike(Array, A, i)
            };

            function Q(A, i, e) {
                e.negative = i.negative ^ A.negative;
                var t = A.length + i.length | 0;
                e.length = t, t = t - 1 | 0;
                var I = 0 | A.words[0],
                    g = 0 | i.words[0],
                    r = I * g,
                    o = 67108863 & r,
                    n = r / 67108864 | 0;
                e.words[0] = o;
                for (var B = 1; B < t; B++) {
                    for (var a = n >>> 26, s = 67108863 & n, E = Math.min(B, i.length - 1), C = Math.max(0, B - A.length + 1); C <= E; C++) {
                        var Q = B - C | 0;
                        a += (r = (I = 0 | A.words[Q]) * (g = 0 | i.words[C]) + s) / 67108864 | 0, s = 67108863 & r
                    }
                    e.words[B] = 0 | s, n = 0 | a
                }
                return 0 !== n ? e.words[B] = 0 | n : e.length--, e._strip()
            }
            g.prototype.toArrayLike = function(A, i, e) {
                this._strip();
                var I = this.byteLength(),
                    g = e || Math.max(1, I);
                t(I <= g, "byte array longer than desired length"), t(g > 0, "Requested array length <= 0");
                var r = function(A, i) {
                    return A.allocUnsafe ? A.allocUnsafe(i) : new A(i)
                }(A, g);
                return this["_toArrayLike" + ("le" === i ? "LE" : "BE")](r, I), r
            }, g.prototype._toArrayLikeLE = function(A, i) {
                for (var e = 0, t = 0, I = 0, g = 0; I < this.length; I++) {
                    var r = this.words[I] << g | t;
                    A[e++] = 255 & r, e < A.length && (A[e++] = r >> 8 & 255), e < A.length && (A[e++] = r >> 16 & 255), 6 === g ? (e < A.length && (A[e++] = r >> 24 & 255), t = 0, g = 0) : (t = r >>> 24, g += 2)
                }
                if (e < A.length)
                    for (A[e++] = t; e < A.length;) A[e++] = 0
            }, g.prototype._toArrayLikeBE = function(A, i) {
                for (var e = A.length - 1, t = 0, I = 0, g = 0; I < this.length; I++) {
                    var r = this.words[I] << g | t;
                    A[e--] = 255 & r, e >= 0 && (A[e--] = r >> 8 & 255), e >= 0 && (A[e--] = r >> 16 & 255), 6 === g ? (e >= 0 && (A[e--] = r >> 24 & 255), t = 0, g = 0) : (t = r >>> 24, g += 2)
                }
                if (e >= 0)
                    for (A[e--] = t; e >= 0;) A[e--] = 0
            }, Math.clz32 ? g.prototype._countBits = function(A) {
                return 32 - Math.clz32(A)
            } : g.prototype._countBits = function(A) {
                var i = A,
                    e = 0;
                return i >= 4096 && (e += 13, i >>>= 13), i >= 64 && (e += 7, i >>>= 7), i >= 8 && (e += 4, i >>>= 4), i >= 2 && (e += 2, i >>>= 2), e + i
            }, g.prototype._zeroBits = function(A) {
                if (0 === A) return 26;
                var i = A,
                    e = 0;
                return 0 == (8191 & i) && (e += 13, i >>>= 13), 0 == (127 & i) && (e += 7, i >>>= 7), 0 == (15 & i) && (e += 4, i >>>= 4), 0 == (3 & i) && (e += 2, i >>>= 2), 0 == (1 & i) && e++, e
            }, g.prototype.bitLength = function() {
                var A = this.words[this.length - 1],
                    i = this._countBits(A);
                return 26 * (this.length - 1) + i
            }, g.prototype.zeroBits = function() {
                if (this.isZero()) return 0;
                for (var A = 0, i = 0; i < this.length; i++) {
                    var e = this._zeroBits(this.words[i]);
                    if (A += e, 26 !== e) break
                }
                return A
            }, g.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8)
            }, g.prototype.toTwos = function(A) {
                return 0 !== this.negative ? this.abs().inotn(A).iaddn(1) : this.clone()
            }, g.prototype.fromTwos = function(A) {
                return this.testn(A - 1) ? this.notn(A).iaddn(1).ineg() : this.clone()
            }, g.prototype.isNeg = function() {
                return 0 !== this.negative
            }, g.prototype.neg = function() {
                return this.clone().ineg()
            }, g.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1), this
            }, g.prototype.iuor = function(A) {
                for (; this.length < A.length;) this.words[this.length++] = 0;
                for (var i = 0; i < A.length; i++) this.words[i] = this.words[i] | A.words[i];
                return this._strip()
            }, g.prototype.ior = function(A) {
                return t(0 == (this.negative | A.negative)), this.iuor(A)
            }, g.prototype.or = function(A) {
                return this.length > A.length ? this.clone().ior(A) : A.clone().ior(this)
            }, g.prototype.uor = function(A) {
                return this.length > A.length ? this.clone().iuor(A) : A.clone().iuor(this)
            }, g.prototype.iuand = function(A) {
                var i;
                i = this.length > A.length ? A : this;
                for (var e = 0; e < i.length; e++) this.words[e] = this.words[e] & A.words[e];
                return this.length = i.length, this._strip()
            }, g.prototype.iand = function(A) {
                return t(0 == (this.negative | A.negative)), this.iuand(A)
            }, g.prototype.and = function(A) {
                return this.length > A.length ? this.clone().iand(A) : A.clone().iand(this)
            }, g.prototype.uand = function(A) {
                return this.length > A.length ? this.clone().iuand(A) : A.clone().iuand(this)
            }, g.prototype.iuxor = function(A) {
                var i, e;
                this.length > A.length ? (i = this, e = A) : (i = A, e = this);
                for (var t = 0; t < e.length; t++) this.words[t] = i.words[t] ^ e.words[t];
                if (this !== i)
                    for (; t < i.length; t++) this.words[t] = i.words[t];
                return this.length = i.length, this._strip()
            }, g.prototype.ixor = function(A) {
                return t(0 == (this.negative | A.negative)), this.iuxor(A)
            }, g.prototype.xor = function(A) {
                return this.length > A.length ? this.clone().ixor(A) : A.clone().ixor(this)
            }, g.prototype.uxor = function(A) {
                return this.length > A.length ? this.clone().iuxor(A) : A.clone().iuxor(this)
            }, g.prototype.inotn = function(A) {
                t("number" == typeof A && A >= 0);
                var i = 0 | Math.ceil(A / 26),
                    e = A % 26;
                this._expand(i), e > 0 && i--;
                for (var I = 0; I < i; I++) this.words[I] = 67108863 & ~this.words[I];
                return e > 0 && (this.words[I] = ~this.words[I] & 67108863 >> 26 - e), this._strip()
            }, g.prototype.notn = function(A) {
                return this.clone().inotn(A)
            }, g.prototype.setn = function(A, i) {
                t("number" == typeof A && A >= 0);
                var e = A / 26 | 0,
                    I = A % 26;
                return this._expand(e + 1), this.words[e] = i ? this.words[e] | 1 << I : this.words[e] & ~(1 << I), this._strip()
            }, g.prototype.iadd = function(A) {
                var i, e, t;
                if (0 !== this.negative && 0 === A.negative) return this.negative = 0, i = this.isub(A), this.negative ^= 1, this._normSign();
                if (0 === this.negative && 0 !== A.negative) return A.negative = 0, i = this.isub(A), A.negative = 1, i._normSign();
                this.length > A.length ? (e = this, t = A) : (e = A, t = this);
                for (var I = 0, g = 0; g < t.length; g++) i = (0 | e.words[g]) + (0 | t.words[g]) + I, this.words[g] = 67108863 & i, I = i >>> 26;
                for (; 0 !== I && g < e.length; g++) i = (0 | e.words[g]) + I, this.words[g] = 67108863 & i, I = i >>> 26;
                if (this.length = e.length, 0 !== I) this.words[this.length] = I, this.length++;
                else if (e !== this)
                    for (; g < e.length; g++) this.words[g] = e.words[g];
                return this
            }, g.prototype.add = function(A) {
                var i;
                return 0 !== A.negative && 0 === this.negative ? (A.negative = 0, i = this.sub(A), A.negative ^= 1, i) : 0 === A.negative && 0 !== this.negative ? (this.negative = 0, i = A.sub(this), this.negative = 1, i) : this.length > A.length ? this.clone().iadd(A) : A.clone().iadd(this)
            }, g.prototype.isub = function(A) {
                if (0 !== A.negative) {
                    A.negative = 0;
                    var i = this.iadd(A);
                    return A.negative = 1, i._normSign()
                }
                if (0 !== this.negative) return this.negative = 0, this.iadd(A), this.negative = 1, this._normSign();
                var e, t, I = this.cmp(A);
                if (0 === I) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                I > 0 ? (e = this, t = A) : (e = A, t = this);
                for (var g = 0, r = 0; r < t.length; r++) g = (i = (0 | e.words[r]) - (0 | t.words[r]) + g) >> 26, this.words[r] = 67108863 & i;
                for (; 0 !== g && r < e.length; r++) g = (i = (0 | e.words[r]) + g) >> 26, this.words[r] = 67108863 & i;
                if (0 === g && r < e.length && e !== this)
                    for (; r < e.length; r++) this.words[r] = e.words[r];
                return this.length = Math.max(this.length, r), e !== this && (this.negative = 1), this._strip()
            }, g.prototype.sub = function(A) {
                return this.clone().isub(A)
            };
            var h = function(A, i, e) {
                var t, I, g, r = A.words,
                    o = i.words,
                    n = e.words,
                    B = 0,
                    a = 0 | r[0],
                    s = 8191 & a,
                    E = a >>> 13,
                    C = 0 | r[1],
                    Q = 8191 & C,
                    h = C >>> 13,
                    c = 0 | r[2],
                    l = 8191 & c,
                    u = c >>> 13,
                    d = 0 | r[3],
                    p = 8191 & d,
                    f = d >>> 13,
                    y = 0 | r[4],
                    D = 8191 & y,
                    w = y >>> 13,
                    k = 0 | r[5],
                    m = 8191 & k,
                    S = k >>> 13,
                    M = 0 | r[6],
                    F = 8191 & M,
                    N = M >>> 13,
                    G = 0 | r[7],
                    R = 8191 & G,
                    K = G >>> 13,
                    v = 0 | r[8],
                    H = 8191 & v,
                    q = v >>> 13,
                    P = 0 | r[9],
                    T = 8191 & P,
                    J = P >>> 13,
                    U = 0 | o[0],
                    Y = 8191 & U,
                    b = U >>> 13,
                    x = 0 | o[1],
                    X = 8191 & x,
                    L = x >>> 13,
                    W = 0 | o[2],
                    O = 8191 & W,
                    V = W >>> 13,
                    _ = 0 | o[3],
                    Z = 8191 & _,
                    z = _ >>> 13,
                    j = 0 | o[4],
                    $ = 8191 & j,
                    AA = j >>> 13,
                    iA = 0 | o[5],
                    eA = 8191 & iA,
                    tA = iA >>> 13,
                    IA = 0 | o[6],
                    gA = 8191 & IA,
                    rA = IA >>> 13,
                    oA = 0 | o[7],
                    nA = 8191 & oA,
                    BA = oA >>> 13,
                    aA = 0 | o[8],
                    sA = 8191 & aA,
                    EA = aA >>> 13,
                    CA = 0 | o[9],
                    QA = 8191 & CA,
                    hA = CA >>> 13;
                e.negative = A.negative ^ i.negative, e.length = 19;
                var cA = (B + (t = Math.imul(s, Y)) | 0) + ((8191 & (I = (I = Math.imul(s, b)) + Math.imul(E, Y) | 0)) << 13) | 0;
                B = ((g = Math.imul(E, b)) + (I >>> 13) | 0) + (cA >>> 26) | 0, cA &= 67108863, t = Math.imul(Q, Y), I = (I = Math.imul(Q, b)) + Math.imul(h, Y) | 0, g = Math.imul(h, b);
                var lA = (B + (t = t + Math.imul(s, X) | 0) | 0) + ((8191 & (I = (I = I + Math.imul(s, L) | 0) + Math.imul(E, X) | 0)) << 13) | 0;
                B = ((g = g + Math.imul(E, L) | 0) + (I >>> 13) | 0) + (lA >>> 26) | 0, lA &= 67108863, t = Math.imul(l, Y), I = (I = Math.imul(l, b)) + Math.imul(u, Y) | 0, g = Math.imul(u, b), t = t + Math.imul(Q, X) | 0, I = (I = I + Math.imul(Q, L) | 0) + Math.imul(h, X) | 0, g = g + Math.imul(h, L) | 0;
                var uA = (B + (t = t + Math.imul(s, O) | 0) | 0) + ((8191 & (I = (I = I + Math.imul(s, V) | 0) + Math.imul(E, O) | 0)) << 13) | 0;
                B = ((g = g + Math.imul(E, V) | 0) + (I >>> 13) | 0) + (uA >>> 26) | 0, uA &= 67108863, t = Math.imul(p, Y), I = (I = Math.imul(p, b)) + Math.imul(f, Y) | 0, g = Math.imul(f, b), t = t + Math.imul(l, X) | 0, I = (I = I + Math.imul(l, L) | 0) + Math.imul(u, X) | 0, g = g + Math.imul(u, L) | 0, t = t + Math.imul(Q, O) | 0, I = (I = I + Math.imul(Q, V) | 0) + Math.imul(h, O) | 0, g = g + Math.imul(h, V) | 0;
                var dA = (B + (t = t + Math.imul(s, Z) | 0) | 0) + ((8191 & (I = (I = I + Math.imul(s, z) | 0) + Math.imul(E, Z) | 0)) << 13) | 0;
                B = ((g = g + Math.imul(E, z) | 0) + (I >>> 13) | 0) + (dA >>> 26) | 0, dA &= 67108863, t = Math.imul(D, Y), I = (I = Math.imul(D, b)) + Math.imul(w, Y) | 0, g = Math.imul(w, b), t = t + Math.imul(p, X) | 0, I = (I = I + Math.imul(p, L) | 0) + Math.imul(f, X) | 0, g = g + Math.imul(f, L) | 0, t = t + Math.imul(l, O) | 0, I = (I = I + Math.imul(l, V) | 0) + Math.imul(u, O) | 0, g = g + Math.imul(u, V) | 0, t = t + Math.imul(Q, Z) | 0, I = (I = I + Math.imul(Q, z) | 0) + Math.imul(h, Z) | 0, g = g + Math.imul(h, z) | 0;
                var pA = (B + (t = t + Math.imul(s, $) | 0) | 0) + ((8191 & (I = (I = I + Math.imul(s, AA) | 0) + Math.imul(E, $) | 0)) << 13) | 0;
                B = ((g = g + Math.imul(E, AA) | 0) + (I >>> 13) | 0) + (pA >>> 26) | 0, pA &= 67108863, t = Math.imul(m, Y), I = (I = Math.imul(m, b)) + Math.imul(S, Y) | 0, g = Math.imul(S, b), t = t + Math.imul(D, X) | 0, I = (I = I + Math.imul(D, L) | 0) + Math.imul(w, X) | 0, g = g + Math.imul(w, L) | 0, t = t + Math.imul(p, O) | 0, I = (I = I + Math.imul(p, V) | 0) + Math.imul(f, O) | 0, g = g + Math.imul(f, V) | 0, t = t + Math.imul(l, Z) | 0, I = (I = I + Math.imul(l, z) | 0) + Math.imul(u, Z) | 0, g = g + Math.imul(u, z) | 0, t = t + Math.imul(Q, $) | 0, I = (I = I + Math.imul(Q, AA) | 0) + Math.imul(h, $) | 0, g = g + Math.imul(h, AA) | 0;
                var fA = (B + (t = t + Math.imul(s, eA) | 0) | 0) + ((8191 & (I = (I = I + Math.imul(s, tA) | 0) + Math.imul(E, eA) | 0)) << 13) | 0;
                B = ((g = g + Math.imul(E, tA) | 0) + (I >>> 13) | 0) + (fA >>> 26) | 0, fA &= 67108863, t = Math.imul(F, Y), I = (I = Math.imul(F, b)) + Math.imul(N, Y) | 0, g = Math.imul(N, b), t = t + Math.imul(m, X) | 0, I = (I = I + Math.imul(m, L) | 0) + Math.imul(S, X) | 0, g = g + Math.imul(S, L) | 0, t = t + Math.imul(D, O) | 0, I = (I = I + Math.imul(D, V) | 0) + Math.imul(w, O) | 0, g = g + Math.imul(w, V) | 0, t = t + Math.imul(p, Z) | 0, I = (I = I + Math.imul(p, z) | 0) + Math.imul(f, Z) | 0, g = g + Math.imul(f, z) | 0, t = t + Math.imul(l, $) | 0, I = (I = I + Math.imul(l, AA) | 0) + Math.imul(u, $) | 0, g = g + Math.imul(u, AA) | 0, t = t + Math.imul(Q, eA) | 0, I = (I = I + Math.imul(Q, tA) | 0) + Math.imul(h, eA) | 0, g = g + Math.imul(h, tA) | 0;
                var yA = (B + (t = t + Math.imul(s, gA) | 0) | 0) + ((8191 & (I = (I = I + Math.imul(s, rA) | 0) + Math.imul(E, gA) | 0)) << 13) | 0;
                B = ((g = g + Math.imul(E, rA) | 0) + (I >>> 13) | 0) + (yA >>> 26) | 0, yA &= 67108863, t = Math.imul(R, Y), I = (I = Math.imul(R, b)) + Math.imul(K, Y) | 0, g = Math.imul(K, b), t = t + Math.imul(F, X) | 0, I = (I = I + Math.imul(F, L) | 0) + Math.imul(N, X) | 0, g = g + Math.imul(N, L) | 0, t = t + Math.imul(m, O) | 0, I = (I = I + Math.imul(m, V) | 0) + Math.imul(S, O) | 0, g = g + Math.imul(S, V) | 0, t = t + Math.imul(D, Z) | 0, I = (I = I + Math.imul(D, z) | 0) + Math.imul(w, Z) | 0, g = g + Math.imul(w, z) | 0, t = t + Math.imul(p, $) | 0, I = (I = I + Math.imul(p, AA) | 0) + Math.imul(f, $) | 0, g = g + Math.imul(f, AA) | 0, t = t + Math.imul(l, eA) | 0, I = (I = I + Math.imul(l, tA) | 0) + Math.imul(u, eA) | 0, g = g + Math.imul(u, tA) | 0, t = t + Math.imul(Q, gA) | 0, I = (I = I + Math.imul(Q, rA) | 0) + Math.imul(h, gA) | 0, g = g + Math.imul(h, rA) | 0;
                var DA = (B + (t = t + Math.imul(s, nA) | 0) | 0) + ((8191 & (I = (I = I + Math.imul(s, BA) | 0) + Math.imul(E, nA) | 0)) << 13) | 0;
                B = ((g = g + Math.imul(E, BA) | 0) + (I >>> 13) | 0) + (DA >>> 26) | 0, DA &= 67108863, t = Math.imul(H, Y), I = (I = Math.imul(H, b)) + Math.imul(q, Y) | 0, g = Math.imul(q, b), t = t + Math.imul(R, X) | 0, I = (I = I + Math.imul(R, L) | 0) + Math.imul(K, X) | 0, g = g + Math.imul(K, L) | 0, t = t + Math.imul(F, O) | 0, I = (I = I + Math.imul(F, V) | 0) + Math.imul(N, O) | 0, g = g + Math.imul(N, V) | 0, t = t + Math.imul(m, Z) | 0, I = (I = I + Math.imul(m, z) | 0) + Math.imul(S, Z) | 0, g = g + Math.imul(S, z) | 0, t = t + Math.imul(D, $) | 0, I = (I = I + Math.imul(D, AA) | 0) + Math.imul(w, $) | 0, g = g + Math.imul(w, AA) | 0, t = t + Math.imul(p, eA) | 0, I = (I = I + Math.imul(p, tA) | 0) + Math.imul(f, eA) | 0, g = g + Math.imul(f, tA) | 0, t = t + Math.imul(l, gA) | 0, I = (I = I + Math.imul(l, rA) | 0) + Math.imul(u, gA) | 0, g = g + Math.imul(u, rA) | 0, t = t + Math.imul(Q, nA) | 0, I = (I = I + Math.imul(Q, BA) | 0) + Math.imul(h, nA) | 0, g = g + Math.imul(h, BA) | 0;
                var wA = (B + (t = t + Math.imul(s, sA) | 0) | 0) + ((8191 & (I = (I = I + Math.imul(s, EA) | 0) + Math.imul(E, sA) | 0)) << 13) | 0;
                B = ((g = g + Math.imul(E, EA) | 0) + (I >>> 13) | 0) + (wA >>> 26) | 0, wA &= 67108863, t = Math.imul(T, Y), I = (I = Math.imul(T, b)) + Math.imul(J, Y) | 0, g = Math.imul(J, b), t = t + Math.imul(H, X) | 0, I = (I = I + Math.imul(H, L) | 0) + Math.imul(q, X) | 0, g = g + Math.imul(q, L) | 0, t = t + Math.imul(R, O) | 0, I = (I = I + Math.imul(R, V) | 0) + Math.imul(K, O) | 0, g = g + Math.imul(K, V) | 0, t = t + Math.imul(F, Z) | 0, I = (I = I + Math.imul(F, z) | 0) + Math.imul(N, Z) | 0, g = g + Math.imul(N, z) | 0, t = t + Math.imul(m, $) | 0, I = (I = I + Math.imul(m, AA) | 0) + Math.imul(S, $) | 0, g = g + Math.imul(S, AA) | 0, t = t + Math.imul(D, eA) | 0, I = (I = I + Math.imul(D, tA) | 0) + Math.imul(w, eA) | 0, g = g + Math.imul(w, tA) | 0, t = t + Math.imul(p, gA) | 0, I = (I = I + Math.imul(p, rA) | 0) + Math.imul(f, gA) | 0, g = g + Math.imul(f, rA) | 0, t = t + Math.imul(l, nA) | 0, I = (I = I + Math.imul(l, BA) | 0) + Math.imul(u, nA) | 0, g = g + Math.imul(u, BA) | 0, t = t + Math.imul(Q, sA) | 0, I = (I = I + Math.imul(Q, EA) | 0) + Math.imul(h, sA) | 0, g = g + Math.imul(h, EA) | 0;
                var kA = (B + (t = t + Math.imul(s, QA) | 0) | 0) + ((8191 & (I = (I = I + Math.imul(s, hA) | 0) + Math.imul(E, QA) | 0)) << 13) | 0;
                B = ((g = g + Math.imul(E, hA) | 0) + (I >>> 13) | 0) + (kA >>> 26) | 0, kA &= 67108863, t = Math.imul(T, X), I = (I = Math.imul(T, L)) + Math.imul(J, X) | 0, g = Math.imul(J, L), t = t + Math.imul(H, O) | 0, I = (I = I + Math.imul(H, V) | 0) + Math.imul(q, O) | 0, g = g + Math.imul(q, V) | 0, t = t + Math.imul(R, Z) | 0, I = (I = I + Math.imul(R, z) | 0) + Math.imul(K, Z) | 0, g = g + Math.imul(K, z) | 0, t = t + Math.imul(F, $) | 0, I = (I = I + Math.imul(F, AA) | 0) + Math.imul(N, $) | 0, g = g + Math.imul(N, AA) | 0, t = t + Math.imul(m, eA) | 0, I = (I = I + Math.imul(m, tA) | 0) + Math.imul(S, eA) | 0, g = g + Math.imul(S, tA) | 0, t = t + Math.imul(D, gA) | 0, I = (I = I + Math.imul(D, rA) | 0) + Math.imul(w, gA) | 0, g = g + Math.imul(w, rA) | 0, t = t + Math.imul(p, nA) | 0, I = (I = I + Math.imul(p, BA) | 0) + Math.imul(f, nA) | 0, g = g + Math.imul(f, BA) | 0, t = t + Math.imul(l, sA) | 0, I = (I = I + Math.imul(l, EA) | 0) + Math.imul(u, sA) | 0, g = g + Math.imul(u, EA) | 0;
                var mA = (B + (t = t + Math.imul(Q, QA) | 0) | 0) + ((8191 & (I = (I = I + Math.imul(Q, hA) | 0) + Math.imul(h, QA) | 0)) << 13) | 0;
                B = ((g = g + Math.imul(h, hA) | 0) + (I >>> 13) | 0) + (mA >>> 26) | 0, mA &= 67108863, t = Math.imul(T, O), I = (I = Math.imul(T, V)) + Math.imul(J, O) | 0, g = Math.imul(J, V), t = t + Math.imul(H, Z) | 0, I = (I = I + Math.imul(H, z) | 0) + Math.imul(q, Z) | 0, g = g + Math.imul(q, z) | 0, t = t + Math.imul(R, $) | 0, I = (I = I + Math.imul(R, AA) | 0) + Math.imul(K, $) | 0, g = g + Math.imul(K, AA) | 0, t = t + Math.imul(F, eA) | 0, I = (I = I + Math.imul(F, tA) | 0) + Math.imul(N, eA) | 0, g = g + Math.imul(N, tA) | 0, t = t + Math.imul(m, gA) | 0, I = (I = I + Math.imul(m, rA) | 0) + Math.imul(S, gA) | 0, g = g + Math.imul(S, rA) | 0, t = t + Math.imul(D, nA) | 0, I = (I = I + Math.imul(D, BA) | 0) + Math.imul(w, nA) | 0, g = g + Math.imul(w, BA) | 0, t = t + Math.imul(p, sA) | 0, I = (I = I + Math.imul(p, EA) | 0) + Math.imul(f, sA) | 0, g = g + Math.imul(f, EA) | 0;
                var SA = (B + (t = t + Math.imul(l, QA) | 0) | 0) + ((8191 & (I = (I = I + Math.imul(l, hA) | 0) + Math.imul(u, QA) | 0)) << 13) | 0;
                B = ((g = g + Math.imul(u, hA) | 0) + (I >>> 13) | 0) + (SA >>> 26) | 0, SA &= 67108863, t = Math.imul(T, Z), I = (I = Math.imul(T, z)) + Math.imul(J, Z) | 0, g = Math.imul(J, z), t = t + Math.imul(H, $) | 0, I = (I = I + Math.imul(H, AA) | 0) + Math.imul(q, $) | 0, g = g + Math.imul(q, AA) | 0, t = t + Math.imul(R, eA) | 0, I = (I = I + Math.imul(R, tA) | 0) + Math.imul(K, eA) | 0, g = g + Math.imul(K, tA) | 0, t = t + Math.imul(F, gA) | 0, I = (I = I + Math.imul(F, rA) | 0) + Math.imul(N, gA) | 0, g = g + Math.imul(N, rA) | 0, t = t + Math.imul(m, nA) | 0, I = (I = I + Math.imul(m, BA) | 0) + Math.imul(S, nA) | 0, g = g + Math.imul(S, BA) | 0, t = t + Math.imul(D, sA) | 0, I = (I = I + Math.imul(D, EA) | 0) + Math.imul(w, sA) | 0, g = g + Math.imul(w, EA) | 0;
                var MA = (B + (t = t + Math.imul(p, QA) | 0) | 0) + ((8191 & (I = (I = I + Math.imul(p, hA) | 0) + Math.imul(f, QA) | 0)) << 13) | 0;
                B = ((g = g + Math.imul(f, hA) | 0) + (I >>> 13) | 0) + (MA >>> 26) | 0, MA &= 67108863, t = Math.imul(T, $), I = (I = Math.imul(T, AA)) + Math.imul(J, $) | 0, g = Math.imul(J, AA), t = t + Math.imul(H, eA) | 0, I = (I = I + Math.imul(H, tA) | 0) + Math.imul(q, eA) | 0, g = g + Math.imul(q, tA) | 0, t = t + Math.imul(R, gA) | 0, I = (I = I + Math.imul(R, rA) | 0) + Math.imul(K, gA) | 0, g = g + Math.imul(K, rA) | 0, t = t + Math.imul(F, nA) | 0, I = (I = I + Math.imul(F, BA) | 0) + Math.imul(N, nA) | 0, g = g + Math.imul(N, BA) | 0, t = t + Math.imul(m, sA) | 0, I = (I = I + Math.imul(m, EA) | 0) + Math.imul(S, sA) | 0, g = g + Math.imul(S, EA) | 0;
                var FA = (B + (t = t + Math.imul(D, QA) | 0) | 0) + ((8191 & (I = (I = I + Math.imul(D, hA) | 0) + Math.imul(w, QA) | 0)) << 13) | 0;
                B = ((g = g + Math.imul(w, hA) | 0) + (I >>> 13) | 0) + (FA >>> 26) | 0, FA &= 67108863, t = Math.imul(T, eA), I = (I = Math.imul(T, tA)) + Math.imul(J, eA) | 0, g = Math.imul(J, tA), t = t + Math.imul(H, gA) | 0, I = (I = I + Math.imul(H, rA) | 0) + Math.imul(q, gA) | 0, g = g + Math.imul(q, rA) | 0, t = t + Math.imul(R, nA) | 0, I = (I = I + Math.imul(R, BA) | 0) + Math.imul(K, nA) | 0, g = g + Math.imul(K, BA) | 0, t = t + Math.imul(F, sA) | 0, I = (I = I + Math.imul(F, EA) | 0) + Math.imul(N, sA) | 0, g = g + Math.imul(N, EA) | 0;
                var NA = (B + (t = t + Math.imul(m, QA) | 0) | 0) + ((8191 & (I = (I = I + Math.imul(m, hA) | 0) + Math.imul(S, QA) | 0)) << 13) | 0;
                B = ((g = g + Math.imul(S, hA) | 0) + (I >>> 13) | 0) + (NA >>> 26) | 0, NA &= 67108863, t = Math.imul(T, gA), I = (I = Math.imul(T, rA)) + Math.imul(J, gA) | 0, g = Math.imul(J, rA), t = t + Math.imul(H, nA) | 0, I = (I = I + Math.imul(H, BA) | 0) + Math.imul(q, nA) | 0, g = g + Math.imul(q, BA) | 0, t = t + Math.imul(R, sA) | 0, I = (I = I + Math.imul(R, EA) | 0) + Math.imul(K, sA) | 0, g = g + Math.imul(K, EA) | 0;
                var GA = (B + (t = t + Math.imul(F, QA) | 0) | 0) + ((8191 & (I = (I = I + Math.imul(F, hA) | 0) + Math.imul(N, QA) | 0)) << 13) | 0;
                B = ((g = g + Math.imul(N, hA) | 0) + (I >>> 13) | 0) + (GA >>> 26) | 0, GA &= 67108863, t = Math.imul(T, nA), I = (I = Math.imul(T, BA)) + Math.imul(J, nA) | 0, g = Math.imul(J, BA), t = t + Math.imul(H, sA) | 0, I = (I = I + Math.imul(H, EA) | 0) + Math.imul(q, sA) | 0, g = g + Math.imul(q, EA) | 0;
                var RA = (B + (t = t + Math.imul(R, QA) | 0) | 0) + ((8191 & (I = (I = I + Math.imul(R, hA) | 0) + Math.imul(K, QA) | 0)) << 13) | 0;
                B = ((g = g + Math.imul(K, hA) | 0) + (I >>> 13) | 0) + (RA >>> 26) | 0, RA &= 67108863, t = Math.imul(T, sA), I = (I = Math.imul(T, EA)) + Math.imul(J, sA) | 0, g = Math.imul(J, EA);
                var KA = (B + (t = t + Math.imul(H, QA) | 0) | 0) + ((8191 & (I = (I = I + Math.imul(H, hA) | 0) + Math.imul(q, QA) | 0)) << 13) | 0;
                B = ((g = g + Math.imul(q, hA) | 0) + (I >>> 13) | 0) + (KA >>> 26) | 0, KA &= 67108863;
                var vA = (B + (t = Math.imul(T, QA)) | 0) + ((8191 & (I = (I = Math.imul(T, hA)) + Math.imul(J, QA) | 0)) << 13) | 0;
                return B = ((g = Math.imul(J, hA)) + (I >>> 13) | 0) + (vA >>> 26) | 0, vA &= 67108863, n[0] = cA, n[1] = lA, n[2] = uA, n[3] = dA, n[4] = pA, n[5] = fA, n[6] = yA, n[7] = DA, n[8] = wA, n[9] = kA, n[10] = mA, n[11] = SA, n[12] = MA, n[13] = FA, n[14] = NA, n[15] = GA, n[16] = RA, n[17] = KA, n[18] = vA, 0 !== B && (n[19] = B, e.length++), e
            };

            function c(A, i, e) {
                e.negative = i.negative ^ A.negative, e.length = A.length + i.length;
                for (var t = 0, I = 0, g = 0; g < e.length - 1; g++) {
                    var r = I;
                    I = 0;
                    for (var o = 67108863 & t, n = Math.min(g, i.length - 1), B = Math.max(0, g - A.length + 1); B <= n; B++) {
                        var a = g - B,
                            s = (0 | A.words[a]) * (0 | i.words[B]),
                            E = 67108863 & s;
                        o = 67108863 & (E = E + o | 0), I += (r = (r = r + (s / 67108864 | 0) | 0) + (E >>> 26) | 0) >>> 26, r &= 67108863
                    }
                    e.words[g] = o, t = r, r = I
                }
                return 0 !== t ? e.words[g] = t : e.length--, e._strip()
            }

            function l(A, i, e) {
                return c(A, i, e)
            }

            function u(A, i) {
                this.x = A, this.y = i
            }
            Math.imul || (h = Q), g.prototype.mulTo = function(A, i) {
                var e = this.length + A.length;
                return 10 === this.length && 10 === A.length ? h(this, A, i) : e < 63 ? Q(this, A, i) : e < 1024 ? c(this, A, i) : l(this, A, i)
            }, u.prototype.makeRBT = function(A) {
                for (var i = new Array(A), e = g.prototype._countBits(A) - 1, t = 0; t < A; t++) i[t] = this.revBin(t, e, A);
                return i
            }, u.prototype.revBin = function(A, i, e) {
                if (0 === A || A === e - 1) return A;
                for (var t = 0, I = 0; I < i; I++) t |= (1 & A) << i - I - 1, A >>= 1;
                return t
            }, u.prototype.permute = function(A, i, e, t, I, g) {
                for (var r = 0; r < g; r++) t[r] = i[A[r]], I[r] = e[A[r]]
            }, u.prototype.transform = function(A, i, e, t, I, g) {
                this.permute(g, A, i, e, t, I);
                for (var r = 1; r < I; r <<= 1)
                    for (var o = r << 1, n = Math.cos(2 * Math.PI / o), B = Math.sin(2 * Math.PI / o), a = 0; a < I; a += o)
                        for (var s = n, E = B, C = 0; C < r; C++) {
                            var Q = e[a + C],
                                h = t[a + C],
                                c = e[a + C + r],
                                l = t[a + C + r],
                                u = s * c - E * l;
                            l = s * l + E * c, c = u, e[a + C] = Q + c, t[a + C] = h + l, e[a + C + r] = Q - c, t[a + C + r] = h - l, C !== o && (u = n * s - B * E, E = n * E + B * s, s = u)
                        }
            }, u.prototype.guessLen13b = function(A, i) {
                var e = 1 | Math.max(i, A),
                    t = 1 & e,
                    I = 0;
                for (e = e / 2 | 0; e; e >>>= 1) I++;
                return 1 << I + 1 + t
            }, u.prototype.conjugate = function(A, i, e) {
                if (!(e <= 1))
                    for (var t = 0; t < e / 2; t++) {
                        var I = A[t];
                        A[t] = A[e - t - 1], A[e - t - 1] = I, I = i[t], i[t] = -i[e - t - 1], i[e - t - 1] = -I
                    }
            }, u.prototype.normalize13b = function(A, i) {
                for (var e = 0, t = 0; t < i / 2; t++) {
                    var I = 8192 * Math.round(A[2 * t + 1] / i) + Math.round(A[2 * t] / i) + e;
                    A[t] = 67108863 & I, e = I < 67108864 ? 0 : I / 67108864 | 0
                }
                return A
            }, u.prototype.convert13b = function(A, i, e, I) {
                for (var g = 0, r = 0; r < i; r++) g += 0 | A[r], e[2 * r] = 8191 & g, g >>>= 13, e[2 * r + 1] = 8191 & g, g >>>= 13;
                for (r = 2 * i; r < I; ++r) e[r] = 0;
                t(0 === g), t(0 == (-8192 & g))
            }, u.prototype.stub = function(A) {
                for (var i = new Array(A), e = 0; e < A; e++) i[e] = 0;
                return i
            }, u.prototype.mulp = function(A, i, e) {
                var t = 2 * this.guessLen13b(A.length, i.length),
                    I = this.makeRBT(t),
                    g = this.stub(t),
                    r = new Array(t),
                    o = new Array(t),
                    n = new Array(t),
                    B = new Array(t),
                    a = new Array(t),
                    s = new Array(t),
                    E = e.words;
                E.length = t, this.convert13b(A.words, A.length, r, t), this.convert13b(i.words, i.length, B, t), this.transform(r, g, o, n, t, I), this.transform(B, g, a, s, t, I);
                for (var C = 0; C < t; C++) {
                    var Q = o[C] * a[C] - n[C] * s[C];
                    n[C] = o[C] * s[C] + n[C] * a[C], o[C] = Q
                }
                return this.conjugate(o, n, t), this.transform(o, n, E, g, t, I), this.conjugate(E, g, t), this.normalize13b(E, t), e.negative = A.negative ^ i.negative, e.length = A.length + i.length, e._strip()
            }, g.prototype.mul = function(A) {
                var i = new g(null);
                return i.words = new Array(this.length + A.length), this.mulTo(A, i)
            }, g.prototype.mulf = function(A) {
                var i = new g(null);
                return i.words = new Array(this.length + A.length), l(this, A, i)
            }, g.prototype.imul = function(A) {
                return this.clone().mulTo(A, this)
            }, g.prototype.imuln = function(A) {
                var i = A < 0;
                i && (A = -A), t("number" == typeof A), t(A < 67108864);
                for (var e = 0, I = 0; I < this.length; I++) {
                    var g = (0 | this.words[I]) * A,
                        r = (67108863 & g) + (67108863 & e);
                    e >>= 26, e += g / 67108864 | 0, e += r >>> 26, this.words[I] = 67108863 & r
                }
                return 0 !== e && (this.words[I] = e, this.length++), i ? this.ineg() : this
            }, g.prototype.muln = function(A) {
                return this.clone().imuln(A)
            }, g.prototype.sqr = function() {
                return this.mul(this)
            }, g.prototype.isqr = function() {
                return this.imul(this.clone())
            }, g.prototype.pow = function(A) {
                var i = function(A) {
                    for (var i = new Array(A.bitLength()), e = 0; e < i.length; e++) {
                        var t = e / 26 | 0,
                            I = e % 26;
                        i[e] = A.words[t] >>> I & 1
                    }
                    return i
                }(A);
                if (0 === i.length) return new g(1);
                for (var e = this, t = 0; t < i.length && 0 === i[t]; t++, e = e.sqr());
                if (++t < i.length)
                    for (var I = e.sqr(); t < i.length; t++, I = I.sqr()) 0 !== i[t] && (e = e.mul(I));
                return e
            }, g.prototype.iushln = function(A) {
                t("number" == typeof A && A >= 0);
                var i, e = A % 26,
                    I = (A - e) / 26,
                    g = 67108863 >>> 26 - e << 26 - e;
                if (0 !== e) {
                    var r = 0;
                    for (i = 0; i < this.length; i++) {
                        var o = this.words[i] & g,
                            n = (0 | this.words[i]) - o << e;
                        this.words[i] = n | r, r = o >>> 26 - e
                    }
                    r && (this.words[i] = r, this.length++)
                }
                if (0 !== I) {
                    for (i = this.length - 1; i >= 0; i--) this.words[i + I] = this.words[i];
                    for (i = 0; i < I; i++) this.words[i] = 0;
                    this.length += I
                }
                return this._strip()
            }, g.prototype.ishln = function(A) {
                return t(0 === this.negative), this.iushln(A)
            }, g.prototype.iushrn = function(A, i, e) {
                var I;
                t("number" == typeof A && A >= 0), I = i ? (i - i % 26) / 26 : 0;
                var g = A % 26,
                    r = Math.min((A - g) / 26, this.length),
                    o = 67108863 ^ 67108863 >>> g << g,
                    n = e;
                if (I -= r, I = Math.max(0, I), n) {
                    for (var B = 0; B < r; B++) n.words[B] = this.words[B];
                    n.length = r
                }
                if (0 === r);
                else if (this.length > r)
                    for (this.length -= r, B = 0; B < this.length; B++) this.words[B] = this.words[B + r];
                else this.words[0] = 0, this.length = 1;
                var a = 0;
                for (B = this.length - 1; B >= 0 && (0 !== a || B >= I); B--) {
                    var s = 0 | this.words[B];
                    this.words[B] = a << 26 - g | s >>> g, a = s & o
                }
                return n && 0 !== a && (n.words[n.length++] = a), 0 === this.length && (this.words[0] = 0, this.length = 1), this._strip()
            }, g.prototype.ishrn = function(A, i, e) {
                return t(0 === this.negative), this.iushrn(A, i, e)
            }, g.prototype.shln = function(A) {
                return this.clone().ishln(A)
            }, g.prototype.ushln = function(A) {
                return this.clone().iushln(A)
            }, g.prototype.shrn = function(A) {
                return this.clone().ishrn(A)
            }, g.prototype.ushrn = function(A) {
                return this.clone().iushrn(A)
            }, g.prototype.testn = function(A) {
                t("number" == typeof A && A >= 0);
                var i = A % 26,
                    e = (A - i) / 26,
                    I = 1 << i;
                return !(this.length <= e) && !!(this.words[e] & I)
            }, g.prototype.imaskn = function(A) {
                t("number" == typeof A && A >= 0);
                var i = A % 26,
                    e = (A - i) / 26;
                if (t(0 === this.negative, "imaskn works only with positive numbers"), this.length <= e) return this;
                if (0 !== i && e++, this.length = Math.min(e, this.length), 0 !== i) {
                    var I = 67108863 ^ 67108863 >>> i << i;
                    this.words[this.length - 1] &= I
                }
                return this._strip()
            }, g.prototype.maskn = function(A) {
                return this.clone().imaskn(A)
            }, g.prototype.iaddn = function(A) {
                return t("number" == typeof A), t(A < 67108864), A < 0 ? this.isubn(-A) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) <= A ? (this.words[0] = A - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(A), this.negative = 1, this) : this._iaddn(A)
            }, g.prototype._iaddn = function(A) {
                this.words[0] += A;
                for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) this.words[i] -= 67108864, i === this.length - 1 ? this.words[i + 1] = 1 : this.words[i + 1]++;
                return this.length = Math.max(this.length, i + 1), this
            }, g.prototype.isubn = function(A) {
                if (t("number" == typeof A), t(A < 67108864), A < 0) return this.iaddn(-A);
                if (0 !== this.negative) return this.negative = 0, this.iaddn(A), this.negative = 1, this;
                if (this.words[0] -= A, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                else
                    for (var i = 0; i < this.length && this.words[i] < 0; i++) this.words[i] += 67108864, this.words[i + 1] -= 1;
                return this._strip()
            }, g.prototype.addn = function(A) {
                return this.clone().iaddn(A)
            }, g.prototype.subn = function(A) {
                return this.clone().isubn(A)
            }, g.prototype.iabs = function() {
                return this.negative = 0, this
            }, g.prototype.abs = function() {
                return this.clone().iabs()
            }, g.prototype._ishlnsubmul = function(A, i, e) {
                var I, g, r = A.length + e;
                this._expand(r);
                var o = 0;
                for (I = 0; I < A.length; I++) {
                    g = (0 | this.words[I + e]) + o;
                    var n = (0 | A.words[I]) * i;
                    o = ((g -= 67108863 & n) >> 26) - (n / 67108864 | 0), this.words[I + e] = 67108863 & g
                }
                for (; I < this.length - e; I++) o = (g = (0 | this.words[I + e]) + o) >> 26, this.words[I + e] = 67108863 & g;
                if (0 === o) return this._strip();
                for (t(-1 === o), o = 0, I = 0; I < this.length; I++) o = (g = -(0 | this.words[I]) + o) >> 26, this.words[I] = 67108863 & g;
                return this.negative = 1, this._strip()
            }, g.prototype._wordDiv = function(A, i) {
                var e = (this.length, A.length),
                    t = this.clone(),
                    I = A,
                    r = 0 | I.words[I.length - 1];
                0 !== (e = 26 - this._countBits(r)) && (I = I.ushln(e), t.iushln(e), r = 0 | I.words[I.length - 1]);
                var o, n = t.length - I.length;
                if ("mod" !== i) {
                    (o = new g(null)).length = n + 1, o.words = new Array(o.length);
                    for (var B = 0; B < o.length; B++) o.words[B] = 0
                }
                var a = t.clone()._ishlnsubmul(I, 1, n);
                0 === a.negative && (t = a, o && (o.words[n] = 1));
                for (var s = n - 1; s >= 0; s--) {
                    var E = 67108864 * (0 | t.words[I.length + s]) + (0 | t.words[I.length + s - 1]);
                    for (E = Math.min(E / r | 0, 67108863), t._ishlnsubmul(I, E, s); 0 !== t.negative;) E--, t.negative = 0, t._ishlnsubmul(I, 1, s), t.isZero() || (t.negative ^= 1);
                    o && (o.words[s] = E)
                }
                return o && o._strip(), t._strip(), "div" !== i && 0 !== e && t.iushrn(e), {
                    div: o || null,
                    mod: t
                }
            }, g.prototype.divmod = function(A, i, e) {
                return t(!A.isZero()), this.isZero() ? {
                    div: new g(0),
                    mod: new g(0)
                } : 0 !== this.negative && 0 === A.negative ? (o = this.neg().divmod(A, i), "mod" !== i && (I = o.div.neg()), "div" !== i && (r = o.mod.neg(), e && 0 !== r.negative && r.iadd(A)), {
                    div: I,
                    mod: r
                }) : 0 === this.negative && 0 !== A.negative ? (o = this.divmod(A.neg(), i), "mod" !== i && (I = o.div.neg()), {
                    div: I,
                    mod: o.mod
                }) : 0 != (this.negative & A.negative) ? (o = this.neg().divmod(A.neg(), i), "div" !== i && (r = o.mod.neg(), e && 0 !== r.negative && r.isub(A)), {
                    div: o.div,
                    mod: r
                }) : A.length > this.length || this.cmp(A) < 0 ? {
                    div: new g(0),
                    mod: this
                } : 1 === A.length ? "div" === i ? {
                    div: this.divn(A.words[0]),
                    mod: null
                } : "mod" === i ? {
                    div: null,
                    mod: new g(this.modrn(A.words[0]))
                } : {
                    div: this.divn(A.words[0]),
                    mod: new g(this.modrn(A.words[0]))
                } : this._wordDiv(A, i);
                var I, r, o
            }, g.prototype.div = function(A) {
                return this.divmod(A, "div", !1).div
            }, g.prototype.mod = function(A) {
                return this.divmod(A, "mod", !1).mod
            }, g.prototype.umod = function(A) {
                return this.divmod(A, "mod", !0).mod
            }, g.prototype.divRound = function(A) {
                var i = this.divmod(A);
                if (i.mod.isZero()) return i.div;
                var e = 0 !== i.div.negative ? i.mod.isub(A) : i.mod,
                    t = A.ushrn(1),
                    I = A.andln(1),
                    g = e.cmp(t);
                return g < 0 || 1 === I && 0 === g ? i.div : 0 !== i.div.negative ? i.div.isubn(1) : i.div.iaddn(1)
            }, g.prototype.modrn = function(A) {
                var i = A < 0;
                i && (A = -A), t(A <= 67108863);
                for (var e = (1 << 26) % A, I = 0, g = this.length - 1; g >= 0; g--) I = (e * I + (0 | this.words[g])) % A;
                return i ? -I : I
            }, g.prototype.modn = function(A) {
                return this.modrn(A)
            }, g.prototype.idivn = function(A) {
                var i = A < 0;
                i && (A = -A), t(A <= 67108863);
                for (var e = 0, I = this.length - 1; I >= 0; I--) {
                    var g = (0 | this.words[I]) + 67108864 * e;
                    this.words[I] = g / A | 0, e = g % A
                }
                return this._strip(), i ? this.ineg() : this
            }, g.prototype.divn = function(A) {
                return this.clone().idivn(A)
            }, g.prototype.egcd = function(A) {
                t(0 === A.negative), t(!A.isZero());
                var i = this,
                    e = A.clone();
                i = 0 !== i.negative ? i.umod(A) : i.clone();
                for (var I = new g(1), r = new g(0), o = new g(0), n = new g(1), B = 0; i.isEven() && e.isEven();) i.iushrn(1), e.iushrn(1), ++B;
                for (var a = e.clone(), s = i.clone(); !i.isZero();) {
                    for (var E = 0, C = 1; 0 == (i.words[0] & C) && E < 26; ++E, C <<= 1);
                    if (E > 0)
                        for (i.iushrn(E); E-- > 0;)(I.isOdd() || r.isOdd()) && (I.iadd(a), r.isub(s)), I.iushrn(1), r.iushrn(1);
                    for (var Q = 0, h = 1; 0 == (e.words[0] & h) && Q < 26; ++Q, h <<= 1);
                    if (Q > 0)
                        for (e.iushrn(Q); Q-- > 0;)(o.isOdd() || n.isOdd()) && (o.iadd(a), n.isub(s)), o.iushrn(1), n.iushrn(1);
                    i.cmp(e) >= 0 ? (i.isub(e), I.isub(o), r.isub(n)) : (e.isub(i), o.isub(I), n.isub(r))
                }
                return {
                    a: o,
                    b: n,
                    gcd: e.iushln(B)
                }
            }, g.prototype._invmp = function(A) {
                t(0 === A.negative), t(!A.isZero());
                var i = this,
                    e = A.clone();
                i = 0 !== i.negative ? i.umod(A) : i.clone();
                for (var I, r = new g(1), o = new g(0), n = e.clone(); i.cmpn(1) > 0 && e.cmpn(1) > 0;) {
                    for (var B = 0, a = 1; 0 == (i.words[0] & a) && B < 26; ++B, a <<= 1);
                    if (B > 0)
                        for (i.iushrn(B); B-- > 0;) r.isOdd() && r.iadd(n), r.iushrn(1);
                    for (var s = 0, E = 1; 0 == (e.words[0] & E) && s < 26; ++s, E <<= 1);
                    if (s > 0)
                        for (e.iushrn(s); s-- > 0;) o.isOdd() && o.iadd(n), o.iushrn(1);
                    i.cmp(e) >= 0 ? (i.isub(e), r.isub(o)) : (e.isub(i), o.isub(r))
                }
                return (I = 0 === i.cmpn(1) ? r : o).cmpn(0) < 0 && I.iadd(A), I
            }, g.prototype.gcd = function(A) {
                if (this.isZero()) return A.abs();
                if (A.isZero()) return this.abs();
                var i = this.clone(),
                    e = A.clone();
                i.negative = 0, e.negative = 0;
                for (var t = 0; i.isEven() && e.isEven(); t++) i.iushrn(1), e.iushrn(1);
                for (;;) {
                    for (; i.isEven();) i.iushrn(1);
                    for (; e.isEven();) e.iushrn(1);
                    var I = i.cmp(e);
                    if (I < 0) {
                        var g = i;
                        i = e, e = g
                    } else if (0 === I || 0 === e.cmpn(1)) break;
                    i.isub(e)
                }
                return e.iushln(t)
            }, g.prototype.invm = function(A) {
                return this.egcd(A).a.umod(A)
            }, g.prototype.isEven = function() {
                return 0 == (1 & this.words[0])
            }, g.prototype.isOdd = function() {
                return 1 == (1 & this.words[0])
            }, g.prototype.andln = function(A) {
                return this.words[0] & A
            }, g.prototype.bincn = function(A) {
                t("number" == typeof A);
                var i = A % 26,
                    e = (A - i) / 26,
                    I = 1 << i;
                if (this.length <= e) return this._expand(e + 1), this.words[e] |= I, this;
                for (var g = I, r = e; 0 !== g && r < this.length; r++) {
                    var o = 0 | this.words[r];
                    g = (o += g) >>> 26, o &= 67108863, this.words[r] = o
                }
                return 0 !== g && (this.words[r] = g, this.length++), this
            }, g.prototype.isZero = function() {
                return 1 === this.length && 0 === this.words[0]
            }, g.prototype.cmpn = function(A) {
                var i, e = A < 0;
                if (0 !== this.negative && !e) return -1;
                if (0 === this.negative && e) return 1;
                if (this._strip(), this.length > 1) i = 1;
                else {
                    e && (A = -A), t(A <= 67108863, "Number is too big");
                    var I = 0 | this.words[0];
                    i = I === A ? 0 : I < A ? -1 : 1
                }
                return 0 !== this.negative ? 0 | -i : i
            }, g.prototype.cmp = function(A) {
                if (0 !== this.negative && 0 === A.negative) return -1;
                if (0 === this.negative && 0 !== A.negative) return 1;
                var i = this.ucmp(A);
                return 0 !== this.negative ? 0 | -i : i
            }, g.prototype.ucmp = function(A) {
                if (this.length > A.length) return 1;
                if (this.length < A.length) return -1;
                for (var i = 0, e = this.length - 1; e >= 0; e--) {
                    var t = 0 | this.words[e],
                        I = 0 | A.words[e];
                    if (t !== I) {
                        t < I ? i = -1 : t > I && (i = 1);
                        break
                    }
                }
                return i
            }, g.prototype.gtn = function(A) {
                return 1 === this.cmpn(A)
            }, g.prototype.gt = function(A) {
                return 1 === this.cmp(A)
            }, g.prototype.gten = function(A) {
                return this.cmpn(A) >= 0
            }, g.prototype.gte = function(A) {
                return this.cmp(A) >= 0
            }, g.prototype.ltn = function(A) {
                return -1 === this.cmpn(A)
            }, g.prototype.lt = function(A) {
                return -1 === this.cmp(A)
            }, g.prototype.lten = function(A) {
                return this.cmpn(A) <= 0
            }, g.prototype.lte = function(A) {
                return this.cmp(A) <= 0
            }, g.prototype.eqn = function(A) {
                return 0 === this.cmpn(A)
            }, g.prototype.eq = function(A) {
                return 0 === this.cmp(A)
            }, g.red = function(A) {
                return new k(A)
            }, g.prototype.toRed = function(A) {
                return t(!this.red, "Already a number in reduction context"), t(0 === this.negative, "red works only with positives"), A.convertTo(this)._forceRed(A)
            }, g.prototype.fromRed = function() {
                return t(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
            }, g.prototype._forceRed = function(A) {
                return this.red = A, this
            }, g.prototype.forceRed = function(A) {
                return t(!this.red, "Already a number in reduction context"), this._forceRed(A)
            }, g.prototype.redAdd = function(A) {
                return t(this.red, "redAdd works only with red numbers"), this.red.add(this, A)
            }, g.prototype.redIAdd = function(A) {
                return t(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, A)
            }, g.prototype.redSub = function(A) {
                return t(this.red, "redSub works only with red numbers"), this.red.sub(this, A)
            }, g.prototype.redISub = function(A) {
                return t(this.red, "redISub works only with red numbers"), this.red.isub(this, A)
            }, g.prototype.redShl = function(A) {
                return t(this.red, "redShl works only with red numbers"), this.red.shl(this, A)
            }, g.prototype.redMul = function(A) {
                return t(this.red, "redMul works only with red numbers"), this.red._verify2(this, A), this.red.mul(this, A)
            }, g.prototype.redIMul = function(A) {
                return t(this.red, "redMul works only with red numbers"), this.red._verify2(this, A), this.red.imul(this, A)
            }, g.prototype.redSqr = function() {
                return t(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
            }, g.prototype.redISqr = function() {
                return t(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
            }, g.prototype.redSqrt = function() {
                return t(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
            }, g.prototype.redInvm = function() {
                return t(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
            }, g.prototype.redNeg = function() {
                return t(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
            }, g.prototype.redPow = function(A) {
                return t(this.red && !A.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, A)
            };
            var d = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };

            function p(A, i) {
                this.name = A, this.p = new g(i, 16), this.n = this.p.bitLength(), this.k = new g(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
            }

            function f() {
                p.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }

            function y() {
                p.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }

            function D() {
                p.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }

            function w() {
                p.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }

            function k(A) {
                if ("string" == typeof A) {
                    var i = g._prime(A);
                    this.m = i.p, this.prime = i
                } else t(A.gtn(1), "modulus must be greater than 1"), this.m = A, this.prime = null
            }

            function m(A) {
                k.call(this, A), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new g(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
            }
            p.prototype._tmp = function() {
                var A = new g(null);
                return A.words = new Array(Math.ceil(this.n / 13)), A
            }, p.prototype.ireduce = function(A) {
                var i, e = A;
                do {
                    this.split(e, this.tmp), i = (e = (e = this.imulK(e)).iadd(this.tmp)).bitLength()
                } while (i > this.n);
                var t = i < this.n ? -1 : e.ucmp(this.p);
                return 0 === t ? (e.words[0] = 0, e.length = 1) : t > 0 ? e.isub(this.p) : e._strip(), e
            }, p.prototype.split = function(A, i) {
                A.iushrn(this.n, 0, i)
            }, p.prototype.imulK = function(A) {
                return A.imul(this.k)
            }, I(f, p), f.prototype.split = function(A, i) {
                for (var e = Math.min(A.length, 9), t = 0; t < e; t++) i.words[t] = A.words[t];
                if (i.length = e, A.length <= 9) return A.words[0] = 0, void(A.length = 1);
                var I = A.words[9];
                for (i.words[i.length++] = 4194303 & I, t = 10; t < A.length; t++) {
                    var g = 0 | A.words[t];
                    A.words[t - 10] = (4194303 & g) << 4 | I >>> 22, I = g
                }
                I >>>= 22, A.words[t - 10] = I, 0 === I && A.length > 10 ? A.length -= 10 : A.length -= 9
            }, f.prototype.imulK = function(A) {
                A.words[A.length] = 0, A.words[A.length + 1] = 0, A.length += 2;
                for (var i = 0, e = 0; e < A.length; e++) {
                    var t = 0 | A.words[e];
                    i += 977 * t, A.words[e] = 67108863 & i, i = 64 * t + (i / 67108864 | 0)
                }
                return 0 === A.words[A.length - 1] && (A.length--, 0 === A.words[A.length - 1] && A.length--), A
            }, I(y, p), I(D, p), I(w, p), w.prototype.imulK = function(A) {
                for (var i = 0, e = 0; e < A.length; e++) {
                    var t = 19 * (0 | A.words[e]) + i,
                        I = 67108863 & t;
                    t >>>= 26, A.words[e] = I, i = t
                }
                return 0 !== i && (A.words[A.length++] = i), A
            }, g._prime = function(A) {
                if (d[A]) return d[A];
                var i;
                if ("k256" === A) i = new f;
                else if ("p224" === A) i = new y;
                else if ("p192" === A) i = new D;
                else {
                    if ("p25519" !== A) throw new Error("Unknown prime " + A);
                    i = new w
                }
                return d[A] = i, i
            }, k.prototype._verify1 = function(A) {
                t(0 === A.negative, "red works only with positives"), t(A.red, "red works only with red numbers")
            }, k.prototype._verify2 = function(A, i) {
                t(0 == (A.negative | i.negative), "red works only with positives"), t(A.red && A.red === i.red, "red works only with red numbers")
            }, k.prototype.imod = function(A) {
                return this.prime ? this.prime.ireduce(A)._forceRed(this) : (B(A, A.umod(this.m)._forceRed(this)), A)
            }, k.prototype.neg = function(A) {
                return A.isZero() ? A.clone() : this.m.sub(A)._forceRed(this)
            }, k.prototype.add = function(A, i) {
                this._verify2(A, i);
                var e = A.add(i);
                return e.cmp(this.m) >= 0 && e.isub(this.m), e._forceRed(this)
            }, k.prototype.iadd = function(A, i) {
                this._verify2(A, i);
                var e = A.iadd(i);
                return e.cmp(this.m) >= 0 && e.isub(this.m), e
            }, k.prototype.sub = function(A, i) {
                this._verify2(A, i);
                var e = A.sub(i);
                return e.cmpn(0) < 0 && e.iadd(this.m), e._forceRed(this)
            }, k.prototype.isub = function(A, i) {
                this._verify2(A, i);
                var e = A.isub(i);
                return e.cmpn(0) < 0 && e.iadd(this.m), e
            }, k.prototype.shl = function(A, i) {
                return this._verify1(A), this.imod(A.ushln(i))
            }, k.prototype.imul = function(A, i) {
                return this._verify2(A, i), this.imod(A.imul(i))
            }, k.prototype.mul = function(A, i) {
                return this._verify2(A, i), this.imod(A.mul(i))
            }, k.prototype.isqr = function(A) {
                return this.imul(A, A.clone())
            }, k.prototype.sqr = function(A) {
                return this.mul(A, A)
            }, k.prototype.sqrt = function(A) {
                if (A.isZero()) return A.clone();
                var i = this.m.andln(3);
                if (t(i % 2 == 1), 3 === i) {
                    var e = this.m.add(new g(1)).iushrn(2);
                    return this.pow(A, e)
                }
                for (var I = this.m.subn(1), r = 0; !I.isZero() && 0 === I.andln(1);) r++, I.iushrn(1);
                t(!I.isZero());
                var o = new g(1).toRed(this),
                    n = o.redNeg(),
                    B = this.m.subn(1).iushrn(1),
                    a = this.m.bitLength();
                for (a = new g(2 * a * a).toRed(this); 0 !== this.pow(a, B).cmp(n);) a.redIAdd(n);
                for (var s = this.pow(a, I), E = this.pow(A, I.addn(1).iushrn(1)), C = this.pow(A, I), Q = r; 0 !== C.cmp(o);) {
                    for (var h = C, c = 0; 0 !== h.cmp(o); c++) h = h.redSqr();
                    t(c < Q);
                    var l = this.pow(s, new g(1).iushln(Q - c - 1));
                    E = E.redMul(l), s = l.redSqr(), C = C.redMul(s), Q = c
                }
                return E
            }, k.prototype.invm = function(A) {
                var i = A._invmp(this.m);
                return 0 !== i.negative ? (i.negative = 0, this.imod(i).redNeg()) : this.imod(i)
            }, k.prototype.pow = function(A, i) {
                if (i.isZero()) return new g(1).toRed(this);
                if (0 === i.cmpn(1)) return A.clone();
                var e = new Array(16);
                e[0] = new g(1).toRed(this), e[1] = A;
                for (var t = 2; t < e.length; t++) e[t] = this.mul(e[t - 1], A);
                var I = e[0],
                    r = 0,
                    o = 0,
                    n = i.bitLength() % 26;
                for (0 === n && (n = 26), t = i.length - 1; t >= 0; t--) {
                    for (var B = i.words[t], a = n - 1; a >= 0; a--) {
                        var s = B >> a & 1;
                        I !== e[0] && (I = this.sqr(I)), 0 !== s || 0 !== r ? (r <<= 1, r |= s, (4 === ++o || 0 === t && 0 === a) && (I = this.mul(I, e[r]), o = 0, r = 0)) : o = 0
                    }
                    n = 26
                }
                return I
            }, k.prototype.convertTo = function(A) {
                var i = A.umod(this.m);
                return i === A ? i.clone() : i
            }, k.prototype.convertFrom = function(A) {
                var i = A.clone();
                return i.red = null, i
            }, g.mont = function(A) {
                return new m(A)
            }, I(m, k), m.prototype.convertTo = function(A) {
                return this.imod(A.ushln(this.shift))
            }, m.prototype.convertFrom = function(A) {
                var i = this.imod(A.mul(this.rinv));
                return i.red = null, i
            }, m.prototype.imul = function(A, i) {
                if (A.isZero() || i.isZero()) return A.words[0] = 0, A.length = 1, A;
                var e = A.imul(i),
                    t = e.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    I = e.isub(t).iushrn(this.shift),
                    g = I;
                return I.cmp(this.m) >= 0 ? g = I.isub(this.m) : I.cmpn(0) < 0 && (g = I.iadd(this.m)), g._forceRed(this)
            }, m.prototype.mul = function(A, i) {
                if (A.isZero() || i.isZero()) return new g(0)._forceRed(this);
                var e = A.mul(i),
                    t = e.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    I = e.isub(t).iushrn(this.shift),
                    r = I;
                return I.cmp(this.m) >= 0 ? r = I.isub(this.m) : I.cmpn(0) < 0 && (r = I.iadd(this.m)), r._forceRed(this)
            }, m.prototype.invm = function(A) {
                return this.imod(A._invmp(this.m).mul(this.r2))._forceRed(this)
            }
        }(void 0 === A || A, this)
    }).call(this, e(17)(A))
}, function(A, i) {
    var e = {}.toString;
    A.exports = Array.isArray || function(A) {
        return "[object Array]" == e.call(A)
    }
}, function(A, i) {
    i.read = function(A, i, e, t, I) {
        var g, r, o = 8 * I - t - 1,
            n = (1 << o) - 1,
            B = n >> 1,
            a = -7,
            s = e ? I - 1 : 0,
            E = e ? -1 : 1,
            C = A[i + s];
        for (s += E, g = C & (1 << -a) - 1, C >>= -a, a += o; a > 0; g = 256 * g + A[i + s], s += E, a -= 8);
        for (r = g & (1 << -a) - 1, g >>= -a, a += t; a > 0; r = 256 * r + A[i + s], s += E, a -= 8);
        if (0 === g) g = 1 - B;
        else {
            if (g === n) return r ? NaN : 1 / 0 * (C ? -1 : 1);
            r += Math.pow(2, t), g -= B
        }
        return (C ? -1 : 1) * r * Math.pow(2, g - t)
    }, i.write = function(A, i, e, t, I, g) {
        var r, o, n, B = 8 * g - I - 1,
            a = (1 << B) - 1,
            s = a >> 1,
            E = 23 === I ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
            C = t ? 0 : g - 1,
            Q = t ? 1 : -1,
            h = i < 0 || 0 === i && 1 / i < 0 ? 1 : 0;
        for (i = Math.abs(i), isNaN(i) || i === 1 / 0 ? (o = isNaN(i) ? 1 : 0, r = a) : (r = Math.floor(Math.log(i) / Math.LN2), i * (n = Math.pow(2, -r)) < 1 && (r--, n *= 2), (i += r + s >= 1 ? E / n : E * Math.pow(2, 1 - s)) * n >= 2 && (r++, n /= 2), r + s >= a ? (o = 0, r = a) : r + s >= 1 ? (o = (i * n - 1) * Math.pow(2, I), r += s) : (o = i * Math.pow(2, s - 1) * Math.pow(2, I), r = 0)); I >= 8; A[e + C] = 255 & o, C += Q, o /= 256, I -= 8);
        for (r = r << I | o, B += I; B > 0; A[e + C] = 255 & r, C += Q, r /= 256, B -= 8);
        A[e + C - Q] |= 128 * h
    }
}, function(A, i, e) {
    "use strict";
    i.byteLength = function(A) {
        var i = B(A),
            e = i[0],
            t = i[1];
        return 3 * (e + t) / 4 - t
    }, i.toByteArray = function(A) {
        var i, e, t = B(A),
            r = t[0],
            o = t[1],
            n = new g(function(A, i, e) {
                return 3 * (i + e) / 4 - e
            }(0, r, o)),
            a = 0,
            s = o > 0 ? r - 4 : r;
        for (e = 0; e < s; e += 4) i = I[A.charCodeAt(e)] << 18 | I[A.charCodeAt(e + 1)] << 12 | I[A.charCodeAt(e + 2)] << 6 | I[A.charCodeAt(e + 3)], n[a++] = i >> 16 & 255, n[a++] = i >> 8 & 255, n[a++] = 255 & i;
        2 === o && (i = I[A.charCodeAt(e)] << 2 | I[A.charCodeAt(e + 1)] >> 4, n[a++] = 255 & i);
        1 === o && (i = I[A.charCodeAt(e)] << 10 | I[A.charCodeAt(e + 1)] << 4 | I[A.charCodeAt(e + 2)] >> 2, n[a++] = i >> 8 & 255, n[a++] = 255 & i);
        return n
    }, i.fromByteArray = function(A) {
        for (var i, e = A.length, I = e % 3, g = [], r = 0, o = e - I; r < o; r += 16383) g.push(a(A, r, r + 16383 > o ? o : r + 16383));
        1 === I ? (i = A[e - 1], g.push(t[i >> 2] + t[i << 4 & 63] + "==")) : 2 === I && (i = (A[e - 2] << 8) + A[e - 1], g.push(t[i >> 10] + t[i >> 4 & 63] + t[i << 2 & 63] + "="));
        return g.join("")
    };
    for (var t = [], I = [], g = "undefined" != typeof Uint8Array ? Uint8Array : Array, r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, n = r.length; o < n; ++o) t[o] = r[o], I[r.charCodeAt(o)] = o;

    function B(A) {
        var i = A.length;
        if (i % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        var e = A.indexOf("=");
        return -1 === e && (e = i), [e, e === i ? 0 : 4 - e % 4]
    }

    function a(A, i, e) {
        for (var I, g, r = [], o = i; o < e; o += 3) I = (A[o] << 16 & 16711680) + (A[o + 1] << 8 & 65280) + (255 & A[o + 2]), r.push(t[(g = I) >> 18 & 63] + t[g >> 12 & 63] + t[g >> 6 & 63] + t[63 & g]);
        return r.join("")
    }
    I["-".charCodeAt(0)] = 62, I["_".charCodeAt(0)] = 63
}, function(A, i, e) {
    (function(i) {
        A.exports = function(A) {
            A.Buffer = e(0).Buffer, A.isBuffer = A.Buffer.isBuffer, A.BN = e(18), A.__nodeCrypto = !1;
            try {
                A.__nodeCrypto = e(15)
            } catch (A) {}
            A.Buffer.prototype.seek = function(A) {
                this.__offset = A > this.length ? this.length : A
            }, A.Buffer.prototype.tell = function() {
                this.__offset
            }, A.Buffer.prototype.read = function(i) {
                if (void 0 === this.__offset && (this.__offset = 0), this.__offset === this.length) return A.Buffer.from([]);
                let e = this.__offset + i;
                e > this.length && (e = this.length);
                let t = this.slice(this.__offset, e);
                return this.__offset = e, t
            }, A.Buffer.prototype.readVarInt = function() {
                if (void 0 === this.__offset && (this.__offset = 0), this.__offset === this.length) return A.Buffer.from([]);
                let i = this[this.__offset];
                return i < 253 ? i = 1 : 253 === i ? i = 3 : 254 === i ? i = 5 : 255 === i && (i = 9), this.read(i)
            }, A.Buffer.prototype.readInt = function(A, i = "little") {
                if (void 0 === this.__offset && (this.__offset = 0), this.__offset === this.length) return 0;
                let e;
                return this.__offset + A > this.length && (A = this.length - this.__offset), e = "little" === i ? this.readUIntLE(this.__offset, A) : this.readUIntBE(this.__offset, A), this.__offset += A, e
            }, A.Buffer.prototype.hex = function() {
                return this.toString("hex")
            }, A.getWindow = () => "undefined" != typeof window ? window : void 0 !== i ? i : "undefined" != typeof self ? self : {}, A.readVarInt = A => {
                let i = A[A.__offset];
                return i < 253 ? i = 1 : 253 === i ? i = 3 : 254 === i ? i = 5 : 255 === i && (i = 9), A.read(i)
            }, A.BNZerro = new A.BN(0), A.isHex = A => Boolean(/^[0-9a-fA-F]+$/.test(A) && !(A.length % 2)), A.getBuffer = function(i, e = "hex") {
                if (A.isBuffer(i)) return void 0 === i.read ? A.Buffer.from(i) : i;
                if (A.isString(i)) {
                    if (0 === i.length) return A.Buffer(0);
                    e = e.split("|");
                    for (let t of e)
                        if ("hex" === t) {
                            if (A.isHex(i)) return A.Buffer.from(i, t)
                        } else if ("utf8" === t) return A.Buffer.from(i, t);
                    throw new Error(e + " encoding required :" + e)
                }
                return A.Buffer.from(i)
            }, A.isString = function(A) {
                return "string" == typeof A || A instanceof String
            }, A.defArgs = function(A, i) {
                if (!(A instanceof Object) && void 0 !== A) throw new Error("Invalid named arguments object");
                for (let e in i) void 0 === A[e] && (A[e] = i[e])
            }, A.bytesToString = function(A) {
                return A.map((function(A) {
                    return String.fromCharCode(A)
                })).join("")
            }, A.hexToBytes = A => {
                if (A.length % 2 == 1) throw new Error("hexToBytes can't have a string with an odd number of characters.");
                return 0 === A.indexOf("0x") && (A = A.slice(2)), A.match(/../g).map((function(A) {
                    return parseInt(A, 16)
                }))
            }, A.stringToBytes = function(A) {
                return A.split("").map((function(A) {
                    return A.charCodeAt(0)
                }))
            }, A.intToBytes = function(i, e, t = "little") {
                let I = [],
                    g = e;
                if (void 0 === e) throw new Error("bytes count required");
                if ("big" !== t && "little" !== t) throw new Error("invalid byte order");
                let r = "big" === t;
                if (e <= 4)
                    do {
                        r ? I.unshift(255 & i) : I.push(255 & i), i >>= 8
                    } while (--g);
                else I = (i = new A.BN(i)).toArrayLike(Array, r ? "be" : "le", e);
                return I
            }, A.intToVarInt = function(i) {
                let e;
                if (i instanceof A.BN) return e = i.lt(253) ? i.toArrayLike(Array, "le", 1) : i.lt(65535) ? [253].concat(i.toArrayLike(Array, "le", 2)) : i.lt(4294967295) ? [254].concat(i.toArrayLike(Array, "le", 4)) : [255].concat(i.toArrayLike(Array, "le", 8)), e;
                if (isNaN(i)) throw new Error("invalid argument type", i);
                return e = i < 253 ? [i] : i < 65535 ? [253].concat(A.intToBytes(i, 2, "little")) : i < 4294967295 ? [254].concat(A.intToBytes(i, 4, "little")) : [255].concat(A.intToBytes(i, 8, "little")), e
            }, A.varIntToInt = function(i, e = !1) {
                let t;
                return t = i[0] < 253 ? new A.BN(i[0]) : i[0] < 65535 ? new A.BN(i.slice(1, 3), "le") : i[0] < 4294967295 ? new A.BN(i.slice(1, 4), "le") : new A.BN(i.slice(1, 8), "le"), e ? t : t.toNumber()
            }, A.varIntLen = A => A[0] < 253 ? 1 : A[0] < 65535 ? 2 : A[0] < 4294967295 ? 4 : 8, A.rh2s = i => A.Buffer.from(i).reverse().hex(), A.s2rh = i => A.Buffer.from(i, "hex").reverse()
        }
    }).call(this, e(1))
}, function(A, i) {
    A.exports = function(A) {
        let i = A.Buffer.from,
            e = {},
            t = {},
            I = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
        for (let A = 0; A < I.length; A++) e[I[A]] = A, t[A] = I.charCodeAt(A);
        for (let A = 0; A < "QPZRY9X8GF2TVDW0S3JN54KHCE6MUA7L".length; A++) e["QPZRY9X8GF2TVDW0S3JN54KHCE6MUA7L" [A]] = A;
        A.BASE32CHARSET = I, A.BASE32CHARSET_UPCASE = "QPZRY9X8GF2TVDW0S3JN54KHCE6MUA7L", A.INT_BASE32_MAP = e, A.BASE32_INT_MAP = t, A.MAINNET_ADDRESS_PREFIX = "1", A.TESTNET_ADDRESS_PREFIX = "m", A.TESTNET_ADDRESS_PREFIX_2 = "n", A.MAINNET_SCRIPT_ADDRESS_PREFIX = "3", A.TESTNET_SCRIPT_ADDRESS_PREFIX = "2", A.MAINNET_SEGWIT_ADDRESS_PREFIX = "bc", A.TESTNET_SEGWIT_ADDRESS_PREFIX = "tb", A.MAINNET_ADDRESS_BYTE_PREFIX = [0], A.TESTNET_ADDRESS_BYTE_PREFIX = [111], A.MAINNET_SCRIPT_ADDRESS_BYTE_PREFIX = [5], A.TESTNET_SCRIPT_ADDRESS_BYTE_PREFIX = [196], A.MAINNET_SEGWIT_ADDRESS_BYTE_PREFIX = [3, 3, 0, 2, 3], A.TESTNET_SEGWIT_ADDRESS_BYTE_PREFIX = [3, 3, 0, 20, 2], A.TESTNET_PRIVATE_KEY_BYTE_PREFIX = [239], A.MAINNET_PRIVATE_KEY_BYTE_PREFIX = [128], A.MAINNET_PRIVATE_KEY_UNCOMPRESSED_PREFIX = "5", A.MAINNET_PRIVATE_KEY_COMPRESSED_PREFIX = "K", A.MAINNET_PRIVATE_KEY_COMPRESSED_PREFIX_2 = "L", A.TESTNET_PRIVATE_KEY_UNCOMPRESSED_PREFIX = "9", A.TESTNET_PRIVATE_KEY_COMPRESSED_PREFIX = "c", A.ADDRESS_PREFIX_LIST = ["1", "m", "n", "3", "2"], A.PRIVATE_KEY_PREFIX_LIST = ["5", "K", "L", "9", "c"], A.SCRIPT_TYPES = {
            P2PKH: 0,
            P2SH: 1,
            PUBKEY: 2,
            NULL_DATA: 3,
            MULTISIG: 4,
            P2WPKH: 5,
            P2WSH: 6,
            NON_STANDARD: 7,
            NULL_DATA_NON_STANDARD: 8
        }, A.SCRIPT_N_TYPES = {
            0: "P2PKH",
            1: "P2SH",
            2: "PUBKEY",
            3: "NULL_DATA",
            4: "MULTISIG",
            5: "P2WPKH",
            6: "P2WSH",
            7: "NON_STANDARD",
            8: "NULL_DATA_NON_STANDARD"
        }, A.GAMMA_NUM_LN = 607 / 128, A.GAMMA_TABLE_LN = [.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -9837447530487956e-20, .0001580887032249125, -.00021026444172410488, .00021743961811521265, -.0001643181065367639, 8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22], A.MACHEP = 11102230246251565e-32, A.MAXLOG = 709.782712893384, A.ECDSA_SEC256K1_ORDER = new A.BN("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16), A.SECP256K1_CONTEXT_VERIFY = 257, A.SECP256K1_CONTEXT_SIGN = 513, A.SECP256K1_CONTEXT_NONE = 1, A.SECP256K1_EC_COMPRESSED = 258, A.SECP256K1_EC_UNCOMPRESSED = 2, A.MAX_AMOUNT = 21e14, A.SIGHASH_ALL = 1, A.SIGHASH_NONE = 2, A.SIGHASH_SINGLE = 3, A.SIGHASH_ANYONECANPAY = 128, A.HARDENED_KEY = 2147483648, A.FIRST_HARDENED_CHILD = 2147483648, A.PATH_LEVEL_BIP0044 = [2147483692, 2147483648, 2147483648, 0, 0], A.TESTNET_PATH_LEVEL_BIP0044 = [2147483692, 2147483649, 2147483648, 0, 0], A.MAINNET_XPRIVATE_KEY_PREFIX = i([4, 136, 173, 228]), A.MAINNET_XPUBLIC_KEY_PREFIX = i([4, 136, 178, 30]), A.TESTNET_XPRIVATE_KEY_PREFIX = i([4, 53, 131, 148]), A.TESTNET_XPUBLIC_KEY_PREFIX = i([4, 53, 135, 207]), A.MAINNET_M44_XPRIVATE_KEY_PREFIX = i([4, 136, 173, 228]), A.MAINNET_M44_XPUBLIC_KEY_PREFIX = i([4, 136, 178, 30]), A.TESTNET_M44_XPRIVATE_KEY_PREFIX = i([4, 53, 131, 148]), A.TESTNET_M44_XPUBLIC_KEY_PREFIX = i([4, 53, 135, 207]), A.MAINNET_M49_XPRIVATE_KEY_PREFIX = i([4, 157, 120, 120]), A.MAINNET_M49_XPUBLIC_KEY_PREFIX = i([4, 157, 124, 178]), A.TESTNET_M49_XPRIVATE_KEY_PREFIX = i([4, 74, 78, 40]), A.TESTNET_M49_XPUBLIC_KEY_PREFIX = i([4, 74, 82, 98]), A.MAINNET_M84_XPRIVATE_KEY_PREFIX = i([4, 178, 67, 12]), A.MAINNET_M84_XPUBLIC_KEY_PREFIX = i([4, 178, 71, 70]), A.TESTNET_M84_XPRIVATE_KEY_PREFIX = i([4, 95, 24, 188]), A.TESTNET_M84_XPUBLIC_KEY_PREFIX = i([4, 95, 28, 246])
    }
}, function(A, i) {
    var e, t = (e = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0, "undefined" != typeof __filename && (e = e || __filename), function(A) {
        var i, t, I;
        A = A || {}, i || (i = void 0 !== A ? A : {}), i.ready = new Promise((function(A, i) {
            t = A, I = i
        }));
        var g, r, o, n, B = {};
        for (g in i) i.hasOwnProperty(g) && (B[g] = i[g]);
        r = "object" == typeof window, o = "function" == typeof importScripts;
        var a, s, E, C, Q = "";
        (n = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node) ? (Q = o ? require("path").dirname(Q) + "/" : __dirname + "/", a = function(A, i) {
            var e = oi(A);
            return e ? i ? e : e.toString() : (E || (E = require("fs")), C || (C = require("path")), A = C.normalize(A), E.readFileSync(A, i ? null : "utf8"))
        }, s = function(A) {
            return (A = a(A, !0)).buffer || (A = new Uint8Array(A)), f(A.buffer), A
        }, 1 < process.argv.length && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), process.on("uncaughtException", (function(A) {
            throw A
        })), process.on("unhandledRejection", Z), i.inspect = function() {
            return "[Emscripten Module object]"
        }) : (r || o) && (o ? Q = self.location.href : document.currentScript && (Q = document.currentScript.src), e && (Q = e), Q = 0 !== Q.indexOf("blob:") ? Q.substr(0, Q.lastIndexOf("/") + 1) : "", a = function(A) {
            try {
                var i = new XMLHttpRequest;
                return i.open("GET", A, !1), i.send(null), i.responseText
            } catch (I) {
                if (A = oi(A)) {
                    i = [];
                    for (var e = 0; e < A.length; e++) {
                        var t = A[e];
                        255 < t && (gi && f(!1, "Character code " + t + " (" + String.fromCharCode(t) + ")  at offset " + e + " not in 0x00-0xFF."), t &= 255), i.push(String.fromCharCode(t))
                    }
                    return i.join("")
                }
                throw I
            }
        }, o && (s = function(A) {
            try {
                var i = new XMLHttpRequest;
                return i.open("GET", A, !1), i.responseType = "arraybuffer", i.send(null), new Uint8Array(i.response)
            } catch (i) {
                if (A = oi(A)) return A;
                throw i
            }
        }));
        var h, c = i.print || console.log.bind(console),
            l = i.printErr || console.warn.bind(console);
        for (g in B) B.hasOwnProperty(g) && (i[g] = B[g]);
        B = null, i.wasmBinary && (h = i.wasmBinary), i.noExitRuntime && i.noExitRuntime, "object" != typeof WebAssembly && Z("no native wasm support detected");
        var u, d = new WebAssembly.Table({
                initial: 48,
                maximum: 48,
                element: "anyfunc"
            }),
            p = !1;

        function f(A, i) {
            A || Z("Assertion failed: " + i)
        }
        var y = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;

        function D(A, i, e) {
            var t = i + e;
            for (e = i; A[e] && !(e >= t);) ++e;
            if (16 < e - i && A.subarray && y) return y.decode(A.subarray(i, e));
            for (t = ""; i < e;) {
                var I = A[i++];
                if (128 & I) {
                    var g = 63 & A[i++];
                    if (192 == (224 & I)) t += String.fromCharCode((31 & I) << 6 | g);
                    else {
                        var r = 63 & A[i++];
                        65536 > (I = 224 == (240 & I) ? (15 & I) << 12 | g << 6 | r : (7 & I) << 18 | g << 12 | r << 6 | 63 & A[i++]) ? t += String.fromCharCode(I) : (I -= 65536, t += String.fromCharCode(55296 | I >> 10, 56320 | 1023 & I))
                    }
                } else t += String.fromCharCode(I)
            }
            return t
        }
        var w = "undefined" != typeof TextDecoder ? new TextDecoder("utf-16le") : void 0;

        function k(A, i) {
            for (var e = A >> 1, t = e + i / 2; !(e >= t) && H[e];) ++e;
            if (32 < (e <<= 1) - A && w) return w.decode(K.subarray(A, e));
            for (e = 0, t = "";;) {
                var I = v[A + 2 * e >> 1];
                if (0 == I || e == i / 2) return t;
                ++e, t += String.fromCharCode(I)
            }
        }

        function m(A, i, e) {
            if (void 0 === e && (e = 2147483647), 2 > e) return 0;
            var t = i;
            e = (e -= 2) < 2 * A.length ? e / 2 : A.length;
            for (var I = 0; I < e; ++I) v[i >> 1] = A.charCodeAt(I), i += 2;
            return v[i >> 1] = 0, i - t
        }

        function S(A) {
            return 2 * A.length
        }

        function M(A, i) {
            for (var e = 0, t = ""; !(e >= i / 4);) {
                var I = q[A + 4 * e >> 2];
                if (0 == I) break;
                ++e, 65536 <= I ? (I -= 65536, t += String.fromCharCode(55296 | I >> 10, 56320 | 1023 & I)) : t += String.fromCharCode(I)
            }
            return t
        }

        function F(A, i, e) {
            if (void 0 === e && (e = 2147483647), 4 > e) return 0;
            var t = i;
            e = t + e - 4;
            for (var I = 0; I < A.length; ++I) {
                var g = A.charCodeAt(I);
                if (55296 <= g && 57343 >= g && (g = 65536 + ((1023 & g) << 10) | 1023 & A.charCodeAt(++I)), q[i >> 2] = g, (i += 4) + 4 > e) break
            }
            return q[i >> 2] = 0, i - t
        }

        function N(A) {
            for (var i = 0, e = 0; e < A.length; ++e) {
                var t = A.charCodeAt(e);
                55296 <= t && 57343 >= t && ++e, i += 4
            }
            return i
        }
        var G, R, K, v, H, q, P, T, J, U = i.INITIAL_MEMORY || 16777216;
        (u = i.wasmMemory ? i.wasmMemory : new WebAssembly.Memory({
            initial: U / 65536,
            maximum: U / 65536
        })) && (G = u.buffer), U = G.byteLength;
        var Y = G;
        G = Y, i.HEAP8 = R = new Int8Array(Y), i.HEAP16 = v = new Int16Array(Y), i.HEAP32 = q = new Int32Array(Y), i.HEAPU8 = K = new Uint8Array(Y), i.HEAPU16 = H = new Uint16Array(Y), i.HEAPU32 = P = new Uint32Array(Y), i.HEAPF32 = T = new Float32Array(Y), i.HEAPF64 = J = new Float64Array(Y);
        var b = [],
            x = [],
            X = [],
            L = [];

        function W() {
            var A = i.preRun.shift();
            b.unshift(A)
        }
        var O = 0,
            V = null,
            _ = null;

        function Z(A) {
            throw i.onAbort && i.onAbort(A), l(A), p = !0, A = new WebAssembly.RuntimeError("abort(" + A + "). Build with -s ASSERTIONS=1 for more info."), I(A), A
        }

        function z(A) {
            var i = j;
            return String.prototype.startsWith ? A.startsWith(i) : 0 === A.indexOf(i)
        }
        i.preloadedImages = {}, i.preloadedAudios = {};
        var j = "data:application/octet-stream;base64,",
            $ = "data:application/octet-stream;base64,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AUEBaiEBIAJBAWoiAiADRw0ACwsgAAsbACAAIAIgBCACKAIAIAFzIANzIAVBACAGEDgLUgAgACAAKQMAIAEpAwB8NwMAIAAgACkDCCABKQMIfDcDCCAAIAApAxAgASkDEHw3AxAgACAAKQMYIAEpAxh8NwMYIAAgACkDICABKQMgfDcDIAtrAQJ+IAAgAkEBaq0iA0Le8P//3///D34gASkDAH03AwAgACADQv7///////8PfiIEIAEpAwh9NwMIIAAgBCABKQMQfTcDECAAIAQgASkDGH03AxggACADQv7///////8AfiABKQMgfTcDIAstACACRQRAIAAoAgQgASgCBEYPCyAAIAFGBEBBAQ8LIAAQggEgARCCARCrAkULIAAgACACIAQgASACKAIAIAMQiQEgBUHO+s/KeiAGEDgLIAAgACACIAQgASACKAIAIAMQiAEgBUHp7bXTByAGEDgLIAAgACACIAQgASACKAIAIAMQhwEgBUHc+e74eCAGEDgLIAAgACACIAQgASACKAIAIAMQhQEgBUHz/cDrBiAGEDgLIAAgACACIAQgASACKAIAIAMQhQEgBUGh1+f2BiAGEDgLIAAgACACIAQgASACKAIAIAMQhwEgBUGkorfiBSAGEDgLIAAgACACIAQgASACKAIAIAMQiAEgBUGZ84nUBSAGEDgLIAAgACACIAQgASACKAIAIAMQiQEgBUHml4qFBSAGEDgLGgAgACABIAIQlAEgAEEgaiABQSBqIAIQlAELCQAgACgAABBcC0gBAX4gACABrSICIAApAwB+NwMAIAAgACkDCCACfjcDCCAAIAApAxAgAn43AxAgACAAKQMYIAJ+NwMYIAAgACkDICACfjcDIAuWAQECfiAAIAApAwAgACkDICICQjCIQtGHgIAQfnwiAUL/////////B4M3AwAgACAAKQMIIAFCNIh8IgFC/////////weDNwMIIAAgACkDECABQjSIfCIBQv////////8HgzcDECAAIAApAxggAUI0iHwiAUL/////////B4M3AxggACACQv///////z+DIAFCNIh8NwMgCwoAIAAgASACEEgLtgMBAX4gACABKQAYIgNCOIYgA0IohkKAgICAgIDA/wCDhCADQhiGQoCAgICA4D+DIANCCIZCgICAgPAfg4SEIANCCIhCgICA+A+DIANCGIhCgID8B4OEIANCKIhCgP4DgyADQjiIhISENwMAIAAgASkAECIDQjiGIANCKIZCgICAgICAwP8Ag4QgA0IYhkKAgICAgOA/gyADQgiGQoCAgIDwH4OEhCADQgiIQoCAgPgPgyADQhiIQoCA/AeDhCADQiiIQoD+A4MgA0I4iISEhDcDCCAAIAEpAAgiA0I4hiADQiiGQoCAgICAgMD/AIOEIANCGIZCgICAgIDgP4MgA0IIhkKAgICA8B+DhIQgA0IIiEKAgID4D4MgA0IYiEKAgPwHg4QgA0IoiEKA/gODIANCOIiEhIQ3AxAgACABKQAAIgNCOIYgA0IohkKAgICAgIDA/wCDhCADQhiGQoCAgICA4D+DIANCCIZCgICAgPAfg4SEIANCCIhCgICA+A+DIANCGIhCgID8B4OEIANCKIhCgP4DgyADQjiIhISENwMYIAAgABB0EHMhACACBEAgAiAANgIACwvzAgICfwF+AkAgAkUNACAAIAJqIgNBf2ogAToAACAAIAE6AAAgAkEDSQ0AIANBfmogAToAACAAIAE6AAEgA0F9aiABOgAAIAAgAToAAiACQQdJDQAgA0F8aiABOgAAIAAgAToAAyACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiATYCACADIAIgBGtBfHEiBGoiAkF8aiABNgIAIARBCUkNACADIAE2AgggAyABNgIEIAJBeGogATYCACACQXRqIAE2AgAgBEEZSQ0AIAMgATYCGCADIAE2AhQgAyABNgIQIAMgATYCDCACQXBqIAE2AgAgAkFsaiABNgIAIAJBaGogATYCACACQWRqIAE2AgAgBCADQQRxQRhyIgRrIgJBIEkNACABrSIFQiCGIAWEIQUgAyAEaiEBA0AgASAFNwMYIAEgBTcDECABIAU3AwggASAFNwMAIAFBIGohASACQWBqIgJBH0sNAAsLIAALoAIBBH8jAEFAaiICJAAgACgCACIDQXxqKAIAIQQgA0F4aigCACEFIAJBADYCFCACQfgnNgIQIAIgADYCDCACIAE2AghBACEDIAJBGGpBAEEnEDIaIAAgBWohAAJAIAQgAUEAECMEQCACQQE2AjggBCACQQhqIAAgAEEBQQAgBCgCACgCFBEJACAAQQAgAigCIEEBRhshAwwBCyAEIAJBCGogAEEBQQAgBCgCACgCGBEIAAJAAkAgAigCLA4CAAECCyACKAIcQQAgAigCKEEBRhtBACACKAIkQQFGG0EAIAIoAjBBAUYbIQMMAQsgAigCIEEBR0EAIAIoAjAgAigCJEEBR3IgAigCKEEBR3IbDQAgAigCGCEDCyACQUBrJAAgAwsaACAAKQMYIAApAxAgACkDCCAAKQMAhISEUAs2AQF/IwBBEGsiAiAANgIMQQAhAANAIAAgAUZFBEAgAigCDCAAakEAOgAAIABBAWohAAwBCwsLJgAgAEIANwMIIAAgAa03AwAgAEIANwMQIABCADcDGCAAQgA3AyALzAQCA38MfiMAQYABayEEIAApAzghECAAKQMwIQogACkDKCEGIAApAyAhCCAAKQMYIQsgACkDECEMIAApAwghDSAAKQMAIhEhDgNAIAohCSAGIQogBCAFQQN0IgNqIAEpAwAiBzcDACAHIANBgA9qKQMAIAgiBkIyiSAGQi6JhSAGQheJhSAQfCAJIAZCf4WDIAYgCoOEfHx8IgggDiIHQiSJIAdCHomFIAdCGYmFIAcgDCIPIA0iDIWDIAwgD4OFfHwhDiAIIAt8IQggAUEIaiEBQRAhAyAHIQ0gDyELIAkhECAFQQFqIgVBEEcNAAsDQCAKIQ0gBiEKIAQgA0EPcUEDdGoiASABKQMAIAQgA0EJakEPcUEDdGopAwAgBCADQQFqIgFBD3FBA3RqKQMAIgZCOIkgBkIHiIUgBkI/iYV8fCAEIANBDmpBD3FBA3RqKQMAIgZCA4kgBkIGiIUgBkItiYV8IgY3AwAgBiADQQN0QYAPaikDACAIIgZCMokgBkIuiYUgBkIXiYUgCXwgDSAGQn+FgyAGIAqDhHx8fCIIIA4iC0IkiSALQh6JhSALQhmJhSALIAwiCSAHIgyFgyAHIAmDhXx8IQ4gCCAPfCEIIAshByAJIQ8gDSEJIAEiA0HQAEcNAAsgAiAOIBF8NwMAIAIgACkDCCAHfDcDCCACIAApAxAgDHw3AxAgAiAAKQMYIA98NwMYIAIgACkDICAIfDcDICACIAApAyggBnw3AyggAiAAKQMwIAp8NwMwIAIgACkDOCAJfDcDOAssACAAIAAoAgAgAyAEaiAFamogBhCEASACajYCACABIAEoAgBBChCEATYCAAuvBQECfyMAQcADayIEJAACQCABKAJ4BEAgACACEEsMAQsgAigCUARAIAMEQCADQQEQNgsgACABQYABEB8aDAELIABBADYCeCAEQZgDaiABQdAAaiIFEBYgBCABKQMgNwOQAyAEIAEpAxg3A4gDIAQgASkDEDcDgAMgBCABKQMINwP4AiAEIAEpAwA3A/ACIARB8AJqEC8gBEHIAmogAiAEQZgDahAZIAQgASkDSDcDwAIgBCABQUBrKQMANwO4AiAEIAEpAzg3A7ACIAQgASkDMDcDqAIgBCABKQMoNwOgAiAEQaACahAvIARB+AFqIAJBKGogBEGYA2oQGSAEQfgBaiAEQfgBaiAFEBkgBEHQAWogBEHwAmpBARAiIARB0AFqIARByAJqECEgBEGoAWogBEGgAmpBARAiIARBqAFqIARB+AFqECEgBEHQAWoQVARAIARBqAFqEFQEQCAAIAEgAxBVDAILIAMEQCADQQAQNgsgAEEBNgJ4DAELIARBgAFqIARBqAFqEBYgBEHYAGogBEHQAWoQFiAEQTBqIARB0AFqIARB2ABqEBkgAwRAIAMgBCkD0AE3AwAgAyAEKQPwATcDICADIAQpA+gBNwMYIAMgBCkD4AE3AxAgAyAEKQPYATcDCAsgAEHQAGogBSAEQdABahAZIARBCGogBEHwAmogBEHYAGoQGSAAIAQpAyg3AyAgACAEKQMgNwMYIAAgBCkDGDcDECAAIAQpAxA3AwggACAEKQMINwMAIABBAhAuIAAgBEEwahAhIAAgAEEDECIgACAEQYABahAhIABBKGoiASAAQQUQIiABIARBCGoQISABIAEgBEGoAWoQGSAEQTBqIARBMGogBEGgAmoQGSAEQTBqIARBMGpBARAiIAEgBEEwahAhCyAEQcADaiQAC/ICACAAIAExAB88AAAgACABMwEePAABIAAgASkDGEIoiDwAAiAAIAE1Ahw8AAMgACABKQMYQhiIPAAEIAAgASkDGEIQiDwABSAAIAEpAxhCCIg8AAYgACABKQMYPAAHIAAgATEAFzwACCAAIAEzARY8AAkgACABKQMQQiiIPAAKIAAgATUCFDwACyAAIAEpAxBCGIg8AAwgACABKQMQQhCIPAANIAAgASkDEEIIiDwADiAAIAEpAxA8AA8gACABMQAPPAAQIAAgATMBDjwAESAAIAEpAwhCKIg8ABIgACABNQIM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ASgCACEBA0AgASIEKAIEQXhxIABGDQIgAkEddiEBIAJBAXQhAiAEIAFBBHFqIgdBEGooAgAiAQ0ACyAHIAM2AhAgAyAENgIYCyADIAM2AgwgAyADNgIIDAELIAQoAggiACADNgIMIAQgAzYCCCADQQA2AhggAyAENgIMIAMgADYCCAtBhL0EQYS9BCgCAEF/aiIANgIAIAANAEGswAQhAwNAIAMoAgAiAEEIaiEDIAANAAtBhL0EQX82AgALC20BAX8jAEGAAmsiBSQAIARBgMAEcSACIANMckUEQCAFIAFB/wFxIAIgA2siAkGAAiACQYACSSIBGxAyGiABRQRAA0AgACAFQYACEE4gAkGAfmoiAkH/AUsNAAsLIAAgBSACEE4LIAVBgAJqJAALMwEBfyAAQQEgABshAAJAA0AgABBYIgENAUHgvAQoAgAiAQRAIAERBQAMAQsLEAQACyABCwYAIAAQRAvZAQEDfyAAIAAoAmAiAyACajYCYAJAQcAAIANBP3EiBGsiBSACSw0AIABBIGoiAyAEaiABIAUQHxogACADEJUBIAEgBWohAUEAIQQgAiAFayICQcAASQ0AA0AgAyABKQAANwAAIAMgASkAODcAOCADIAEpADA3ADAgAyABKQAoNwAoIAMgASkAIDcAICADIAEpABg3ABggAyABKQAQNwAQIAMgASkACDcACCAAIAMQlQEgAUFAayEBIAJBQGoiAkE/Sw0ACwsgAgRAIAAgBGpBIGogASACEB8aCwt/AQJ+IABCACACrCIDfSIEIAEpAwCDIANCf3wiAyAAKQMAg4Q3AwAgACABKQMIIASDIAApAwggA4OENwMIIAAgASkDECAEgyAAKQMQIAODhDcDECAAIAEpAxggBIMgACkDGCADg4Q3AxggACABKQMgIASDIAApAyAgA4OENwMgC4sDAQV+IAAgATEAHyABMQAeQgiGhCABMQAdQhCGhCABMQAcQhiGhCABMQAbQiCGhCABMQAaQiiGhCABMQAZQg+DQjCGhCICNwMAIAAgAS0AGUEEdq0gATEAGEIEhoQgATEAF0IMhoQgATEAFkIUhoQgATEAFUIchoQgATEAFEIkhoQgATEAE0IshoQiAzcDCCAAIAExABIgATEAEUIIhoQgATEAEEIQhoQgATEAD0IYhoQgATEADkIghoQgATEADUIohoQgATEADEIPg0IwhoQiBDcDECAAIAEtAAxBBHatIAExAAtCBIaEIAExAApCDIaEIAExAAlCFIaEIAExAAhCHIaEIAExAAdCJIaEIAExAAZCLIaEIgU3AxggACABMQAFIAExAARCCIaEIAExAANCEIaEIAExAAJCGIaEIAExAAFCIIaEIAExAABCKIaEIgY3AyACfyAGQv///////z9SIAJCr/j//+///wdUckUEQEEAIAMgBIMgBYNC/////////wdRDQEaC0EBCwuAAQAgACABKAJQNgJ4IAAgASkDADcDACAAIAEpAwg3AwggACABKQMQNwMQIAAgASkDGDcDGCAAIAEpAyA3AyAgACABKQMoNwMoIAAgASkDMDcDMCAAIAEpAzg3AzggAEFAayABQUBrKQMANwMAIAAgASkDSDcDSCAAQdAAakEBEDYLxQEBA38gASACaiEEAkAgACgCYEE/cSIDRQ0AIAIgA2pBwABJBEAgAyEFDAELIABBIGoiAiADaiABQcAAIANrIgMQHxogACAAKQNgIAOtfDcDYCAAIAJBARCcASABIANqIQELAn8gBCABayICQcAATgRAIAAgASACQQZ2EJwBIAAgACkDYCACQUBxIgKtfDcDYCABIAJqIQELIAQgAUsLBEAgACAFakEgaiABIAQgAWsiARAfGiAAIAApA2AgAax8NwNgCyAACwcAIABBAEcLFwAgAC0AAEEgcUUEQCABIAIgABCYAgsLpQECAn8BfiABBEAgABDGAQNAIAJBCEYEQCABIABBwAAQHxoFIAAgAkEDdGoiAyADKQMAIgRCOIYgBEIohkKAgICAgIDA/wCDhCAEQhiGQoCAgICA4D+DIARCCIZCgICAgPAfg4SEIARCCIhCgICA+A+DIARCGIhCgID8B4OEIARCKIhCgP4DgyAEQjiIhISENwMAIAJBAWohAgwBCwsLIABB0AEQNQsJACAAIAE2AAALDwAgABA/KAIAIAAoAgBrCxAAIAAoAgAgASgCAEZBAXMLCgAgACgCBBCMAQvPAQEFfiAAKQMAIAApAyAiA0IwiELRh4CAEH58IgJC/////////weDIgFC0IeAgBCFIQQCfyABUEUEQEEAIARC/////////wdSDQEaCyABIAApAwggAkI0iHwiAUL/////////B4OEIAApAxAgAUI0iHwiAkL/////////B4OEIAApAxggAkI0iHwiBUL/////////B4OEIANC////////P4MgBUI0iHwiA4RQIAEgBIMgAoMgBYMgA0KAgICAgIDAB4WDQv////////8HUXILC2sAAkAgASgCeARAIABBATYCeCACRQ0BIAJBARA2DwsgAgRAIAIgASkDKDcDACACIAEpA0g3AyAgAiABQUBrKQMANwMYIAIgASkDODcDECACIAEpAzA3AwggAhAvIAJBAhAuCyAAIAEQ7wELC8UCAQd+IAApAwggACkDACAAKQMgIgRCMIhC0YeAgBB+fCIBQjSIfCICQv////////8HgyEFIAApAxggACkDECACQjSIfCIHQjSIfCIDQv////////8HgyEGIAAgBEL///////8/gyADQjSIfCIEQjCIIAIgB0L/////////B4MiAoMgA4NC/////////wdRIARC////////P1FxIAFC/////////weDIgNCrvj//+///wdWca2EUAR+IAQFIANC0YeAgBB8IgFC/////////weDIQMgBSABQjSIfCIBQv////////8HgyEFIAIgAUI0iHwiAUL/////////B4MhAiAGIAFCNIh8IgFC/////////weDIQYgAUI0iCAEfEL///////8/gws3AyAgACAGNwMYIAAgAjcDECAAIAU3AwggACADNwMACx0AIAAgARCdASAAQShqIAFBIGoQnQEgAEEANgJQC4suAQx/IwBBEGsiDCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB9AFNBEBB5LwEKAIAIgVBECAAQQtqQXhxIABBC0kbIgZBA3YiAHYiAUEDcQRAIAFBf3NBAXEgAGoiAkEDdCIDQZS9BGooAgAiAUEIaiEAAkAgASgCCCIGIANBjL0EaiIDRgRAQeS8BCAFQX4gAndxNgIADAELIAYgAzYCDCADIAY2AggLIAEgAkEDdCICQQNyNgIEIAEgAmoiASABKAIEQQFyNgIEDA0LIAZB7LwEKAIAIghNDQEgAQRAAkBBAiAAdCICQQAgAmtyIAEgAHRxIgBBACAAa3FBf2oiACAAQQx2QRBxIgB2IgFBBXZBCHEiAiAAciABIAJ2IgBBAnZBBHEiAXIgACABdiIAQQF2QQJxIgFyIAAgAXYiAEEBdkEBcSIBciAAIAF2aiIC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cjYCBCALIANBAXI2AgQgAyALaiADNgIAIAgEQCAIQQN2IgZBA3RBjL0EaiEAQfi8BCgCACECAn9BASAGdCIGIAVxRQRAQeS8BCAFIAZyNgIAIAAMAQsgACgCCAshBiAAIAI2AgggBiACNgIMIAIgADYCDCACIAY2AggLQfi8BCALNgIAQey8BCADNgIACyABQQhqIQALIAxBEGokACAACwoAIABBUGpBCkkLSwAgAEIANwNgIABCq7OP/JGjs/DbADcCGCAAQv+kuYjFkdqCm383AhAgAELy5rvjo6f9p6V/NwIIIABC58yn0NbQ67O7fzcCACAACyoAIAAEQCAAQcAOQcAAEB8iAEHQAGpBgAEQNSAAQgA3A0ggAEIANwNACwskACAAQQh0QYCA/AdxIABBGHRyIABBCHZBgP4DcSAAQRh2cnILGgEBfyAAKAIAIQEgACAAKAIAQQFqNgIAIAELLAEBfyMAQRBrIgEkACABIAAoAgQ2AgggAUEIahBrKAIAIQAgAUEQaiQAIAALsQECAX8BfiMAQRBrIgIkACACIAApA2BCA4YiA6cQXK1CIIYgA0IgiKcQXK2ENwAIIAEgAEGACEE3IAAoAmBrQT9xQQFqEEwgAkEIakEIEEwiACgCABA9IAFBBGogACgCBBA9IAFBCGogACgCCBA9IAFBDGogACgCDBA9IAFBEGogACgCEBA9IAFBFGogACgCFBA9IAFBGGogACgCGBA9IAFBHGogACgCHBA9IAJBEGokAAtXACAAIAEpAwAgASkDCEI0hoQ3AwAgACABKQMQQiiGIAEpAwhCDIiENwMIIAAgASkDGEIchiABKQMQQhiIhDcDECAAIAEpAyBCEIYgASkDGEIkiIQ3AxgLTQEBfyMAQdAAayIDJAAgA0EoaiACEBYgAyADQShqIAIQGSAAIAEgA0EoahAZIABBKGogAUEoaiADEBkgACABKAJ4NgJQIANB0ABqJAALkAEBBX4gACkDCCAAKQMAIAApAyAiAUIwiELRh4CAEH58IgJCNIh8IgMgAoQgACkDECADQjSIfCIEhCAAKQMYIARCNIh8IgWEQv////////8HgyABQv///////z+DIAVCNIh8IgGEUCADIAJC0IeAgBCFgyAEgyAFgyABQoCAgICAgMAHhYNC/////////wdRcgsmAEJ/IAKthkJ/hSAAIAFBA3ZB+P///wFxaikDACABQT9xrYiDpwunAgEFfiAAIAApAxggACkDECAAKQMIIAApAwAgACkDICIDQjCIQtGHgIAQfnwiAkI0iHwiAUI0iHwiBEI0iHwiBUI0iCADQv///////z+DfCIDQjCIIARC/////////weDIgQgAYMgBYNC/////////wdRIANC////////P1FxIAJC/////////weDIgJCrvj//+///wdWca2EQtGHgIAQfiACfCICQv////////8HgzcDACAAIAFC/////////weDIAJCNIh8IgFC/////////weDNwMIIAAgAUI0iCAEfCIBQv////////8HgzcDECAAIAVC/////////weDIAFCNIh8IgFC/////////weDNwMYIAAgAUI0iCADfEL///////8/gzcDIAseACAAIAEoAgBqIAIgAxAfGiABIAEoAgAgA2o2AgALngEBBX4gACABKQMAQn+FIgJCwoLZgc3Rl+m/f3wiA0IAQn8gARA0GyIEgzcDACAAIAEpAwhCf4UiBSADIAJUrXwiAkK7wKL66py317p/fCIDIASDNwMIIAAgASkDEEJ/hSIGIAIgBVStIAMgAlStfHwiAkJ+fCIDIASDNwMQIAAgAiAGVK0gAyACVK18IAEpAxhCf4V8Qn98IASDNwMYCwgAIACnQQFxC2oBAX8jAEFAaiICJAAgAiABEHcgACACKQM4NwA4IAAgAikDMDcAMCAAIAIpAyg3ACggACACKQMgNwAgIAAgAikDGDcAGCAAIAIpAxA3ABAgACACKQMINwAIIAAgAikDADcAACACQUBrJAALRgECfyAAKAIEIgVBCHUhBiAAKAIAIgAgASACKAIAIAZqKAIAIAYgBUEBcRsgAmogA0ECIAVBAnEbIAQgACgCACgCGBEIAAu8AQEDfwJ/IAEgACgCWEE/cSIERQ0AGiACIARqQcAASQRAIAQhBSABDAELIABBFGoiAyAEaiABQcAAIARrIgQQHxogACAAKQNYIAStfDcDWCAAIAMQigEgASAEagshAyABIAJqIQIDQCACIANBQGsiAUlFBEAgACADEIoBIAAgACkDWEJAfTcDWCABIQMMAQsLIAIgA0sEQCAAIAVqQRRqIAMgAiADayIBEB8aIAAgACkDWCABrHw3A1gLIAALEQAgACAAKAIAQX9qNgIAIAALCgAgACgCABCMAQsfACAAQgA3AwggACABrTcDACAAQgA3AxAgAEIANwMYC8kBAQN/IwBB0ABrIgIkACAAIAEoAng2AlAgAUHQAGoiAyADEKEBIAJBKGogAxAWIAIgAyACQShqEBkgASABIAJBKGoQGSABQShqIgQgBCACEBkgA0EBEDYgACABKQMgNwMgIAAgASkDGDcDGCAAIAEpAxA3AxAgACABKQMINwMIIAAgASkDADcDACAAIAEpAyg3AyggACABKQMwNwMwIAAgASkDODcDOCAAQUBrIAFBQGspAwA3AwAgACABKQNINwNIIAJB0ABqJAALuwQBA38jAEHAAWsiAyQAIANCADcDMCADQgA3AzggA0FAa0IANwMAIANCADcDSCADQgA3A1AgA0IANwNYIANCADcDYCADQgA3AyggASAAQShqQYABEB8hBSADQQhqIAIgAEEIahCjASADQQA2ArgBA0AgA0EoaiAEQQp0IgEgACgCAGogA0EIaiAEQQJ0QQQQYyICRRAsIANBKGogACgCACABakFAayACQQFGECwgA0EoaiAAKAIAIAFqQYABaiACQQJGECwgA0EoaiAAKAIAIAFqQcABaiACQQNGECwgA0EoaiAAKAIAIAFqQYACaiACQQRGECwgA0EoaiAAKAIAIAFqQcACaiACQQVGECwgA0EoaiAAKAIAIAFqQYADaiACQQZGECwgA0EoaiAAKAIAIAFqQcADaiACQQdGECwgA0EoaiAAKAIAIAFqQYAEaiACQQhGECwgA0EoaiAAKAIAIAFqQcAEaiACQQlGECwgA0EoaiAAKAIAIAFqQYAFaiACQQpGECwgA0EoaiAAKAIAIAFqQcAFaiACQQtGECwgA0EoaiAAKAIAIAFqQYAGaiACQQxGECwgA0EoaiAAKAIAIAFqQcAGaiACQQ1GECwgA0EoaiAAKAIAIAFqQYAHaiACQQ5GECwgA0EoaiAAKAIAIAFqQcAHaiACQQ9GECwgA0HoAGogA0EoahBXIAUgBSADQegAahD+ASAEQQFqIgRBwABHDQALIANB6ABqEHggA0EIahBCIANBwAFqJAALuQEBAn8jAEHQAWsiAiQAIAAoAkAEQCACQQhqIABBIGoiAxBBIAJBCGogAEEgEDAgAkEIakHAtARBARAwIAJBCGogAxBAIAJBCGogAxBBIAJBCGogAEEgEDAgAkEIaiAAEEALIAJBCGogAEEgahBBIAJBCGogAEEgEDAgAkEIaiAAEEAgASAAKQAYNwAYIAEgACkAEDcAECABIAApAAg3AAggASAAKQAANwAAIABBATYCQCACQdABaiQAC1ABAX8jAEGgGGsiBSQAIAUgBUEQajYCDCAFIAVBoAhqNgIIIAUgBUHgDWo2AgQgBSAFQaAQajYCACAAIAUgASACIAMgBBDoASAFQaAYaiQAC1IAIAAgAikAADcAACAAIAIpABg3ABggACACKQAQNwAQIAAgAikACDcACCABIAIpADg3ABggASACKQAwNwAQIAEgAikAKDcACCABIAIpACA3AAALhQEBBX4gACAAKQMAIgQgAa0iAkK//ab+sq7olsAAfnwiBTcDACAAIAApAwgiBiACQsS/3YWV48ioxQB+fCIDIAUgBFStfCIENwMIIAAgACkDECIFIAJ8IgIgAyAGVK0gBCADVK18fCIDNwMQIAAgACkDGCACIAVUrSADIAJUrXx8NwMYIAELZAICfwJ+IAApAxhCf1IgACkDECIDQn5UciIBIAApAwgiBEK7wKL66py317p/VHJBf3MiAiAEQrvAovrqnLfXun9WcSABQX9zIANCf1FxciAAKQMAQsCC2YHN0Zfpv39WIAJxcguiAwAgACABKQMgQiiIPAAAIAAgATUCJDwAASAAIAEpAyBCGIg8AAIgACABKQMgQhCIPAADIAAgASkDIEIIiDwABCAAIAEpAyA8AAUgACABKQMYQiyIPAAGIAAgASkDGEIkiDwAByAAIAEpAxhCHIg8AAggACABKQMYQhSIPAAJIAAgASkDGEIMiDwACiAAIAEpAxhCBIg8AAsgACABMwEWQg+DIAEpAxhCBIaEPAAMIAAgASkDEEIoiDwADSAAIAE1AhQ8AA4gACABKQMQQhiIPAAPIAAgASkDEEIQiDwAECAAIAEpAxBCCIg8ABEgACABKQMQPAASIAAgASkDCEIsiDwAEyAAIAEpAwhCJIg8ABQgACABKQMIQhyIPAAVIAAgASkDCEIUiDwAFiAAIAEpAwhCDIg8ABcgACABKQMIQgSIPAAYIAAgATMBBkIPgyABKQMIQgSGhDwAGSAAIAEpAwBCKIg8ABogACABNQIEPAAbIAAgASkDAEIYiDwAHCAAIAEpAwBCEIg8AB0gACABKQMAQgiIPAAeIAAgASkDADwAHwuOAQEBfyMAQUBqIgMkACADIAIpADg3AzggAyACKQAwNwMwIAMgAikAKDcDKCADIAIpACA3AyAgAyACKQAYNwMYIAMgAikAEDcDECADIAIpAAg3AwggAyACKQAANwMAIAEgAxBXQQEhAiABEK0BBEAgACgCsAEgACgCtAFBsbMEEB5BACECCyADQUBrJAAgAgudAQEBfyMAQdAAayICJAAgAiABKQMINwMwIAIgASkDEDcDOCACQUBrIAEpAxg3AwAgAiABKQMgNwNIIAIgASkDADcDKCACQShqEGQgAiABKQNINwMgIAIgAUFAaykDADcDGCACIAEpAzg3AxAgAiABKQMwNwMIIAIgASkDKDcDACACEGQgACACQShqEGAgAEEgaiACEGAgAkHQAGokAAsUACAAQQA2AlAgABA7IABBKGoQOwuQAQEDfyAAIQECQAJAIABBA3FFDQAgAC0AAEUEQEEADwsDQCABQQFqIgFBA3FFDQEgAS0AAA0ACwwBCwNAIAEiAkEEaiEBIAIoAgAiA0F/cyADQf/9+3dqcUGAgYKEeHFFDQALIANB/wFxRQRAIAIgAGsPCwNAIAItAAEhAyACQQFqIgEhAiADDQALCyABIABrC0gBAn8gACgCBCIGQQh1IQcgACgCACIAIAEgAiADKAIAIAdqKAIAIAcgBkEBcRsgA2ogBEECIAZBAnEbIAUgACgCACgCFBEJAAseACAAKAIcQQFGIAAoAgQgAUdyRQRAIAAgAjYCHAsLoQEAIABBAToANQJAIAAoAgQgAkcNACAAQQE6ADQgACgCECICRQRAIABBATYCJCAAIAM2AhggACABNgIQIANBAUcgACgCMEEBR3INASAAQQE6ADYPCyABIAJGBEAgACgCGCICQQJGBEAgACADNgIYIAMhAgsgACgCMEEBRyACQQFHcg0BIABBAToANg8LIABBAToANiAAIAAoAiRBAWo2AiQLC10BAX8gACgCECIDRQRAIABBATYCJCAAIAI2AhggACABNgIQDwsCQCABIANGBEAgACgCGEECRw0BIAAgAjYCGA8LIABBAToANiAAQQI2AhggACAAKAIkQQFqNgIkCwsUACAAQeAmNgIAIABBBGoQsAIgAAsWACAARQRAQQAP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AiQgAiAAKAIMIhM2AiAgAiAAKAIQIhQ2AhwgAiADNgIYIAIgEjYCFCACIAQ2AhAgAiATNgIMIAIgFDYCCCABKAAEIQMgASgACCEEIAEoAAwhBSABKAAQIQYgASgAFCEHIAEoABghCCABKAAcIQkgASgAICEKIAEoACQhCyABKAAoIQwgASgALCENIAEoADAhDiABKAA0IQ8gASgAOCEQIAEoADwhESACQSxqIBIgAkEkaiATIBQgASgAACIBQQsQICACQRhqIAIoAhQgAkEQaiACKAIMIAIoAgggB0EIECsgAkEcaiACKAIsIAJBKGogAigCJCACKAIgIANBDhAgIAJBCGogAigCGCACQRRqIAIoAhAgAigCDCAQQQkQKyACQSBqIAIoAhwgAkEsaiACKAIoIAIoAiQgBEEPECAgAkEMaiACKAIIIAJBGGogAigCFCACKAIQIAlBCRArIAJBJGogAigCICACQRxqIAIoAiwgAigCKCAFQQwQICACQRBqIAIoAgwgAkEIaiACKAIYIAIoAhQgAUELECsgAkEoaiACKAIkIAJBIGogAigCHCACKAIsIAZBBRAgIAJBFGogAigCECACQQxqIAIoAgggAigCGCALQQ0QKyACQSxqIAIoAiggAkEkaiACKAIgIAIoAhwgB0EIECAgAkEYaiACKAIUIAJBEGogAigCDCACKAIIIARBDxArIAJBHGogAigCLCACQShqIAIoAiQgAigCICAIQQcQICACQQhqIAIoAhggAkEUaiACKAIQIAIoAgwgDUEPECsgAkEgaiACKAIcIAJBLGogAigCKCACKAIkIAlBCRAgIAJBDGogAigCCCACQRhqIAIoAhQgAigCECAGQQUQKyACQSRqIAIoAiAgAkEcaiACKAIsIAIoAiggCkELECAgAkEQaiACKAIMIAJBCGogAigCGCACKAIUIA9BBxArIAJBKGogAigCJCACQSBqIAIoAhwgAigCLCALQQ0QICACQRRqIAIoAhAgAkEMaiACKAIIIAIoAhggCEEHECsgAkEsaiACKAIoIAJBJGogAigCICACKAIcIAxBDhAgIAJBGGogAigCFCACQRBqIAIoAgwgAigCCCARQQgQKyACQRxqIAIoAiwgAkEoaiACKAIkIAIoAiAgDUEPECAgAkEIaiACKAIYIAJBFGogAigCECACKAIMIApBCxArIAJBIGogAigCHCACQSxqIAIoAiggAigCJCAOQQYQICACQQxqIAIoAgggAkEYaiACKAIUIAIoAhAgA0EOECsgAkEkaiACKAIgIAJBHGogAigCLCACKAIoIA9BBxAgIAJBEGogAigCDCACQQhqIAIoAhggAigCFCAMQQ4QKyACQShqIAIoAiQgAkEgaiACKAIcIAIoAiwgEEEJECAgAkEUaiACKAIQIAJBDGogAigCCCACKAIYIAVBDBArIAJBLGogAigCKCACQSRqIAIoAiAgAigCHCARQQgQICACQRhqIAIoAhQgAkEQaiACKAIMIAIoAgggDkEGECsgAkEcaiACKAIsIAJBKGogAigCJCACKAIgIAlBBxAqIAJBCGogAigCGCACQRRqIAIoAhAgAigCDCAIQQkQKSACQSBqIAIoAhwgAkEsaiACKAIoIAIoAiQgBkEGECogAkEMaiACKAIIIAJBGGogAigCFCACKAIQIA1BDRApIAJBJGogAigCICACQRxqIAIoAiwgAigCKCAPQQgQKiACQRBqIAIoAgwgAkEIaiACKAIYIAIoAhQgBUEPECkgAkEoaiACKAIkIAJBIGogAigCHCACKAIsIANBDRAqIAJBFGogAigCECACQQxqIAIoAgggAigCGCAJQQcQKSACQSxqIAIoAiggAkEkaiACKAIgIAIoAhwgDEELECogAkEYaiACKAIUIAJBEGogAigCDCACKAIIIAFBDBApIAJBHGogAigCLCACQShqIAIoAiQgAigCICAIQQkQKiACQQhqIAIoAhggAkEUaiACKAIQIAIoAgwgD0EIECkgAkEgaiACKAIcIAJBLGogAigCKCACKAIkIBFBBxAqIAJBDGogAigCCCACQRhqIAIoAhQgAigCECAHQQkQKSACQSRqIAIoAiAgAkEcaiACKAIsIAIoAiggBUEPECogAkEQaiACKAIMIAJBCGogAigCGCACKAIUIAxBCxApIAJBKGogAigCJCACQSBqIAIoAhwgAigCLCAOQQcQKiACQRRqIAIoAhAgAkEMaiACKAIIIAIoAhggEEEHECkgAkEsaiACKAIoIAJBJGogAigCICACKAIcIAFBDBAqIAJBGGogAigCFCACQRBqIAIoAgwgAigCCCARQQcQKSACQRxqIAIoAiwgAkEoaiACKAIkIAIoAiAgC0EPECogAkEIaiACKAIYIAJBFGogAigCECACKAIMIApBDBApIAJBIGogAigCHCACQSxqIAIoAiggAigCJCAHQQkQKiACQQxqIAIoAgggAkEYaiACKAIUIAIoAhAgDkEHECkgAkEkaiACKAIgIAJBHGogAigCLCACKAIoIARBCxAqIAJBEGogAigCDCACQQhqIAIoAhggAigCFCAGQQYQKSACQShqIAIoAiQgAkEgaiACKAIcIAIoAiwgEEEHECogAkEUaiACKAIQIAJBDGogAigCCCACKAIYIAtBDxApIAJBLGogAigCKCACQSRqIAIoAiAgAigCHCANQQ0QKiACQRhqIAIoAhQgAkEQaiACKAIMIAIoAgggA0ENECkgAkEcaiACKAIsIAJBKGogAigCJCACKAIgIApBDBAqIAJBCGogAigCGCACQRRqIAIoAhAgAigCDCAEQQsQKSACQSBqIAIoAhwgAkEsaiACKAIoIAIoAiQgBUELECggAkEMaiACKAIIIAJBGGogAigCFCACKAIQIBFBCRAnIAJBJGogAigCICACQRxqIAIoAiwgAigCKCAMQQ0QKCACQRBqIAIoAgwgAkEIaiACKAIYIAIoAhQgB0EHECcgAkEoaiACKAIkIAJBIGogAigCHCACKAIsIBBBBhAoIAJBFGogAigCECACQQxqIAIoAgggAigCGCADQQ8QJyACQSxqIAIoAiggAkEkaiACKAIgIAIoAhwgBkEHECggAkEYaiACKAIUIAJBEGogAigCDCACKAIIIAVBCxAnIAJBHGogAigCLCACQShqIAIoAiQgAigCICALQQ4QKCACQQhqIAIoAhggAkEUaiACKAIQIAIoAgwgCUEIECcgAkEgaiACKAIcIAJBLGogAigCKCACKAIkIBFBCRAoIAJBDGogAigCCCACQRhqIAIoAhQgAigCECAQQQYQJyACQSRqIAIoAiAgAkEcaiACKAIsIAIoAiggCkENECggAkEQaiACKAIMIAJBCGogAigCGCACKAIUIAhBBhAnIAJBKGogAigCJCACQSBqIAIoAhwgAigCLCADQQ8QKCACQRRqIAIoAhAgAkEMaiACKAIIIAIoAhggC0EOECcgAkEsaiACKAIoIAJBJGogAigCICACKAIcIARBDhAoIAJBGGogAigCFCACQRBqIAIoAgwgAigCCCANQQwQJyACQRxqIAIoAiwgAkEoaiACKAIkIAIoAiAgCUEIECggAkEIaiACKAIYIAJBFGogAigCECACKAIMIApBDRAnIAJBIGogAigCHCACQSxqIAIoAiggAigCJCABQQ0QKCACQQxqIAIoAgggAkEYaiACKAIUIAIoAhAgDkEFECcgAkEkaiACKAIgIAJBHGogAigCLCACKAIoIAhBBhAoIAJBEGogAigCDCACQQhqIAIoAhggAigCFCAEQQ4QJyACQShqIAIoAiQgAkEgaiACKAIcIAIoAiwgD0EFECggAkEUaiACKAIQIAJBDGogAigCCCACKAIYIAxBDRAnIAJBLGogAigCKCACQSRqIAIoAiAgAigCHCANQQwQKCACQRhqIAIoAhQgAkEQaiACKAIMIAIoAgggAUENECcgAkEcaiACKAIsIAJBKGogAigCJCACKAIgIAdBBxAoIAJBCGogAigCGCACQRRqIAIoAhAgAigCDCAGQQcQJyACQSBqIAIoAhwgAkEsaiACKAIoIAIoAiQgDkEFECggAkEMaiACKAIIIAJBGGogAigCFCACKAIQIA9BBRAnIAJBJGogAigCICACQRxqIAIoAiwgAigCKCADQQsQJiACQRBqIAIoAgwgAkEIaiACKAIYIAIoAhQgCkEPECUgAkEoaiACKAIkIAJBIGogAigCHCACKAIsIAtBDBAmIAJBFGogAigCECACQQxqIAIoAgggAigCGCAIQQUQJSACQSxqIAIoAiggAkEkaiACKAIgIAIoAhwgDUEOECYgAkEYaiACKAIUIAJBEGogAigCDCACKAIIIAZBCBAlIAJBHGogAigCLCACQShqIAIoAiQgAigCICAMQQ8QJiACQQhqIAIoAhggAkEUaiACKAIQIAIoAgwgA0ELECUgAkEgaiACKAIcIAJBLGogAigCKCACKAIkIAFBDhAmIAJBDGogAigCCCACQRhqIAIoAhQgAigCECAFQQ4QJSACQSRqIAIoAiAgAkEcaiACKAIsIAIoAiggCkEPECYgAkEQaiACKAIMIAJBCGogAigCGCACKAIUIA1BDhAlIAJBKGogAigCJCACQSBqIAIoAhwgAigCLCAOQQkQJiACQRRqIAIoAhAgAkEMaiACKAIIIAIoAhggEUEGECUgAkEsaiACKAIoIAJBJGogAigCICACKAIcIAZBCBAmIAJBGGogAigCFCACQRBqIAIoAgwgAigCCCABQQ4QJSACQRxqIAIoAiwgAkEoaiACKAIkIAIoAiAgD0EJECYgAkEIaiACKAIYIAJBFGogAigCECACKAIMIAdBBhAlIAJBIGogAigCHCACQSxqIAIoAiggAigCJCAFQQ4QJiACQQxqIAIoAgggAkEYaiACKAIUIAIoAhAgDkEJECUgAkEkaiACKAIgIAJBHGogAigCLCACKAIoIAlBBRAmIAJBEGogAigCDCACQQhqIAIoAhggAigCFCAEQQwQJSACQShqIAIoAiQgAkEgaiACKAIcIAIoAiwgEUEGECYgAkEUaiACKAIQIAJBDGogAigCCCACKAIYIA9BCRAlIAJBLGogAigCKCACQSRqIAIoAiAgAigCHCAQQQgQJiACQRhqIAIoAhQgAkEQaiACKAIMIAIoAgggC0EMECUgAkEcaiACKAIsIAJBKGogAigCJCACKAIgIAdBBhAmIAJBCGogAigCGCACQRRqIAIoAhAgAigCDCAJQQUQJSACQSBqIAIoAhwgAkEsaiACKAIoIAIoAiQgCEEFECYgAkEMaiACKAIIIAJBGGogAigCFCACKAIQIAxBDxAlIAJBJGogAigCICACQRxqIAIoAiwgAigCKCAEQQwQJiACQRBqIAIoAgwgAkEIaiACKAIYIAIoAhQgEEEIECUgAkEoaiACKAIkIAJBIGogAigCHCACKAIsIAZBCRAkIAJBFGogAigCECACQQxqIAIoAgggAigCGCAOQQgQICACQSxqIAIoAiggAkEkaiACKAIgIAIoAhwgAUEPECQgAkEYaiACKAIUIAJBEGogAigCDCACKAIIIBFBBRAgIAJBHGogAigCLCACQShqIAIoAiQgAigCICAHQQUQJCACQQhqIAIoAhggAkEUaiACKAIQIAIoAgwgDEEMECAgAkEgaiACKAIcIAJBLGogAigCKCACKAIkIAtBCxAkIAJBDGogAigCCCACQRhqIAIoAhQgAigCECAGQQkQICACQSRqIAIoAiAgAkEcaiACKAIsIAIoAiggCUEGECQgAkEQaiACKAIMIAJBCGogAigCGCACKAIUIANBDBAgIAJBKGogAigCJCACQSBqIAIoAhwgAigCLCAOQQgQJCACQRRqIAIoAhAgAkEMaiACKAIIIAIoAhggB0EFECAgAkEsaiACKAIoIAJBJGogAigCICACKAIcIARBDRAkIAJBGGogAigCFCACQRBqIAIoAgwgAigCCCAKQQ4QICACQRxqIAIoAiwgAkEoaiACKAIkIAIoAiAgDEEMECQgAkEIaiACKAIYIAJBFGogAigCECACKAIMIAlBBhAgIAJBIGogAigCHCACQSxqIAIoAiggAigCJCAQQQUQJCACQQxqIAIoAgggAkEYaiACKAIUIAIoAhAgCEEIECAgAkEkaiACKAIgIAJBHGogAigCLCACKAIoIANBDBAkIAJBEGogAigCDCACQQhqIAIoAhggAigCFCAEQQ0QICACQShqIAIoAiQgAkEgaiACKAIcIAIoAiwgBUENECQgAkEUaiACKAIQIAJBDGogAigCCCACKAIYIA9BBhAgIAJBLGogAigCKCACQSRqIAIoAiAgAigCHCAKQQ4QJCACQRhqIAIoAhQgAkEQaiACKAIMIAIoAgggEEEFECAgAkEcaiACKAIsIAJBKGogAigCJCACKAIgIA1BCxAkIAJBCGogAigCGCACQRRqIAIoAhAgAigCDCABQQ8QICACQSBqIAIoAhwgAkEsaiACKAIoIAIoAiQgCEEIECQgAkEMaiACKAIIIAJBGGogAigCFCACKAIQIAVBDRAgIAJBJGogAigCICACQRxqIAIoAiwgAigCKCARQQUQJCACQRBqIAIoAgwgAkEIaiACKAIYIAIoAhQgC0ELECAgAkEoaiACKAIkIAJBIGogAigCHCACKAIsIA9BBhAkIAJBFGogAigCECACQQxqIAIoAgggAigCGCANQQsQICAAKAIAIQEgACACKAIMIAIoAiQgACgCBGpqNgIAIAAgAigCCCACKAIgIAAoAghqajYCBCAAIAIoAhggAigCHCAAKAIMamo2AgggACACKAIUIAIoAiwgACgCEGpqNgIMIAAgAigCECABIAIoAihqajYCECACQTBqJAALOAEDf0EIEA0iAiIDIgFBtCY2AgAgAUHgJjYCACABQQRqIAAQvQIgA0GQJzYCACACQbAnQQ4QDAALJQEBfyMAQRBrIgEkACABQRBqJAAgAUEIaiIBIAA2AgAgASgCAAsQACAAIAE2AgQgACABNgIACzUBAX8gABBRGiAAEFEaIAAoAgAEQCAAIAAoAgAQ0wEgABA/GiAAKAIAIQEg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hZXjyKjFABAYIAAgCCACKQMAIgh8IgMgAikDGCAEIAZUrXx8IgQ3AwggACAFIAl8IgYgBCADVK0gAikDCCADIAhUrXx8fCIDNwMQIAAgBiAFVK0gAyAGVK18IgUgB3wiAzcDGCAAIAAQdCADIAVUahBzGiACQeABaiQACzMBAX8jAEEwayICJAAgAkEIaiAAQQEQIiACQQhqIAEQISACQQhqEFQhACACQTBqJAAgAAsUAQF/QQQQRiIBIAAoAgA2AgAgAQu+IQERfyMAQSBrIgMkAANAIAIEQCADIAAoAgAiCDYCHCADIAAoAgQiCTYCGCADIAAoAggiBzYCFCADIAAoAgw2AhAgAyAAKAIQIgY2AgwgAyAAKAIUIgQ2AgggAyAAKAIYIgU2AgQgAyAAKAIcNgIAIAggCSAHIANBEGogBiAEIAUgAyABEC0iB0GY36iUBGoQGiADKAIAIAMoAhwgAygCGCADQRRqIAMoAhAgAygCDCADKAIIIANBBGogAUEEahAtIgZBkYndiQdqEBogAygCBCADKAIAIAMoAhwgA0EYaiADKAIUIAMoAhAgAygCDCADQQhqIAFBCGoQLSIEQc/3g657ahAaIAMoAgggAygCBCADKAIAIANBHGogAygCGCADKAIUIAMoAhAgA0EMaiABQQxqEC0iBUGlt9fNfmoQGiADKAIMIAMoAgggAygCBCADIAMoAhwgAygCGCADKAIUIANBEGogAUEQahAtIgpB24TbygNqEBogAygCECADKAIMIAMoAgggA0EEaiADKAIAIAMoAhwgAygCGCADQRRqIAFBFGoQLSILQfGjxM8FahAaIAMoAhQgAygCECADKAIMIANBCGogAygCBCADKAIAIAMoAhwgA0EYaiABQRhqEC0iDEGkhf6ReWoQGiADKAIYIAMoAhQgAygCECADQQxqIAMoAgggAygCBCADKAIAIANBHGogAUEcahAtIg1B1b3x2HpqEBogAygCHCADKAIYIAMoAhQgA0EQaiADKAIMIAMoAgggAygCBCADIAFBIGoQLSITQZjVnsB9ahAaIAMoAgAgAygCHCADKAIYIANBFGogAygCECADKAIMIAMoAgggA0EEaiABQSRqEC0iDkGBto2UAWoQGiADKAIEIAMoAgAgAygCHCADQRhqIAMoAhQgAygCECADKAIMIANBCGogAUEoahAtIg9BvovGoQJqEBogAygCCCADKAIEIAMoAgAgA0EcaiADKAIYIAMoAhQgAygCECADQQxqIAFBLGoQLSIQQcP7sagFahAaIAMoAgwgAygCCCADKAIEIAMgAygCHCADKAIYIAMoAhQgA0EQaiABQTBqEC0iEUH0uvmVB2oQGiADKAIQIAMoAgwgAygCCCADQQRqIAMoAgAgAygCHCADKAIYIANBFGogAUE0ahAtIhJB/uP6hnhqEBogAygCFCADKAIQIAMoAgwgA0EIaiADKAIEIAMoAgAgAygCHCADQRhqIAFBOGoQLSIIQaeN8N55ahAaIAMoAhggAygCFCADKAIQIANBDGogAygCCCADKAIEIAMoAgAgA0EcaiABQTxqEC0iCUH04u+MfGoQGiADKAIcIAMoAhggAygCFCADQRBqIAMoAgwgAygCCCADKAIEIAMgCBAcIAcgDmpqIAYQG2oiB0HB0+2kfmoQGiADKAIAIAMoAhwgAygCGCADQRRqIAMoAhAgAygCDCADKAIIIANBBGogCRAcIAYgD2pqIAQQG2oiBkGGj/n9fmoQGiADKAIEIAMoAgAgAygCHCADQRhqIAMoAhQgAygCECADKAIMIANBCGogBxAcIAQgEGpqIAUQG2oiBEHGu4b+AGoQGiADKAIIIAMoAgQgAygCACADQRxqIAMoAhggAygCFCADKAIQIANBDGogBhAcIAUgEWpqIAoQG2oiBUHMw7KgAmoQGiADKAIMIAMoAgggAygCBCADIAMoAhwgAygCGCADKAIUIANBEGogBBAcIAogEmpqIAsQG2oiCkHv2KTvAmoQGiADKAIQIAMoAgwgAygCCCADQQRqIAMoAgAgAygCHCADKAIYIANBFGogBRAcIAggC2pqIAwQG2oiC0GqidLTBGoQGiADKAIUIAMoAhAgAygCDCADQQhqIAMoAgQgAygCACADKAIcIANBGGogChAcIAkgDGpqIA0QG2oiDEHc08LlBWoQGiADKAIYIAMoAhQgAygCECADQQxqIAMoAgggAygCBCADKAIAIANBHGogCxAcIAcgDWpqIBMQG2oiDUHakea3B2oQGiADKAIcIAMoAhggAygCFCADQRBqIAMoAgwgAygCCCADKAIEIAMgDBAcIAYgE2pqIA4QG2oiE0HSovnBeWoQGiADKAIAIAMoAhwgAygCGCADQRRqIAMoAhAgAygCDCADKAIIIANBBGogDRAcIAQgDmpqIA8QG2oiDkHtjMfBemoQGiADKAIEIAMoAgAgAygCHCADQRhqIAMoAhQgAygCECADKAIMIANBCGogExAcIAUgD2pqIBAQG2oiD0HIz4yAe2oQGiADKAIIIAMoAgQgAygCACADQRxqIAMoAhggAygCFCADKAIQIANBDGogDhAcIAogEGpqIBEQG2oiEEHH/+X6e2oQGiADKAIMIAMoAgggAygCBCADIAMoAhwgAygCGCADKAIUIANBEGogDxAcIAsgEWpqIBIQG2oiEUHzl4C3fGoQGiADKAIQIAMoAgwgAygCCCADQQRqIAMoAgAgAygCHCADKAIYIANBFGogEBAcIAwgEmpqIAgQG2oiEkHHop6tfWoQGiADKAIUIAMoAhAgAygCDCADQQhqIAMoAgQgAygCACADKAIcIANBGGogERAcIAggDWpqIAkQG2oiCEHRxqk2ahAaIAMoAhggAygCFCADKAIQIANBDGogAygCCCADKAIEIAMoAgAgA0EcaiASEBwgCSATamogBxAbaiIJQefSpKEBahAaIAMoAhwgAygCGCADKAIUIANBEGogAygCDCADKAIIIAMoAgQgAyAIEBwgByAOamogBhAbaiIHQYWV3L0CahAaIAMoAgAgAygCHCADKAIYIANBFGogAygCECADKAIMIAMoAgggA0EEaiAJEBwgBiAPamogBBAbaiIGQbjC7PACahAaIAMoAgQgAygCACADKAIcIANBGGogAygCFCADKAIQIAMoAgwgA0EIaiAHEBwgBCAQamogBRAbaiIEQfzbsekEahAaIAMoAgggAygCBCADKAIAIANBHGogAygCGCADKAIUIAMoAhAgA0EMaiAGEBwgBSARamogChAbaiIFQZOa4JkFahAaIAMoAgwgAygCCCADKAIEIAMgAygCHCADKAIYIAMoAhQgA0EQaiAEEBwgCiASamogCxAbaiIKQdTmqagGahAaIAMoAhAgAygCDCADKAIIIANBBGogAygCACADKAIcIAMoAhggA0EUaiAFEBwgCCALamogDBAbaiILQbuVqLMHahAaIAMoAhQgAygCECADKAIMIANBCGogAygCBCADKAIAIAMoAhwgA0EYaiAKEBwgCSAMamogDRAbaiIMQa6Si454ahAaIAMoAhggAygCFCADKAIQIANBDGogAygCCCADKAIEIAMoAgAgA0EcaiALEBwgByANamogExAbaiINQYXZyJN5ahAaIAMoAhwgAygCGCADKAIUIANBEGogAygCDCADKAIIIAMoAgQgAyAMEBwgBiATamogDhAbaiITQaHR/5V6ahAaIAMoAgAgAygCHCADKAIYIANBFGogAygCECADKAIMIAMoAgggA0EEaiANEBwgBCAOamogDxAbaiIOQcvM6cB6ahAaIAMoAgQgAygCACADKAIcIANBGGogAygCFCADKAIQIAMoAgwgA0EIaiATEBwgBSAPamogEBAbaiIPQfCWrpJ8ahAaIAMoAgggAygCBCADKAIAIANBHGogAygCGCADKAIUIAMoAhAgA0EMaiAOEBwgCiAQamogERAbaiIQQaOjsbt8ahAaIAMoAgwgAygCCCADKAIEIAMgAygCHCADKAIYIAMoAhQgA0EQaiAPEBwgCyARamogEhAbaiIRQZnQy4x9ahAaIAMoAhAgAygCDCADKAIIIANBBGogAygCACADKAIcIAMoAhggA0EUaiAQEBwgDCASamogCBAbaiISQaSM5LR9ahAaIAMoAhQgAygCECADKAIMIANBCGogAygCBCADKAIAIAMoAhwgA0EYaiAREBwgCCANamogCRAbaiIIQYXruKB/ahAaIAMoAhggAygCFCADKAIQIANBDGogAygCCCADKAIEIAMoAgAgA0EcaiASEBwgCSATamogBxAbaiIJQfDAqoMBahAaIAMoAhwgAygCGCADKAIUIANBEGogAygCDCADKAIIIAMoAgQgAyAIEBwgByAOamogBhAbaiIHQZaCk80BahAaIAMoAgAgAygCHCADKAIYIANBFGogAygCECADKAIMIAMoAgggA0EEaiAJEBwgBiAPamogBBAbaiIGQYjY3fEBahAaIAMoAgQgAygCACADKAIcIANBGGogAygCFCADKAIQIAMoAgwgA0EIaiAHEBwgBCAQamogBRAbaiIEQczuoboCahAaIAMoAgggAygCBCADKAIAIANBHGogAygCGCADKAIUIAMoAhAgA0EMaiAGEBwgBSARamogChAbaiIFQbX5wqUDahAaIAMoAgwgAygCCCADKAIEIAMgAygCHCADKAIYIAMoAhQgA0EQaiAEEBwgCiASamogCxAbaiIKQbOZ8MgDahAaIAMoAhAgAygCDCADKAIIIANBBGogAygCACADKAIcIAMoAhggA0EUaiAFEBwgCCALamogDBAbaiILQcrU4vYEahAaIAMoAhQgAygCECADKAIMIANBCGogAygCBCADKAIAIAMoAhwgA0EYaiAKEBwgCSAMamogDRAbaiIMQc+U89wFahAaIAMoAhggAygCFCADKAIQIANBDGogAygCCCADKAIEIAMoAgAgA0EcaiALEBwgByANamogExAbaiINQfPfucEGahAaIAMoAhwgAygCGCADKAIUIANBEGogAygCDCADKAIIIAMoAgQgAyAMEBwgBiATamogDhAbaiIGQe6FvqQHahAaIAMoAgAgAygCHCADKAIYIANBFGogAygCECADKAIMIAMoAgggA0EEaiANEBwgBCAOamogDxAbaiIEQe/GlcUHahAaIAMoAgQgAygCACADKAIcIANBGGogAygCFCADKAIQIAMoAgwgA0EIaiAGEBwgBSAPamogEBAbaiIFQZTwoaZ4ahAaIAMoAgggAygCBCADKAIAIANBHGogAygCGCADKAIUIAMoAhAgA0EMaiAEEBwgCiAQamogERAbaiIEQYiEnOZ4ahAaIAMoAgwgAygCCCADKAIEIAMgAygCHCADKAIYIAMoAhQgA0EQaiAFEBwgCyARamogEhAbaiIFQfr/+4V5ahAaIAMoAhAgAygCDCADKAIIIANBBGogAygCACADKAIcIAMoAhggA0EUaiAEEBwgDCASamogCBAbaiIEQevZwaJ6ahAaIAMoAhQgAygCECADKAIMIANBCGogAygCBCADKAIAIAMoAhwgA0EYaiAFEBwgCCANamogCRAbakH3x+b3e2oQGiADKAIYIAMoAhQgAygCECADQQxqIAMoAgggAygCBCADKAIAIANBHGogBBAcIAYgCWpqIAcQG2pB8vHFs3xqEBogACAAKAIAIAMoAhxqNgIAIAAgACgCBCADKAIYajYCBCAAIAAoAgggAygCFGo2AgggACAAKAIMIAMoAhBqNgIMIAAgACgCECADKAIMajYCECAAIAAoAhQgAygCCGo2AhQgACAAKAIYIAMoAgRqNgIYIAAgACgCHCADKAIAajYCHCABQUBrIQEgAkF/aiECDAELCyADQSBqJAALgwEAIAAgASkDAEL/////////B4M3AwAgACABKQMIQgyGQoDg//////8HgyABKQMAQjSIhDcDCCAAIAEpAxBCGIZCgICA+P///weDIAEpAwhCKIiENwMQIAAgASkDGEIkhkKAgICAgP7/B4MgASkDEEIciIQ3AxggACABKQMYQhCINwMgCwkAIAAgARChAQtcACAAIAMpAAA3AAAgACADKQAYNwAYIAAgAykAEDcAECAAIAMpAAg3AAggASADKQA4NwAYIAEgAykAMDcAECABIAMpACg3AAggASADKQAgNwAAIAIgAy0AQDYCAAtZACAAIAEpAAA3AAAgACABKQAYNwAYIAAgASkAEDcAECAAIAEpAAg3AAggACACKQAANwAgIAAgAikACDcAKCAAIAIpABA3ADAgACACKQAYNwA4IAAgAzoAQAuAFwECfyMAQeADayICJAAgAkG4A2ogARAWIAJBuANqIAJBuANqIAEQGSACQZADaiACQbgDahAWIAJBkANqIAJBkANqIAEQGSACIAIpA7ADNwOIAyACIAIpA6gDNwOAAyACIAIpA6ADNwP4AiACIAIpA5gDNwPwAiACIAIpA5ADNwPoAiACQegCaiACQegCahAWIAJB6AJqIAJB6AJqEBYgAkHoAmogAkHoAmoQFiACQegCaiACQegCaiACQZADahAZIAIgAikDiAM3A+ACIAIgAikDgAM3A9gCIAIgAikD+AI3A9ACIAIgAikD8AI3A8gCIAIgAikD6AI3A8ACIAJBwAJqIAJBwAJqEBYgAkHAAmogAkHAAmoQFiACQcACaiACQcACahAWIAJBwAJqIAJBwAJqIAJBkANqEBkgAiACKQPgAjcDuAIgAiACKQPYAjcDsAIgAiACKQPQAjcDqAIgAiACKQPIAjcDoAIgAiACKQPAAjcDmAIgAkGYAmogAkGYAmoQFiACQZgCaiACQZgCahAWIAJBmAJqIAJBmAJqIAJBuANqEBkgAiACKQO4AjcDkAIgAiACKQOwAjcDiAIgAiACKQOoAjcDgAIgAiACKQOgAjcD+AEgAiACKQOYAjcD8AEgAkHwAWogAkHwAWoQFiACQfABaiACQfABahAWIAJB8AFqIAJB8AFqEBYgAkHwAWogAkHwAWoQFiACQfABaiACQfABahAWIAJB8AFqIAJB8AFqEBYgAkHwAWogAkHwAWoQFiACQfABaiACQfABahAWIAJB8AFqIAJB8AFqEBYgAkHwAWogAkHwAWoQFiACQfABaiACQfABahAWIAJB8AFqIAJB8AFqIAJBmAJqEBkgAiACKQOQAjcD6AEgAiACKQOIAjcD4AEgAiACKQOAAjcD2AEgAiACKQP4ATcD0AEgAiACKQPwATcDyAEgAkHIAWogAkHIAWoQFiACQcgBaiACQcgBahAWIAJByAFqIAJByAFqEBYgAkHIAWogAkHIAWoQFiACQcgBaiACQcgBahAWIAJByAFqIAJByAFqEBYgAkHIAWogAkHIAWoQFiACQcgBaiACQcgBahAWIAJByAFqIAJByAFqEBYgAkHIAWogAkHIAWoQFiACQcgBaiACQcgBahAWIAJByAFqIAJByAFqEBYgAkHIAWogAkHIAWoQFiACQcgBaiACQcgBahAWIAJByAFqIAJByAFqEBYgAkHIAWogAkHIAWoQFiACQcgBaiACQcgBahAWIAJByAFqIAJByAFqEBYgAkHIAWogAkHIAWoQFiACQcgBaiACQcgBahAWIAJByAFqIAJByAFqEBYgAkHIAWogAkHIAWoQFiACQcgBaiACQcgBaiACQfABahAZIAIgAikD6AE3A8ABIAIgAikD4AE3A7gBIAIgAikD2AE3A7ABIAIgAikD0AE3A6gBIAIgAikDyAE3A6ABIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABaiACQcgBahAZIAIgAikDwAE3A5gBIAIgAikDuAE3A5ABIAIgAikDsAE3A4gBIAIgAikDqAE3A4ABIAIgAikDoAE3A3gDQCACQfgAaiACQfgAahAWIANBAWoiA0HYAEcNAAsgAkH4AGogAkH4AGogAkGgAWoQGSACIAIpA5gBNwNwIAIgAikDkAE3A2ggAiACKQOIATcDYCACIAIpA4ABNwNYIAIgAikDeDcDUCACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGogAkHIAWoQGSACIAIpA3A3A0ggAkFAayIDIAIpA2g3AwAgAiACKQNgNwM4IAIgAikDWDcDMCACIAIpA1A3AyggAkEoaiACQShqEBYgAkEoaiACQShqEBYgAkEoaiACQShqEBYgAkEoaiACQShqIAJBkANqEBkgAiACKQNINwMgIAIgAykDADcDGCACIAIpAzg3AxAgAiACKQMwNwMIIAIgAikDKDcDACACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIgAkHwAWoQGSACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIQFiACIAIgARAZIAIgAhAWIAIgAhAWIAIgAhAWIAIgAiACQbgDahAZIAIgAhAWIAIgAhAWIAAgASACEBkgAkHgA2okAAudIQEBfyMAQcADayICJAAgAkGAAWogARAXIAJBoANqIAJBgAFqIAEQHSACQeAAaiACQYABaiACQaADahAdIAJBgANqIAJB4ABqIAJBgAFqEB0gAkFAayACQYADaiACQYABahAdIAJBIGogAkFAayACQYABahAdIAIgAkEgaiACQYABahAdIAJB4AJqIAIQFyACQeACaiACQeACahAXIAJB4AJqIAJB4AJqIAJBIGoQHSACQcACaiACQeACahAXIAJBwAJqIAJBwAJqEBcgAkHAAmogAkHAAmogAkGgA2oQHSACQaACaiACQcACahAXIAJBoAJqIAJBoAJqEBcgAkGgAmogAkGgAmoQFyACQaACaiACQaACahAXIAJBoAJqIAJBoAJqEBcgAkGgAmogAkGgAmoQFyACQaACaiACQaACaiACQeACahAdIAJBgAJqIAJBoAJqEBcgAkGAAmogAkGAAmoQFyACQYACaiACQYACahAXIAJBgAJqIAJBgAJqEBcgAkGAAmogAkGAAmoQFyACQYACaiACQYACahAXIAJBgAJqIAJBgAJqEBcgAkGAAmogAkGAAmoQFyACQYACaiACQYACahAXIAJBgAJqIAJBgAJqEBcgAkGAAmogAkGAAmoQFyACQYACaiACQYACahAXIAJBgAJqIAJBgAJqEBcgAkGAAmogAkGAAmoQFyACQYACaiACQYACaiACQaACahAdIAJB4AFqIAJBgAJqEBcgAkHgAWogAkHgAWoQFyACQeABaiACQeABahAXIAJB4AFqIAJB4AFqEBcgAkHgAWogAkHgAWoQFyACQeABaiACQeABahAXIAJB4AFqIAJB4AFqEBcgAkHgAWogAkHgAWoQFyACQeABaiACQeABahAXIAJB4AFqIAJB4AFqEBcgAkHgAWogAkHgAWoQFyACQeABaiACQeABahAXIAJB4AFqIAJB4AFqEBcgAkHgAWogAkHgAWoQFyACQeABaiACQeABahAXIAJB4AFqIAJB4AFqEBcgAkHgAWogAkHgAWoQFyACQeABaiACQeABahAXIAJB4AFqIAJB4AFqEBcgAkHgAWogAkHgAWoQFyACQeABaiACQeABahAXIAJB4AFqIAJB4AFqEBcgAkHgAWogAkHgAWoQFyACQeABaiACQeABahAXIAJB4AFqIAJB4AFqEBcgAkHgAWogAkHgAWoQFyACQeABaiACQeABahAXIAJB4AFqIAJB4AFqEBcgAkHgAWogAkHgAWogAkGAAmoQHSACQcABaiACQeABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWoQFyACQcABaiACQcABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWoQFyACQcABaiACQcABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWoQFyACQcABaiACQcABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWoQFyACQcABaiACQcABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWoQFyACQcABaiACQcABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWoQFyACQcABaiACQcABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWoQFyACQcABaiACQcABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWoQFyACQcABaiACQcABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWoQFyACQcABaiACQcABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWoQFyACQcABaiACQcABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWoQFyACQcABaiACQcABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWoQFyACQcABaiACQcABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWoQFyACQcABaiACQcABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWoQFyACQcABaiACQcABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWoQFyACQcABaiACQcABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWoQFyACQcABaiACQcABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWoQFyACQcABaiACQcABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWoQFyACQcABaiACQcABahAXIAJBwAFqIAJBwAFqEBcgAkHAAWogAkHAAWogAkHgAWoQHSACQaABaiACQcABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWogAkGgAmoQHSACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABaiACQeAAahAdIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWogAkGAA2oQHSACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqIAJB4ABqEB0gAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqIAJBIGoQHSACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqIAJBIGoQHSACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqIAJBgANqEB0gAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqIAJBgANqEB0gAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWogAhAdIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWogAkHgAGoQHSACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABaiACQYADahAdIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABaiACQUBrEB0gAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWogAkHgAGoQHSACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqIAJBgANqEB0gAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABaiACQYADahAdIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqIAJBwAJqEB0gAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqIAJBQGsQHSACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABaiACQSBqEB0gAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABaiACEB0gAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqIAJBoANqEB0gAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWogAhAdIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWogAhAdIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWogAkFAaxAdIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqIAEQHSACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgAkGgAWogAkGgAWoQFyACQaABaiACQaABahAXIAJBoAFqIAJBoAFqEBcgACACQaABaiACQeACahAdIAJBwANqJAALlQEBBX4gACACKQMAIgMgASkDAHwiBDcDACAAIAQgA1StIgUgASkDCHwiAyACKQMIfCIGNwMIIAAgAikDECIHIAEpAxB8IgQgAyAFVK0gBiADVK18fCIFNwMQIAAgAikDGCIGIAEpAxh8IgMgBCAHVK0gBSAEVK18fCIENwMYIAAgABB0IAMgBlStIAQgA1StfKdqEHMaCwwAIABBAEHEABAyGgueAgECfyMAQdABayIDJAAgAEKBgoSIkKDAgAE3AgAgAEIANwIgIABCgYKEiJCgwIABNwIYIABCgYKEiJCgwIABNwIQIABCgYKEiJCgwIABNwIIIABCADcCKCAAQgA3AjAgAEIANwI4IANBCGogAEEgaiIEEEEgA0EIaiAAQSAQMCADQQhqQfizBEEBEDAgA0EIaiABIAIQMCADQQhqIAQQQCADQQhqIAQQQSADQQhqIABBIBAwIANBCGogABBAIANBCGogBBBBIANBCGogAEEgEDAgA0EIakH5swRBARAwIANBCGogASACEDAgA0EIaiAEEEAgA0EIaiAEEEEgA0EIaiAAQSAQMCADQQhqIAAQQCAAQQA2AkAgA0HQAWokAAsEACAAC4sBAgF/AX4CQAJAIAApAxhQRSAAKQMgQgBScg0AIAApAxAiAkKjopUKVg0AQX8hASACQqOilQpSDQEgACkDCCICQoKI8a+3oeUAVg0AIAJCgojxr7eh5QBSDQFBASEBIAApAwAiAkLu9ab+oq7oBlYNAUF/QQAgAkLu9ab+oq7oBlIbDwtBASEBCyABC3UBAX8jAEHQAGsiAiQAIAJBKGogAUHQAGoQFiACQShqIAJBKGogABAZIAIgASkDIDcDICACIAEpAxg3AxggAiABKQMQNwMQIAIgASkDCDcDCCACIAEpAwA3AwAgAhAvIAJBKGogAhCaASEAIAJB0ABqJAAgAAsJACAAIAEQogELcgICfwF+IAApAxgiA0I/iKciAkF/cyIBIAApAxBCf1JxIANC////////////AFRyIAApAwgiA0KdoJG9tc7bq90AVCABcXJBf3MiASADQp2gkb21ztur3QBWcSACciABIAApAwBCoMHswOboy/RfVnFyC94CAQV/IwBBQGoiAyQAIANBADYCPCADQgA3AyggA0IANwMgIANCADcDGCADQgA3AxACQCABKAIAIgQgAkYgBC0AAEECR3INACABIARBAWo2AgAgA0EMaiABIAIQrAFFDQAgAygCDCIERQ0AIAEoAgAiBSAEaiACSw0AAkACQCAFLAAAIgIgBEECSSIHckUEQCAFLAABQX9KDQNBASEGDAELAn8CQCAHIAJBf0dyRQRAIAUsAAFBAE4NAQwFC0EBIAJBf0oNARoLIANBATYCPCAFLQAAIQJBAAshBiACQf8BcQ0BCyADIARBf2oiBDYCDCABIAVBAWoiBTYCAAsCQAJAIARBIU8EQCADQQE2AjwMAQsgBkUNACADIARrQTBqIAUgBBAfGiAAIANBEGogA0E8ahAxIAMoAjxFDQELIABBABBtCyABIAEoAgAgBGo2AgBBASEGCyADQUBrJAAgBgvgAQEFfyAAQQA2AgACQCABKAIAIgYgAk8NACABIAZBAWoiBDYCACAGLQAAIgNB/wFGDQAgA0GAAXFFBEAgACADNgIAQQEhBQwBCyADQYABRg0AIANB/wBxIgcgAiAEayIDSyAHQQRLcg0AIAQtAAAiBEUNAAJAIAdFBEBBACEEDAELIAAgBDYCACABIAZBAmoiBTYCACAHQX9qIgMEQANAIAAgBS0AACAEQQh0ciIENgIAIAEgBUEBaiIFNgIAIANBf2oiAw0ACwsgAiAFayEDCyAEIANNIARB/wBLcQ8LIAULIAAgACkDICAAKQMYIAApAxAgACkDCCAAKQMAhISEhFALMAAgACABEOwBRQRAQQAPCyAAQShqIgEQViAAKQMoEGcgAkcE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EBAYIAAgAykD2AEgBCAFVK18IgcgAykD6AEgBiAEVK18fCIEIAMpA6ABfCIFIAMpA7ABfCIGIAMpA8ABfCIINwMQIANB4ABqIAIpAxhCACABKQMAEBggA0HwAGogAikDEEIAIAEpAwgQGCADQYABaiACKQMIQgAgASkDEBAYIANBkAFqIAIpAwBCACABKQMYEBggACADKQOoASAFIARUrXwiCiAEIAdUrXwiBCADKQO4ASAGIAVUrXx8IgUgAykDyAEgCCAGVK18fCIGIAMpA2B8IgcgAykDcHwiCCADKQOAAXwiCSADKQOQAXwiCzcDGCADQTBqIAIpAxhCACABKQMIEBggA0FAayACKQMQQgAgASkDEBAYIANB0ABqIAIpAwhCACABKQMYEBggACADKQOYASALIAlUrXwiCyAGIAVUrSAFIARUrSAEIApUrXx8IgogAykDaCAHIAZUrXx8IgQgAykDeCAIIAdUrXx8IgUgAykDiAEgCSAIVK18fCIJfCIGIAMpAzB8IgcgAykDQHwiCCADKQNQfCIMNwMgIANBEGogAikDGEIAIAEpAxAQGCADQSBqIAIpAxBCACABKQMYEBggACAGIAtUrSAJIAVUrSAFIARUrSAEIApUrXx8fCIJIAMpAzggByAGVK18fCIEIAMpA0ggCCAHVK18fCIFIAMpA1ggDCAIVK18fCIGIAMpAxB8IgcgAykDIHwiCDcDKCADIAIpAxhCACABKQMYEBggACAGIAVUrSAFIARUrSAEIAlUrXx8IgkgAykDGCAHIAZUrXx8IgQgAykDKCAIIAdUrXx8IgUgAykDAHwiBjcDMCAAIAYgBVStIAUgBFStIAMpAwggBCAJVK18fHw3AzggA0GAAmokAAszAQF/IwBBMGsiAiQAIAJBCGogAEEBECIgAkEIaiABECEgAkEIahBiIQAgAkEwaiQAIAAL9RYBAn8jAEHgA2siAiQAIAJBuANqIAEQFiACQbgDaiACQbgDaiABEBkgAkGQA2ogAkG4A2oQFiACQZADaiACQZADaiABEBkgAiACKQOwAzcDiAMgAiACKQOoAzcDgAMgAiACKQOgAzcD+AIgAiACKQOYAzcD8AIgAiACKQOQAzcD6AIgAkHoAmogAkHoAmoQFiACQegCaiACQegCahAWIAJB6AJqIAJB6AJqEBYgAkHoAmogAkHoAmogAkGQA2oQGSACIAIpA4gDNwPgAiACIAIpA4ADNwPYAiACIAIpA/gCNwPQAiACIAIpA/ACNwPIAiACIAIpA+gCNwPAAiACQcACaiACQcACahAWIAJBwAJqIAJBwAJqEBYgAkHAAmogAkHAAmoQFiACQcACaiACQcACaiACQZADahAZIAIgAikD4AI3A7gCIAIgAikD2AI3A7ACIAIgAikD0AI3A6gCIAIgAikDyAI3A6ACIAIgAikDwAI3A5gCIAJBmAJqIAJBmAJqEBYgAkGYAmogAkGYAmoQFiACQZgCaiACQZgCaiACQbgDahAZIAIgAikDuAI3A5ACIAIgAikDsAI3A4gCIAIgAikDqAI3A4ACIAIgAikDoAI3A/gBIAIgAikDmAI3A/ABIAJB8AFqIAJB8AFqEBYgAkHwAWogAkHwAWoQFiACQfABaiACQfABahAWIAJB8AFqIAJB8AFqEBYgAkHwAWogAkHwAWoQFiACQfABaiACQfABahAWIAJB8AFqIAJB8AFqEBYgAkHwAWogAkHwAWoQFiACQfABaiACQfABahAWIAJB8AFqIAJB8AFqEBYgAkHwAWogAkHwAWoQFiACQfABaiACQfABaiACQZgCahAZIAIgAikDkAI3A+gBIAIgAikDiAI3A+ABIAIgAikDgAI3A9gBIAIgAikD+AE3A9ABIAIgAikD8AE3A8gBIAJByAFqIAJByAFqEBYgAkHIAWogAkHIAWoQFiACQcgBaiACQcgBahAWIAJByAFqIAJByAFqEBYgAkHIAWogAkHIAWoQFiACQcgBaiACQcgBahAWIAJByAFqIAJByAFqEBYgAkHIAWogAkHIAWoQFiACQcgBaiACQcgBahAWIAJByAFqIAJByAFqEBYgAkHIAWogAkHIAWoQFiACQcgBaiACQcgBahAWIAJByAFqIAJByAFqEBYgAkHIAWogAkHIAWoQFiACQcgBaiACQcgBahAWIAJByAFqIAJByAFqEBYgAkHIAWogAkHIAWoQFiACQcgBaiACQcgBahAWIAJByAFqIAJByAFqEBYgAkHIAWogAkHIAWoQFiACQcgBaiACQcgBahAWIAJByAFqIAJByAFqEBYgAkHIAWogAkHIAWogAkHwAWoQGSACIAIpA+gBNwPAASACIAIpA+ABNwO4ASACIAIpA9gBNwOwASACIAIpA9ABNwOoASACIAIpA8gBNwOgASACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWoQFiACQaABaiACQaABahAWIAJBoAFqIAJBoAFqEBYgAkGgAWogAkGgAWogAkHIAWoQGSACIAIpA8ABNwOYASACIAIpA7gBNwOQASACIAIpA7ABNwOIASACIAIpA6gBNwOAASACIAIpA6ABNwN4A0AgAkH4AGogAkH4AGoQFiADQQFqIgNB2ABHDQALIAJB+ABqIAJB+ABqIAJBoAFqEBkgAiACKQOYATcDcCACIAIpA5ABNwNoIAIgAikDiAE3A2AgAiACKQOAATcDWCACIAIpA3g3A1AgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqEBYgAkHQAGogAkHQAGoQFiACQdAAaiACQdAAahAWIAJB0ABqIAJB0ABqIAJByAFqEBkgAiACKQNwNwNIIAJBQGsiAyACKQNoNwMAIAIgAikDYDcDOCACIAIpA1g3AzAgAiACKQNQNwMoIAJBKGogAkEoahAWIAJBKGogAkEoahAWIAJBKGogAkEoahAWIAJBKGogAkEoaiACQZADahAZIAIgAikDSDcDICACIAMpAwA3AxggAiACKQM4NwMQIAIgAikDMDcDCCACIAIpAyg3AwAgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACIAJB8AFqEBkgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACEBYgAiACIAJBuANqEBkgAiACEBYgACACEBYgAiAAEBYgAiABEOoBIQAgAkHgA2okACAAC44BAQF/IwBBgAFrIgIkACAAIAEpAyA3AyAgACABKQMYNwMYIAAgASkDEDcDECAAIAEpAwg3AwggACABKQMANwMAIAJB2ABqIAEQFiACQTBqIAEgAkHYAGoQGSAAQQA2AlAgAkEIakEHEDYgAkEIaiACQTBqECEgAEEoaiACQQhqEOsBIQAgAkGAAWokACAAC+EIAgF/D34jAEHQAmsiAiQAIAJBQGsgASkDGCIEQgAgASkDACIHQgGGIgoQGCACQZACaiABKQMIIghCAYYiBUIAIAEpAxAiBhAYIAJB4AFqIAEpAyAiCUIAIAkQGCACQdABaiACKQPgASIDQv////////8Hg0IAQpD6gICAAhAYIAJBsAFqIAlCAYYiCUIAIAcQGCACQdAAaiAEQgAgBRAYIAJBgAJqIAZCACAGEBggAkHAAWogAikD6AEiBUIMhiADQjSIhCAFQjSIQpD6gICAAhAYIAJBwAJqIAdCACAHEBggAkGgAWogCUIAIAgQGCACQeAAaiAGQgGGQgAgBBAYIAIgAikDoAEiDyACKQNgfCIFIAIpA1AiDiACKQOAAnwiAyACKQOwAXwiCyACKQPAAXwiDCACKQNAIg0gAikDkAJ8IgcgAikD0AF8IhBCNIggECAHVK0gAikD2AEgByANVK0gAikDSCACKQOYAnx8fHwiDUIMhoR8IgdCNIggByAMVK0gDCALVK0gAikDyAEgCyADVK0gAikDuAEgAyAOVK0gAikDWCACKQOIAnx8fHx8fCANQjSIfHwiDkIMhoR8IgNCBIZC8P////////8AgyAHQjCIQg+DhEIAQtGHgIAQEBggACACKQMAIg0gAikDwAJ8IgtC/////////weDNwMAIAJBsAJqIApCACAIEBggAkGQAWogCUIAIAYQGCACQfAAaiAEQgAgBBAYIAJBMGogAikDkAEiESACKQNwfCIMIAMgBVStIAUgD1StIAIpA6gBIAIpA2h8fCAOQjSIfHwiD0IMhiADQjSIhHwiBUL/////////B4NCAEKQ+oCAgAIQGCAAIAIpAzAiDiACKQOwAnwiAyALIA1UrSACKQMIIAIpA8gCfHwiDUIMhiALQjSIhHwiC0L/////////B4M3AwggAkHwAWogBkIAIAoQGCACQaACaiAIQgAgCBAYIAJBgAFqIAlCACAEEBggAkEgaiAFIAxUrSAMIBFUrSACKQOYASACKQN4fHwgD0I0iHx8IgpCDIYgBUI0iIQiBSACKQOAAXwiBEL/////////B4NCAEKQ+oCAgAIQGCAAIAIpA/ABIgwgAikDoAJ8IgYgAikDIHwiCCALIANUrSADIA5UrSACKQM4IAIpA7gCfHwgDUI0iHx8IgNCDIYgC0I0iIR8IglC/////////weDNwMQIAJBEGogBCAFVK0gAikDiAEgCkI0iHx8IgpCDIYgBEI0iIQgCkI0iEKQ+oCAgAIQGCAAIAIpAxAiCiAQQv7///////8Hg3wiBCAJIAhUrSAIIAZUrSACKQMoIAYgDFStIAIpA/gBIAIpA6gCfHx8fCADQjSIfHwiCEIMhiAJQjSIhHwiBkL/////////B4M3AxggACAHQv///////z+DIAYgBFStIAIpAxggBCAKVK18IAhCNIh8fEIMhiAGQjSIhHw3AyAgAkHQAmokAAvaCwIBfxl+IwBB8ANrIgMkACADQUBrIAIpAxgiBEIAIAEpAwAiBRAYIANB0AFqIAIpAxAiBkIAIAEpAwgiCxAYIANBwAJqIAIpAwgiDEIAIAEpAxAiDRAYIANBkANqIAIpAwAiB0IAIAEpAxgiDxAYIANB4ANqIAIpAyAiEEIAIAEpAyAiERAYIANB0ANqIAMpA+ADIghC/////////weDQgBCkPqAgIACEBggA0HQAGogEEIAIAUQGCADQZABaiAEQgAgCxAYIANBkAJqIAZCACANEBggA0HwAmogDEIAIA8QGCADQbADaiAHQgAgERAYIANBwANqIAMpA+gDIg5CDIYgCEI0iIQgDkI0iEKQ+oCAgAIQGCADQeAAaiAHQgAgBRAYIANB4AFqIBBCACALEBggA0GgAWogBEIAIA0QGCADQaACaiAGQgAgDxAYIANBgANqIAxCACAREBggAyADKQOgAiIZIAMpA6ABfCIOIAMpA4ADfCITIAMpA+ABfCIUIAMpA5ACIhsgAykDkAF8IgkgAykD8AJ8IhUgAykDsAN8IhYgAykDUHwiFyADKQPAA3wiEiADKQPQASIcIAMpA0B8IgggAykDwAJ8IgogAykDkAN8IhggAykD0AN8IhpCNIggGiAYVK0gAykD2AMgGCAKVK0gAykDmAMgCiAIVK0gAykDyAIgCCAcVK0gAykD2AEgAykDSHx8fHx8fHx8IgpCDIaEfCIIQjSIIAggElStIBIgF1StIAMpA8gDIBcgFlStIAMpA1ggFiAVVK0gAykDuAMgFSAJVK0gAykD+AIgCSAbVK0gAykDmAIgAykDmAF8fHx8fHx8fHx8IApCNIh8fCISQgyGhHwiCUIEhkLw/////////wCDIAhCMIhCD4OEQgBC0YeAgBAQGCAAIAMpAwAiCiADKQNgfCIVQv////////8HgzcDACADQfAAaiAMQgAgBRAYIANB8AFqIAdCACALEBggA0HQAmogEEIAIA0QGCADQbABaiAEQgAgDxAYIANBsAJqIAZCACAREBggA0EwaiADKQOwAiIYIAMpA7ABfCIWIAMpA9ACfCIXIAkgFFStIBQgE1StIAMpA+gBIBMgDlStIAMpA4gDIA4gGVStIAMpA6gCIAMpA6gBfHx8fHx8IBJCNIh8fCISQgyGIAlCNIiEfCIOQv////////8Hg0IAQpD6gICAAhAYIAAgAykD8AEiGSADKQNwfCITIAMpAzB8IhQgFSAKVK0gAykDCCADKQNofHwiCkIMhiAVQjSIhHwiCUL/////////B4M3AwggA0GAAWogBkIAIAUQGCADQYACaiAMQgAgCxAYIANB4AJqIAdCACANEBggA0GgA2ogEEIAIA8QGCADQcABaiAEQgAgERAYIANBIGogAykDoAMiByADKQPAAXwiBCAOIBdUrSAXIBZUrSADKQPYAiAWIBhUrSADKQO4AiADKQO4AXx8fHwgEkI0iHx8Ig9CDIYgDkI0iIR8IgVC/////////weDQgBCkPqAgIACEBggACADKQOAAiIQIAMpA4ABfCIGIAMpA+ACfCILIAMpAyB8IgwgCSAUVK0gFCATVK0gAykDOCATIBlUrSADKQP4ASADKQN4fHx8fCAKQjSIfHwiEUIMhiAJQjSIhHwiDUL/////////B4M3AxAgA0EQaiAFIARUrSAEIAdUrSADKQOoAyADKQPIAXx8IA9CNIh8fCIEQgyGIAVCNIiEIARCNIhCkPqAgIACEBggACADKQMQIgcgGkL/////////B4N8IgQgDSAMVK0gDCALVK0gAykDKCALIAZUrSADKQPoAiAGIBBUrSADKQOIAiADKQOIAXx8fHx8fCARQjSIfHwiBkIMhiANQjSIhHwiBUL/////////B4M3AxggACAIQv///////z+DIAUgBFStIAMpAxggBCAHVK18IAZCNIh8fEIMhiAFQjSIhHw3AyAgA0HwA2okAAuoAgEDfyMAQaABayICJAAgAEEANgJ4IABB0ABqIgMgAUHQAGogAUEoaiIEEBkgA0ECEC4gAkH4AGogARAWIAJB+ABqQQMQLiACQdAAaiACQfgAahAWIAJBKGogBBAWIAJBKGpBAhAuIAIgAkEoahAWIAJBAhAuIAJBKGogAkEoaiABEBkgACACKQNINwMgIAAgAkFAaykDADcDGCAAIAIpAzg3AxAgACACKQMwNwMIIAAgAikDKDcDACAAQQQQLiAAIABBBBAiIAAgAkHQAGoQISACQdAAaiACQdAAakEBECIgAkEoakEGEC4gAkEoaiACQdAAahAhIABBKGoiACACQfgAaiACQShqEBkgAkHQAGogAkECECIgACACQdAAahAhIAJBoAFqJAALPAEBfyMAQfAAayIEJAAgBEEIaiABIAIgAyAAKAIAEQcAQegAEEYgBEEIakHoABAfIQAgBEHwAGokACAAC9EBAQN/IwBB0ABrIgIkACAAIAEoAngiAzYCUCADRQRAIAFB0ABqIgMgAxCeASACQShqIAMQFiACIAMgAkEoahAZIAEgASACQShqEBkgAUEoaiIEIAQgAhAZIANBARA2IAAgASkDIDcDICAAIAEpAxg3AxggACABKQMQNwMQIAAgASkDCDcDCCAAIAEpAwA3AwAgACABKQMoNwMoIAAgASkDMDcDMCAAIAEpAzg3AzggAEFAayABQUBrKQMANwMAIAAgASkDSDcDSAsgAkHQAGokAAvnAQECfyMAQYAEayIGJAACQCABEDQNACACEDQNACAGQeADaiABEDogBkG4A2ogBkHgA2oQShogBUECcQRAIAZBuANqEKcBQX9KDQEgBkG4A2pB0LMEECELIAZB4AJqIAZBuANqIAVBAXEQrgFFDQAgBkHgAWogBkHgAmoQSyAGQcABaiABEKkBIAZBoAFqIAZBwAFqIAQQHSAGQaABaiAGQaABahBmIAZBgAFqIAZBwAFqIAIQHSAAIAYgBkHgAWogBkGAAWogBkGgAWoQcSADIAYQ8QEgBigCeEUhBwsgBkGABGokACAHC6MCAQF/IwBBwAFrIgQkAAJAIAAoAgAQTUUEQCAAKAKwASAAKAK0AUGPMBAeQQAhAgwBCyADRQRAIAAoArABIAAoArQBQcMwEB5BACECDAELIAJFBEAgACgCsAEgACgCtAFBjTEQHkEAIQIMAQsgAUUEQCAAKAKwASAAKAK0AUGYLhAeQQAhAgwBCyAEQcgAaiAEQShqIARBBGogAhCfAUEAIQIgBEEIaiADQQAQMSAAIARByABqIARBKGogBEHoAGogBEEIaiAEKAIEEPIBBEAgASAEQegAahBoQQEhAgwBCyABQgA3AAAgAUIANwA4IAFCADcAMCABQgA3ACggAUIANwAgIAFCADcAGCABQgA3ABAgAUIANwAICyAEQcABaiQAIAILsgMBBH8jAEHQAWsiBiQAIAZBADYCKAJAIAAoAggQTUUEQCAAKAKwASAAKAK0AUHRMBAeDAELIAJFBEAgACgCsAEgACgCtAFBwzAQHgwBCyABRQRAIAAoArABIAAoArQBQY0xEB4MAQsgA0UEQCAAKAKwASAAKAK0AUGfMRAeDAELIAZB8ABqIAMgBkEoahAxAkAgBigCKA0AIAZB8ABqEDQNACAGQTBqIAJBABAxAkAgBiACIANBACAFQQAgBEEuIAQbIgkRDQAiBEUEQAwBCyAAQQhqIQADQCAGQdAAaiAGIAZBKGoQMQJAIAYoAigNACAGQdAAahA0DQAgBCEHIAAgBkGwAWogBkGQAWogBkHwAGogBkEwaiAGQdAAaiAGQSxqEIECDQILQQAhByAGIAIgA0EAIAUgCEEBaiIIIAkRDQAiBA0ACwsgBkIANwMYIAZCADcDECAGQgA3AwggBkIANwMAIAZBMGoQQiAGQdAAahBCIAZB8ABqEEIgB0UNACABIAZBsAFqIAZBkAFqIAYoAiwQoAEMAQtBACEHIAFBAEHBABAyGgsgBkHQAWokACAHC44BAQF/IwBBQGoiBCQAAn8gAUUEQCAAKAKwASAAKAK0AUH+LxAeQQAMAQsgA0UEQCAAKAKwASAAKAK0AUHiLxAeQQAMAQsgAkUEQCAAKAKwASAAKAK0AUHVMRAeQQAMAQsgBEEgaiAEIAIgAxCfASABIARBIGoQOiABQSBqIAQQOkEBCyEBIARBQGskACABC8IBAQJ/IwBB0ABrIgQkACAEQQA2AgwCQCABRQRAIAAoArABIAAoArQBQeIvEB4MAQsgAkUEQCAAKAKwASAAKAK0AUHuLxAeDAELIANBBE8EQCAAKAKwASAAKAK0AUG8MRAeDAELIARBMGogAiAEQQxqEDEgBCgCDCEAIARBEGogAkEgaiAEQQxqEDEgACAEKAIMckUEQCABIARBMGogBEEQaiADEKABQQEhBQwBCyABQQBBwQAQMhoLIARB0ABqJAAgBQsHACAAEQ4AC04BAn8jAEEwayICJAAgAkEIaiABEBYgACAAIAJBCGoQGSAAQShqIgMgAyACQQhqEBkgAyADIAEQGSAAQdAAaiIAIAAgARAZIAJBMGokAAu5AQAgACABKAJ4NgJ4IAAgASkDIDcDICAAIAEpAxg3AxggACABKQMQNwMQIAAgASkDCDcDCCAAIAEpAwA3AwAgACABKQMoNwMoIAAgASkDMDcDMCAAIAEpAzg3AzggAEFAayABQUBrKQMANwMAIAAgASkDSDcDSCAAIAEpA1g3A1ggACABKQNgNwNgIAAgASkDaDcDaCAAIAEpA3A3A3AgACABKQNQNwNQIABBKGoiABAvIAAgAEEBECILGAAgACgCCBBNBEAgAEEIaiABELABC0EBC1QBAX8jAEGgAWsiAyQAIANBIGogARBLIANBARBtIAAgA0EgaiADQSBqIAMgAhBxQQAhACADKAKYAUUEQCABIANBIGoQbkEBIQALIANBoAFqJAAgAAurAgECfyMAQYABayIDJAAgA0EANgIEAkAgACgCABBNRQRAIAAoArABIAAoArQBQY8wEB4MAQsgAUUEQCAAKAKwASAAKAK0AUGYLhAeDAELIAJFBEAgACgCsAEgACgCtAFBrjEQHgwBCyADQQhqIAIgA0EEahAxIAMoAgQEQCABQgA3AAAgAUIANwA4IAFCADcAMCABQgA3ACggAUIANwAgIAFCADcAGCABQgA3ABAgAUIANwAIDAELIAAgA0EoaiABEHYhAiABQgA3ADggAUIANwAwIAFCADcAKCABQgA3ACAgAUIANwAYIAFCADcAECABQgA3AAggAUIANwAAIAJFDQAgACADQShqIANBCGoQ+wFFDQAgASADQShqEGhBASEECyADQYABaiQAIAQLOAEBfyMAQfAAayIDJAAgA0EIahBaIAAgARBMIAIQXyADQQhqEFogAkEgEEwgAhBfIANB8ABqJAALjAcBBn8jAEGQBGsiAyQAIANB6ANqIAFB0ABqIgUQFiADIAEpAyA3A+ADIAMgASkDGDcD2AMgAyABKQMQNwPQAyADIAEpAwg3A8gDIAMgASkDADcDwAMgA0HAA2oQLyADQZgDaiACIANB6ANqEBkgAyABKQNINwOQAyADIAFBQGspAwA3A4gDIAMgASkDODcDgAMgAyABKQMwNwP4AiADIAEpAyg3A/ACIANB8AJqEC8gA0HIAmogAkEoaiIHIANB6ANqEBkgA0HIAmogA0HIAmogBRAZIAMgAykD4AM3A8ACIAMgAykD2AM3A7gCIAMgAykD0AM3A7ACIAMgAykDyAM3A6gCIAMgAykDwAM3A6ACIANBoAJqIANBmANqECEgAyADKQOQAzcD8AEgAyADKQOIAzcD6AEgAyADKQOAAzcD4AEgAyADKQP4AjcD2AEgAyADKQPwAjcD0AEgA0HQAWogA0HIAmoQISADQdgAaiADQaACahAWIANBMGogA0GYA2pBARAiIANB+AFqIANBwANqIANBMGoQGSADQdgAaiADQfgBahAhIANB0AFqEGIhBCADQdgAahBiIQYgAyADKQOQAzcDKCADIAMpA4gDNwMgIAMgAykDgAM3AxggAyADKQP4AjcDECADIAMpA/ACNwMIIANBCGpBAhAuIANBMGogA0HAA2oQISADQQhqIANB2ABqIAQgBnEiBEUiBhBJIANBMGogA0HQAWogBhBJIANBqAFqIANBMGoQFiADQYABaiADQagBaiADQaACahAZIANBqAFqIANBqAFqEBYgA0GoAWogA0HQAWogBBBJIANBoAJqIANBCGoQFiAAQdAAaiIEIAUgA0EwahAZIAQQYiEGIAEoAnghCCAEQQIQLiADQYABaiADQYABakEBECIgA0GgAmogA0GAAWoQISADQaACahAvIAAgAykDwAI3AyAgACADKQO4AjcDGCAAIAMpA7ACNwMQIAAgAykDqAI3AwggACADKQOgAjcDACADQaACakECEC4gA0GgAmogA0GAAWoQISADQaACaiADQaACaiADQQhqEBkgA0GgAmogA0GoAWoQISAAQShqIgUgA0GgAmpBAxAiIAUQLyAAQQQQLiAFQQQQLiAAIAIgASgCeBBJ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BkEASA0AIARBC3IhBUEWIQIgBg0AIAQsAAwiBkEASA0AIARBDHIhBUEVIQIgBg0AIAQsAA0iBkEASA0AIARBDXIhBUEUIQIgBg0AIAQsAA4iBkEASA0AIARBDnIhBUETIQIgBg0AIAQsAA8iBkEASA0AIARBD3IhBUESIQIgBg0AIAQsABAiBkEASA0AIARBEGohBUERIQIgBg0AIAQsABEiBkEASA0AIARBEWohBUEQIQIgBg0AIAQsABIiBkEASA0AIARBEmohBUEPIQIgBg0AIAQsABMiBkEASA0AIARBE2ohBUEOIQIgBg0AIAQsABQiBkEASA0AIARBFGohBUENIQIgBg0AIAQsABUiBkEASA0AIARBFWohBUEMIQIgBg0AIAQsABYiBkEASA0AIARBFmohBUELIQIgBg0AIAQsABciBkEASA0AIARBF2ohBUEKIQIgBg0AIAQsABgiBkEASA0AIARBGGohBUEJIQIgBg0AIAQsABkiBkEASA0AIARBGWohBUEIIQIgBg0AIAQsABoiBkEASA0AIARBGmohBUEHIQIgBg0AIAQsABsiBkEASA0AIARBG2ohBUEGIQIgBg0AIAQsABwiBkEASA0AIARBHGohBUEFIQIgBg0AIAQsAB0iBkEASA0AIARBHWohBUEEIQIgBg0AIAQsAB4iBkEASA0AIARBHmohBUEDIQIgBg0AIAQsAB8iBkEASA0AIARBH2ohBUECIQIgBg0AQQFBAiAELAAgQX9KIgYbIQIgCCAFIAYbIQULIAEoAgAhBiABIAIgA2pBBmoiCDYCAEEAIQEgBiAITwRAIAAgAzoAAyAAQQI6AAIgAEEwOgAAIAAgA0EEaiIBIAJqOgABIABBBGogByADEB8aIAAgA2oiAyACOgAFIAAgAWpBAjoAACADQQZqIAUgAhAfGkEBIQELIARB4ABqJAAgAQuFAQEBfyMAQUBqIgQkAAJ/IAFFBEAgACgCsAEgACgCtAFBiy8QHkEADAELIAJFBEAgACgCsAEgACgCtAFBtS4QHkEADAELIANFBEAgACgCsAEgACgCtAFB4i8QHkEADAELIARBIGogBCADEHIgASACIARBIGogBBCGAgshASAEQUBrJAAgAQtSACAAIAEpAAA3AAAgACABKQAYNwAYIAAgASkAEDcAECAAIAEpAAg3AAggACACKQAANwAgIAAgAikACDcAKCAAIAIpABA3ADAgACACKQAYNwA4C4gBAQJ/IwBBEGsiBCQAIAQgAjYCDAJAIANFDQAgBCACQQFqNgIMIAItAABBMEcNACAEQQhqIARBDGogAiADaiICEKwBRSAEKAIIIAIgBCgCDGtHcg0AIAAgBEEMaiACEKsBRQ0AIAEgBEEMaiACEKsBQQBHIAQoAgwgAkZxIQULIARBEGokACAFC6sBAQF/IwBBQGoiBCQAAn8CQCABRQRAIAAoArABIAAoArQBQeIvEB4MAQsgAkUEQCAAKAKwASAAKAK0AUGnLhAeDAELIARBIGogBCACIAMQiQIEQCABIARBIGogBBCIAkEBDAILIAFCADcAACABQgA3ADggAUIANwAwIAFCADcAKCABQgA3ACAgAUIANwAYIAFCADcAECABQgA3AAgLQQALIQEgBEFAayQAIAELYQECfyAAKAJQRQRAIAAQViAAQShqIgQQVkEBIQUgAUEBaiAAEHUgAwRAIAJBITYCACABQQNBAiAEKQMAEGcbOgAAQQEPCyACQcEANgIAIAFBBDoAACABQSFqIAQQdQsgBQv7AQEEfyMAQeAAayIGJAACQCACRQRAIAAoArABIAAoArQBQbUuEB4MAQsgAigCACIHQSFBwQAgBEGAAnEiCBtJBEAgACgCsAEgACgCtAFBxy4QHgwBCyAGIAc2AgQgAkEANgIAIAFFBEAgACgCsAEgACgCtAFBiy8QHgwBCyABQQAgBxAyIQEgA0UEQCAAKAKwASAAKAK0AUGYLhAeDAELIARB/wFxQQJHBEAgACgCsAEgACgCtAFBmi8QHgwBCyAAIAZBCGogAxB2RQ0AIAZBCGogASAGQQRqIAgQiwIiAEUNACACIAYoAgQ2AgAgACEFCyAGQeAAaiQAIAULcQECfyMAQYABayIBJAAgACgCUEUEQCABQdgAaiAAQShqEBYgAUEwaiAAEBYgAUEwaiABQTBqIAAQGSABQQhqQQcQNiABQTBqIAFBCGoQISABQTBqEC8gAUHYAGogAUEwahCaASECCyABQYABaiQAIAILcAAgAEEANgJQIAAgASkDADcDACAAIAEpAwg3AwggACABKQMQNwMQIAAgASkDGDcDGCAAIAEpAyA3AyAgACACKQMANwMoIAAgAikDCDcDMCAAIAIpAxA3AzggAEFAayACKQMYNwMAIAAgAikDIDcDSAvIAQECfyMAQdAAayIDJAACQCACQcEARwRAIAJBIUcgAS0AAEH+AXFBAkdyDQEgA0EoaiABQQFqEEpFBEAMAgsgACADQShqIAEtAABBA0YQrgFBAEchBAwBCyABLQAAIgJBB0tBASACdEHQAXFFcg0AIANBKGogAUEBahBKRQ0AIAMgAUEhahBKRQ0AIAAgA0EoaiADEI4CIAEtAAAiAUH+AXFBBkYEQCADKQMAEGcgAUEHRkcNAQsgABCNAiEECyADQdAAaiQAIAQLrwEBAX8jAEHgAGsiBCQAAn8gAUUEQCAAKAKwASAAKAK0AUGYLhAeQQAMAQsgAUIANwAAIAFCADcAOCABQgA3ADAgAUIANwAoIAFCADcAICABQgA3ABggAUIANwAQIAFCADcACCACRQRAIAAoArABIAAoArQBQacuEB5BAAwBC0EAIARBCGogAiADEI8CRQ0AGiABIARBCGoQaCAEQQhqEHhBAQshASAEQeAAaiQAIAELJAAjAEEQayIBJAAgASAANgIAQZAmKAIAQfuyBCABELcBEAQACzkBAX8CfyAAELMBEFgiAUUEQEGQLigCAEGULigCAEHIsgQQHgsgAQsgABCWAgR/IAEFIAEQREEACwvjBQEGfyMAQYAFayICJAAgAkGABGogAUEAEFUgAiACKQOgBDcDyAMgAiACKQOYBDcDwAMgAiACKQOQBDcDuAMgAiACKQOIBDcDsAMgAiACKQOwBDcD2AMgAiACKQO4BDcD4AMgAiACKQPABDcD6AMgAiACKQPIBDcD8AMgAiACKQOABDcDqAMgAiACKQOoBDcD0AMgAkEANgL4AyACQdACaiABIAJB0ARqIgQQYSACIAIpA5gDNwOYAiACIAIpA5ADNwOQAiACIAIpA4gDNwOIAiACIAIpA4ADNwOAAiACIAIpA/ACNwPwASACIAIpA+gCNwPoASACIAIpA+ACNwPgASACIAIpA9gCNwPYASACIAIpA/gCNwP4ASACIAIpA9ACNwPQASACIAEpA3A3A8ACIAIgASkDaDcDuAIgAiABKQNgNwOwAiACIAEpA1g3A6gCIAIgASkDUDcDoAIgAkEANgLIAiACQaACaiEBIAJB+AJqIQUgAkH4AWohBgNAIAYQViAAIANBBnRqIgdBIGogBhBgIAJB0AFqIAJB0AFqIAJBqANqIAJBgAFqEDkgAkGAAWoQViAHIAJBgAFqEGAgA0EBaiIDQf8/Rw0ACyACQagBaiABIAQQGSACQagBaiACQagBahCeASACQdACaiACQdABaiACQagBahBhIABBwP8faiACQdACahB3IAQgAkGoAWogARAZIAJB2ABqIAQQFiACQdgAaiACQdgAaiACQYAEahAZQf8/IQMDQCACQdACaiAAIANBf2oiAUEGdGoiBBBXIAJBqAFqIAJBqAFqIAJB0AJqEBkgAkEwaiACQagBahAWIAJBCGogAkEwaiACQagBahAZIAJB0AJqIAJB0AJqIAJBMGoQGSACQdACaiACQdACakEBECIgAkHQAmogAkHYAGoQISAFIAUgAkEIahAZIAQgAkHQAmoQdyADQQFLIQQgASEDIAQNAAsgAkGABWokAAtCAQF/IwBBgAFrIgIkACAAKAIARQRAIAJB8LEEEEsgACABQYCAIEGAgCAQsgEiADYCACAAIAIQkwILIAJBgAFqJAALRQEBfyMAQRBrIgEkACABIAApAgA3AwhBoAlB9QhBAkGcCkGkCkENAn9BCBBGIgAgASkCCDcDACAAC0EAEAMgAUEQaiQAC68BAgJ/AX4jAEEQayICJAAgAiAANgIMIAJBDGpBwAEgARCzARCyASIAQZAuKQMANwO4ASAAQfgtKQMAIgQ3A7ABAkAgAUH/AXFBAUcEQCAEpyAEQiCIp0GALhAeQQAhAAwBCyAAELEBIABBCGoiAxCxASABQYAEcQRAIAMoAgBFBEAgA0HwMTYCACADQQAQsAELCyABQYACcUUNACAAIAJBDGoQlAILIAJBEGokACAACyQAIwBBEGsiASQAIAEgADYCAEGQJigCAEHWsgQgARC3ARAEAAupAQEDfwJAIAIoAhAiBAR/IAQFIAIQmQINASACKAIQCyACKAIUIgVrIAFJBEAgAiAAIAEgAigCJBEDABoPCwJAIAIsAEtBAEgNACABIQQDQCAEIgNFDQEgACADQX9qIgRqLQAAQQpHDQALIAIgACADIAIoAiQRAwAgA0kNASAAIANqIQAgASADayEBIAIoAhQhBQsgBSAAIAEQHxogAiACKAIUIAFqNgIUCwtZAQF/IAAgAC0ASiIBQX9qIAFyOgBKIAAoAgAiAUEIcQRAIAAg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AAJ+IAAoAjwgAacgAUIgiKcgAkH/AXEgA0EIahAOEH9FBEAgAykDCAwBCyADQn83AwhCfwshASADQRBqJAAgAQvZAgEHfyMAQSBrIgMkACADIAAoAhwiBDYCECAAKAIUIQUgAyACNgIcIAMgATYCGCADIAUgBGsiATYCFCABIAJqIQRBAiEHIANBEGohAQJ/AkACQCAAKAI8IANBEGpBAiADQQxqEAgQf0UEQANAIAQgAygCDCIFRg0CIAVBf0wNAyABIAUgASgCBCIISyIGQQN0aiIJIAUgCEEAIAYbayIIIAkoAgBqNgIAIAFBDEEEIAYbaiIJIAkoAgAgCGs2AgAgBCAFayEEIAAoAjwgAUEIaiABIAYbIgEgByAGayIHIANBDGoQCBB/RQ0ACwsgA0F/NgIMIARBf0cNAQsgACAAKAIsIgE2AhwgACABNgIUIAAgASAAKAIwajYCECACDAELIABBADYCHCAAQgA3AxAgACAAKAIAQSByNgIAQQAgB0ECRg0AGiACIAEoAgRrCyEEIANBIGokACAECwkAIAAoAjwQEgslAQF/IwBBEGsiACQAQaAJQQFB6AlB4AlBCkEGEA8gAEEQaiQAC4MBAgN/AX4CQCAAQoCAgIAQVARAIAAhBQwBCwNAIAFBf2oiASAAIABCCoAiBUIKfn2nQTByOgAAIABC/////58BViECIAUhACACDQALCyAFpyICBEADQCABQX9qIgEgAiACQQpuIgNBCmxrQTByOgAAIAJBCUshBCADIQIgBA0ACwsgAQstACAAUEUEQANAIAFBf2oiASAAp0EHcUEwcjoAACAAQgOIIgBCAFINAAsLIAELNAAgAFBFBEADQCABQX9qIgEgAKdBD3FBgCZqLQAAIAJyOgAAIABCBIgiAEIAUg0ACwsgAQvEAgEDfyMAQdABayIDJAAgAyACNgLMAUEAIQIgA0GgAWpBAEEoEDIaIAMgAygCzAE2AsgBAkBBACABIANByAFqIANB0ABqIANBoAFqEIABQQBIDQAgACgCTEEATiECIAAoAgAhBCAALABKQQBMBEAgACAEQV9xNgIACyAEQSBxIQUCfyAAKAIwBEAgACABIANByAFqIANB0ABqIANBoAFqEIABDAELIABB0AA2AjAgACADQdAAajYCECAAIAM2AhwgACADNgIUIAAoAiwhBCAA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gABBwAgL5wFfc2luZ2xlX3NoYTI1NgBfZG91YmxlX3NoYTI1NgBDU0hBMjU2AFdyaXRlAEZpbmFsaXplAFJlc2V0AAAAAAAAWBUAALgVAADcFQAAuBUAAHZpaWlpADdDU0hBMjU2AAAEFgAAlgQAAFA3Q1NIQTI1NgAAAOQWAACoBAAAAAAAAKAEAABQSzdDU0hBMjU2AADkFgAAxAQAAAEAAACgBAAAaWkAdgB2aQC0BAAAAAAAAKAEAACgBAAAuBUAANwVAABpaWlpaQAAAFgVAACgBAAAuBUAAHZpaWkAAAAAoAQAALQEAABpaWkAQbAKC8AD/////////////////////////////////////////////////////////////////wABAgMEBQYHCP////////8JCgsMDQ4PEP8REhMUFf8WFxgZGhscHR4fIP///////yEiIyQlJicoKSor/ywtLi8wMTIzNDU2Nzg5/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2NhcnJ5ID09IDAAL2pzYnRjL2NwcC1jcnlwdG8vYmFzZTU4LmNwcABEZWNvZGVCYXNlNTgARW5jb2RlQmFzZTU4ADEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXoAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQBBgA4LAYAAQcAOC7EUCMm882fmCWo7p8qEha5nuyv4lP5y82488TYdXzr1T6XRguatf1IOUR9sPiuMaAWba71B+6vZgx95IX4TGc3gWyKuKNeYL4pCzWXvI5FEN3EvO03sz/vAtbzbiYGl27XpOLVI81vCVjkZ0AW28RHxWZtPGa+kgj+SGIFt2tVeHKtCAgOjmKoH2L5vcEUBW4MSjLLkTr6FMSTitP/Vw30MVW+Je/J0Xb5ysZYWO/6x3oA1Esclpwbcm5Qmac908ZvB0krxnsFpm+TjJU84hke+77XVjIvGncEPZZysd8yhDCR1AitZbyzpLYPkpm6qhHRK1PtBvdypsFy1UxGD2oj5dqvfZu5SUT6YEDK0LW3GMag/IfuYyCcDsOQO777Hf1m/wo+oPfML4MYlpwqTR5Gn1W+CA+BRY8oGcG4OCmcpKRT8L9JGhQq3JybJJlw4IRsu7SrEWvxtLE3fs5WdEw04U95jr4tUcwplqLJ3PLsKanbmru1HLsnCgTs1ghSFLHKSZAPxTKHov6IBMEK8S2YaqJGX+NBwi0vCML5UBqNRbMcYUu/WGeiS0RCpZVUkBpnWKiBxV4U1DvS40bsycKBqEMjQ0rgWwaQZU6tBUQhsNx6Z647fTHdIJ6hIm+G1vLA0Y1rJxbMMHDnLikHjSqrYTnPjY3dPypxbo7iy1vNvLmj8su9d7oKPdGAvF0NvY6V4cqvwoRR4yITsOWQaCALHjCgeYyP6/76Q6b2C3utsUKQVecay96P5vitTcuPyeHHGnGEm6s4+J8oHwsAhx7iG0R7r4M3WfdrqeNFu7n9PffW6bxdyqmfwBqaYyKLFfWMKrg35vgSYPxEbRxwTNQtxG4R9BCP1d9sokyTHQHuryjK8vskVCr6ePEwNEJzEZx1DtkI+y77UxUwqfmX8nCl/Wez61jqrb8tfF1hHSowZRGwwMTIzNDU2Nzg5YWJjZGVmAGNvbnRleHQtPnNpemUgPCA2NAAvanNidGMvYy1jcnlwdG8vbWQ1LmMAbWQ1X2ZpbmFsAHZvaWQAYm9vbABjaGFyAHNpZ25lZCBjaGFyAHVuc2lnbmVkIGNoYXIAc2hvcnQAdW5zaWduZWQgc2hvcnQAaW50AHVuc2lnbmVkIGludABsb25nAHVuc2lnbmVkIGxvbmcAZmxvYXQAZG91YmxlAHN0ZDo6c3RyaW5nAHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AHN0ZDo6d3N0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBlbXNjcmlwdGVuOjp2YWwAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZG91YmxlPgBOU3QzX18yMTJiYXNpY19zdHJpbmdJY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQBOU3QzX18yMjFfX2Jhc2ljX3N0cmluZ19jb21tb25JTGIxRUVFAAAEFgAAmQ0AAIgWAABaDQAAAAAAAAEAAADADQAAAAAAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0loTlNfMTFjaGFyX3RyYWl0c0loRUVOU185YWxsb2NhdG9ySWhFRUVFAACIFgAA4A0AAAAAAAABAAAAwA0AAAAAAABOU3QzX18yMTJiYXNpY19zdHJpbmdJd05TXzExY2hhcl90cmFpdHNJd0VFTlNfOWFsbG9jYXRvckl3RUVFRQAAiBYAADgOAAAAAAAAAQAAAMANAAAAAAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAACIFgAAkA4AAAAAAAABAAAAwA0AAAAAAABOU3QzX18yMTJiYXNpY19zdHJpbmdJRGlOU18x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";
        if (!z($)) {
            var AA = $;
            $ = i.locateFile ? i.locateFile(AA, Q) : Q + AA
        }

        function iA() {
            try {
                if (h) return new Uint8Array(h);
                var A = oi($);
                if (A) return A;
                if (s) return s($);
                throw "both async and sync fetching of the wasm failed"
            } catch (A) {
                Z(A)
            }
        }

        function eA(A) {
            for (; 0 < A.length;) {
                var e = A.shift();
                if ("function" == typeof e) e(i);
                else {
                    var t = e.ya;
                    "number" == typeof t ? void 0 === e.ra ? d.get(t)() : d.get(t)(e.ra) : t(void 0 === e.ra ? null : e.ra)
                }
            }
        }

        function tA(A) {
            this.$ = A - 16, this.Ma = function(A) {
                q[this.$ + 8 >> 2] = A
            }, this.Ja = function(A) {
                q[this.$ + 0 >> 2] = A
            }, this.Ka = function() {
                q[this.$ + 4 >> 2] = 0
            }, this.Ia = function() {
                R[this.$ + 12 >> 0] = 0
            }, this.La = function() {
                R[this.$ + 13 >> 0] = 0
            }, this.Ca = function(A, i) {
                this.Ma(A), this.Ja(i), this.Ka(), this.Ia(), this.La()
            }
        }

        function IA() {
            return 0 < IA.ta
        }

        function gA(A) {
            switch (A) {
                case 1:
                    return 0;
                case 2:
                    return 1;
                case 4:
                    return 2;
                case 8:
                    return 3;
                default:
                    throw new TypeError("Unknown type size: " + A)
            }
        }
        var rA = void 0;

        function oA(A) {
            for (var i = ""; K[A];) i += rA[K[A++]];
            return i
        }
        var nA = {},
            BA = {},
            aA = {};

        function sA(A) {
            if (void 0 === A) return "_unknown";
            var i = (A = A.replace(/[^a-zA-Z0-9_]/g, "$")).charCodeAt(0);
            return 48 <= i && 57 >= i ? "_" + A : A
        }

        function EA(A, i) {
            return A = sA(A), new Function("body", "return function " + A + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(i)
        }

        function CA(A) {
            var i = Error,
                e = EA(A, (function(i) {
                    this.name = A, this.message = i, void 0 !== (i = Error(i).stack) && (this.stack = this.toString() + "\n" + i.replace(/^Error(:[^\n]*)?\n/, ""))
                }));
            return e.prototype = Object.create(i.prototype), e.prototype.constructor = e, e.prototype.toString = function() {
                return void 0 === this.message ? this.name : this.name + ": " + this.message
            }, e
        }
        var QA = void 0;

        function hA(A) {
            throw new QA(A)
        }
        var cA = void 0;

        function lA(A) {
            throw new cA(A)
        }

        function uA(A, i, e) {
            function t(i) {
                (i = e(i)).length !== A.length && lA("Mismatched type converter count");
                for (var t = 0; t < A.length; ++t) dA(A[t], i[t])
            }
            A.forEach((function(A) {
                aA[A] = i
            }));
            var I = Array(i.length),
                g = [],
                r = 0;
            i.forEach((function(A, i) {
                BA.hasOwnProperty(A) ? I[i] = BA[A] : (g.push(A), nA.hasOwnProperty(A) || (nA[A] = []), nA[A].push((function() {
                    I[i] = BA[A], ++r === g.length && t(I)
                })))
            })), 0 === g.length && t(I)
        }

        function dA(A, i, e) {
            if (e = e || {}, !("argPackAdvance" in i)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
            var t = i.name;
            if (A || hA('type "' + t + '" must have a positive integer typeid pointer'), BA.hasOwnProperty(A)) {
                if (e.Ba) return;
                hA("Cannot register type '" + t + "' twice")
            }
            BA[A] = i, delete aA[A], nA.hasOwnProperty(A) && (i = nA[A], delete nA[A], i.forEach((function(A) {
                A()
            })))
        }

        function pA(A) {
            return {
                count: A.count,
                ka: A.ka,
                ma: A.ma,
                $: A.$,
                ba: A.ba,
                ea: A.ea,
                fa: A.fa
            }
        }

        function fA(A) {
            hA(A.Z.ba.aa.name + " instance already deleted")
        }
        var yA = !1;

        function DA() {}

        function wA(A) {
            --A.count.value, 0 === A.count.value && (A.ea ? A.fa.ja(A.ea) : A.ba.aa.ja(A.$))
        }

        function kA(A) {
            return "undefined" == typeof FinalizationGroup ? (kA = function(A) {
                return A
            }, A) : (yA = new FinalizationGroup((function(A) {
                for (var i = A.next(); !i.done; i = A.next())(i = i.value).$ ? wA(i) : console.warn("object already deleted: " + i.$)
            })), DA = function(A) {
                yA.unregister(A.Z)
            }, (kA = function(A) {
                return yA.register(A, A.Z, A.Z), A
            })(A))
        }
        var mA = void 0,
            SA = [];

        function MA() {
            for (; SA.length;) {
                var A = SA.pop();
                A.Z.ka = !1, A.delete()
            }
        }

        function FA() {}
        var NA = {};

        function GA(A, i, e) {
            if (void 0 === A[i].da) {
                var t = A[i];
                A[i] = function() {
                    return A[i].da.hasOwnProperty(arguments.length) || hA("Function '" + e + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + A[i].da + ")!"), A[i].da[arguments.length].apply(this, arguments)
                }, A[i].da = [], A[i].da[t.oa] = t
            }
        }

        function RA(A, e, t) {
            i.hasOwnProperty(A) ? ((void 0 === t || void 0 !== i[A].da && void 0 !== i[A].da[t]) && hA("Cannot register public name '" + A + "' twice"), GA(i, A, A), i.hasOwnProperty(t) && hA("Cannot register multiple overloads of a function with the same number of arguments (" + t + ")!"), i[A].da[t] = e) : (i[A] = e, void 0 !== t && (i[A].Pa = t))
        }

        function KA(A, i, e, t, I, g, r, o) {
            this.name = A, this.constructor = i, this.la = e, this.ja = t, this.ga = I, this.za = g, this.na = r, this.xa = o, this.Ea = []
        }

        function vA(A, i, e) {
            for (; i !== e;) i.na || hA("Expected null or instance of " + e.name + ", got an instance of " + i.name), A = i.na(A), i = i.ga;
            return A
        }

        function HA(A, i) {
            return null === i ? (this.sa && hA("null is not a valid " + this.name), 0) : (i.Z || hA('Cannot pass "' + $A(i) + '" as a ' + this.name), i.Z.$ || hA("Cannot pass deleted object as a pointer of type " + this.name), vA(i.Z.$, i.Z.ba.aa, this.aa))
        }

        function qA(A, i) {
            if (null === i) {
                if (this.sa && hA("null is not a valid " + this.name), this.qa) {
                    var e = this.Fa();
                    return null !== A && A.push(this.ja, e), e
                }
                return 0
            }
            if (i.Z || hA('Cannot pass "' + $A(i) + '" as a ' + this.name), i.Z.$ || hA("Cannot pass deleted object as a pointer of type " + this.name), !this.pa && i.Z.ba.pa && hA("Cannot convert argument of type " + (i.Z.fa ? i.Z.fa.name : i.Z.ba.name) + " to parameter type " + this.name), e = vA(i.Z.$, i.Z.ba.aa, this.aa), this.qa) switch (void 0 === i.Z.ea && hA("Passing raw pointer to smart pointer is illegal"), this.Na) {
                case 0:
                    i.Z.fa === this ? e = i.Z.ea : hA("Cannot convert argument of type " + (i.Z.fa ? i.Z.fa.name : i.Z.ba.name) + " to parameter type " + this.name);
                    break;
                case 1:
                    e = i.Z.ea;
                    break;
                case 2:
                    if (i.Z.fa === this) e = i.Z.ea;
                    else {
                        var t = i.clone();
                        e = this.Ga(e, jA((function() {
                            t.delete()
                        }))), null !== A && A.push(this.ja, e)
                    }
                    break;
                default:
                    hA("Unsupporting sharing policy")
            }
            return e
        }

        function PA(A, i) {
            return null === i ? (this.sa && hA("null is not a valid " + this.name), 0) : (i.Z || hA('Cannot pass "' + $A(i) + '" as a ' + this.name), i.Z.$ || hA("Cannot pass deleted object as a pointer of type " + this.name), i.Z.ba.pa && hA("Cannot convert argument of type " + i.Z.ba.name + " to parameter type " + this.name), vA(i.Z.$, i.Z.ba.aa, this.aa))
        }

        function TA(A) {
            return this.fromWireType(P[A >> 2])
        }
        var JA = {};

        function UA(A, i) {
            return i.ba && i.$ || lA("makeClassHandle requires ptr and ptrType"), !!i.fa != !!i.ea && lA("Both smartPtrType and smartPtr must be specified"), i.count = {
                value: 1
            }, kA(Object.create(A, {
                Z: {
                    value: i
                }
            }))
        }

        function YA(A, i, e, t) {
            this.name = A, this.aa = i, this.sa = e, this.pa = t, this.qa = !1, this.ja = this.Ga = this.Fa = this.va = this.Na = this.Da = void 0, void 0 !== i.ga ? this.toWireType = qA : (this.toWireType = t ? HA : PA, this.ha = null)
        }

        function bA(A, e, t) {
            i.hasOwnProperty(A) || lA("Replacing nonexistant public symbol"), void 0 !== i[A].da && void 0 !== t ? i[A].da[t] = e : (i[A] = e, i[A].oa = t)
        }

        function xA(A, e) {
            var t = -1 != (A = oA(A)).indexOf("j") ? function(A, e) {
                f(0 <= A.indexOf("j"), "getDynCaller should only be called with i64 sigs");
                var t = [];
                return function() {
                    t.length = arguments.length;
                    for (var I = 0; I < arguments.length; I++) t[I] = arguments[I];
                    return -1 != A.indexOf("j") ? t && t.length ? i["dynCall_" + A].apply(null, [e].concat(t)) : i["dynCall_" + A].call(null, e) : d.get(e).apply(null, t)
                }
            }(A, e) : d.get(e);
            return "function" != typeof t && hA("unknown function pointer with signature " + A + ": " + e), t
        }
        var XA = void 0;

        function LA(A) {
            var i = oA(A = Ci(A));
            return si(A), i
        }

        function WA(A, i) {
            var e = [],
                t = {};
            throw i.forEach((function A(i) {
                t[i] || BA[i] || (aA[i] ? aA[i].forEach(A) : (e.push(i), t[i] = !0))
            })), new XA(A + ": " + e.map(LA).join([", "]))
        }

        function OA(A, i) {
            for (var e = [], t = 0; t < A; t++) e.push(q[(i >> 2) + t]);
            return e
        }

        function VA(A) {
            for (; A.length;) {
                var i = A.pop();
                A.pop()(i)
            }
        }

        function _A(A, i, e, t, I) {
            var g = i.length;
            2 > g && hA("argTypes array size mismatch! Must at least get return value and 'this' types!");
            var r = null !== i[1] && null !== e,
                o = !1;
            for (e = 1; e < i.length; ++e)
                if (null !== i[e] && void 0 === i[e].ha) {
                    o = !0;
                    break
                }
            var n = "void" !== i[0].name,
                B = "",
                a = "";
            for (e = 0; e < g - 2; ++e) B += (0 !== e ? ", " : "") + "arg" + e, a += (0 !== e ? ", " : "") + "arg" + e + "Wired";
            A = "return function " + sA(A) + "(" + B + ") {\nif (arguments.length !== " + (g - 2) + ") {\nthrowBindingError('function " + A + " called with ' + arguments.length + ' arguments, expected " + (g - 2) + " args!');\n}\n", o && (A += "var destructors = [];\n");
            var s = o ? "destructors" : "null";
            for (B = "throwBindingError invoker fn runDestructors retType classParam".split(" "), t = [hA, t, I, VA, i[0], i[1]], r && (A += "var thisWired = classParam.toWireType(" + s + ", this);\n"), e = 0; e < g - 2; ++e) A += "var arg" + e + "Wired = argType" + e + ".toWireType(" + s + ", arg" + e + "); // " + i[e + 2].name + "\n", B.push("argType" + e), t.push(i[e + 2]);
            if (r && (a = "thisWired" + (0 < a.length ? ", " : "") + a), A += (n ? "var rv = " : "") + "invoker(fn" + (0 < a.length ? ", " : "") + a + ");\n", o) A += "runDestructors(destructors);\n";
            else
                for (e = r ? 1 : 2; e < i.length; ++e) g = 1 === e ? "thisWired" : "arg" + (e - 2) + "Wired", null !== i[e].ha && (A += g + "_dtor(" + g + "); // " + i[e].name + "\n", B.push(g + "_dtor"), t.push(i[e].ha));
            return n && (A += "var ret = retType.fromWireType(rv);\nreturn ret;\n"), B.push(A + "}\n"),
                function(A) {
                    var i = Function;
                    if (!(i instanceof Function)) throw new TypeError("new_ called with constructor type " + typeof i + " which is not a function");
                    var e = EA(i.name || "unknownFunctionName", (function() {}));
                    return e.prototype = i.prototype, e = new e, (A = i.apply(e, A)) instanceof Object ? A : e
                }(B).apply(null, t)
        }
        var ZA = [],
            zA = [{}, {
                value: void 0
            }, {
                value: null
            }, {
                value: !0
            }, {
                value: !1
            }];

        function jA(A) {
            switch (A) {
                case void 0:
                    return 1;
                case null:
                    return 2;
                case !0:
                    return 3;
                case !1:
                    return 4;
                default:
                    var i = ZA.length ? ZA.pop() : zA.length;
                    return zA[i] = {
                        Ha: 1,
                        value: A
                    }, i
            }
        }

        function $A(A) {
            if (null === A) return "null";
            var i = typeof A;
            return "object" === i || "array" === i || "function" === i ? A.toString() : "" + A
        }

        function Ai(A, i) {
            switch (i) {
                case 2:
                    return function(A) {
                        return this.fromWireType(T[A >> 2])
                    };
                case 3:
                    return function(A) {
                        return this.fromWireType(J[A >> 3])
                    };
                default:
                    throw new TypeError("Unknown float type: " + A)
            }
        }

        function ii(A, i, e) {
            switch (i) {
                case 0:
                    return e ? function(A) {
                        return R[A]
                    } : function(A) {
                        return K[A]
                    };
                case 1:
                    return e ? function(A) {
                        return v[A >> 1]
                    } : function(A) {
                        return H[A >> 1]
                    };
                case 2:
                    return e ? function(A) {
                        return q[A >> 2]
                    } : function(A) {
                        return P[A >> 2]
                    };
                default:
                    throw new TypeError("Unknown integer type: " + A)
            }
        }
        for (var ei = [null, [],
                []
            ], ti = Array(256), Ii = 0; 256 > Ii; ++Ii) ti[Ii] = String.fromCharCode(Ii);
        rA = ti, QA = i.BindingError = CA("BindingError"), cA = i.InternalError = CA("InternalError"), FA.prototype.isAliasOf = function(A) {
            if (!(this instanceof FA && A instanceof FA)) return !1;
            var i = this.Z.ba.aa,
                e = this.Z.$,
                t = A.Z.ba.aa;
            for (A = A.Z.$; i.ga;) e = i.na(e), i = i.ga;
            for (; t.ga;) A = t.na(A), t = t.ga;
            return i === t && e === A
        }, FA.prototype.clone = function() {
            if (this.Z.$ || fA(this), this.Z.ma) return this.Z.count.value += 1, this;
            var A = kA(Object.create(Object.getPrototypeOf(this), {
                Z: {
                    value: pA(this.Z)
                }
            }));
            return A.Z.count.value += 1, A.Z.ka = !1, A
        }, FA.prototype.delete = function() {
            this.Z.$ || fA(this), this.Z.ka && !this.Z.ma && hA("Object already scheduled for deletion"), DA(this), wA(this.Z), this.Z.ma || (this.Z.ea = void 0, this.Z.$ = void 0)
        }, FA.prototype.isDeleted = function() {
            return !this.Z.$
        }, FA.prototype.deleteLater = function() {
            return this.Z.$ || fA(this), this.Z.ka && !this.Z.ma && hA("Object already scheduled for deletion"), SA.push(this), 1 === SA.length && mA && mA(MA), this.Z.ka = !0, this
        }, YA.prototype.Aa = function(A) {
            return this.va && (A = this.va(A)), A
        }, YA.prototype.ua = function(A) {
            this.ja && this.ja(A)
        }, YA.prototype.argPackAdvance = 8, YA.prototype.readValueFromPointer = TA, YA.prototype.deleteObject = function(A) {
            null !== A && A.delete()
        }, YA.prototype.fromWireType = function(A) {
            function i() {
                return this.qa ? UA(this.aa.la, {
                    ba: this.Da,
                    $: e,
                    fa: this,
                    ea: A
                }) : UA(this.aa.la, {
                    ba: this,
                    $: A
                })
            }
            var e = this.Aa(A);
            if (!e) return this.ua(A), null;
            var t = function(A, i) {
                for (void 0 === i && hA("ptr should not be undefined"); A.ga;) i = A.na(i), A = A.ga;
                return JA[i]
            }(this.aa, e);
            if (void 0 !== t) return 0 === t.Z.count.value ? (t.Z.$ = e, t.Z.ea = A, t.clone()) : (t = t.clone(), this.ua(A), t);
            if (t = this.aa.za(e), !(t = NA[t])) return i.call(this);
            t = this.pa ? t.wa : t.pointerType;
            var I = function A(i, e, t) {
                return e === t ? i : void 0 === t.ga ? null : null === (i = A(i, e, t.ga)) ? null : t.xa(i)
            }(e, this.aa, t.aa);
            return null === I ? i.call(this) : this.qa ? UA(t.aa.la, {
                ba: t,
                $: I,
                fa: this,
                ea: A
            }) : UA(t.aa.la, {
                ba: t,
                $: I
            })
        }, i.getInheritedInstanceCount = function() {
            return Object.keys(JA).length
        }, i.getLiveInheritedInstances = function() {
            var A, i = [];
            for (A in JA) JA.hasOwnProperty(A) && i.push(JA[A]);
            return i
        }, i.flushPendingDeletes = MA, i.setDelayFunction = function(A) {
            mA = A, SA.length && mA && mA(MA)
        }, XA = i.UnboundTypeError = CA("UnboundTypeError"), i.count_emval_handles = function() {
            for (var A = 0, i = 5; i < zA.length; ++i) void 0 !== zA[i] && ++A;
            return A
        }, i.get_first_emval = function() {
            for (var A = 5; A < zA.length; ++A)
                if (void 0 !== zA[A]) return zA[A];
            return null
        };
        var gi = !1,
            ri = "function" == typeof atob ? atob : function(A) {
                var i = "",
                    e = 0;
                A = A.replace(/[^A-Za-z0-9\+\/=]/g, "");
                do {
                    var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(A.charAt(e++)),
                        I = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(A.charAt(e++)),
                        g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(A.charAt(e++)),
                        r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(A.charAt(e++));
                    t = t << 2 | I >> 4, I = (15 & I) << 4 | g >> 2;
                    var o = (3 & g) << 6 | r;
                    i += String.fromCharCode(t), 64 !== g && (i += String.fromCharCode(I)), 64 !== r && (i += String.fromCharCode(o))
                } while (e < A.length);
                return i
            };

        function oi(A) {
            if (z(A)) {
                if (A = A.slice(j.length), "boolean" == typeof n && n) {
                    try {
                        var i = Buffer.from(A, "base64")
                    } catch (e) {
                        i = new Buffer(A, "base64")
                    }
                    var e = new Uint8Array(i.buffer, i.byteOffset, i.byteLength)
                } else try {
                    var t = ri(A),
                        I = new Uint8Array(t.length);
                    for (i = 0; i < t.length; ++i) I[i] = t.charCodeAt(i);
                    e = I
                } catch (A) {
                    throw Error("Converting base64 string to bytes failed.")
                }
                return e
            }
        }
        x.push({
            ya: function() {
                Bi()
            }
        });
        var ni = {
            e: function(A, i, e, t) {
                Z("Assertion failed: " + (A ? D(K, A, void 0) : "") + ", at: " + [i ? i ? D(K, i, void 0) : "" : "unknown filename", e, t ? t ? D(K, t, void 0) : "" : "unknown function"])
            },
            p: function(A) {
                return ai(A + 16) + 16
            },
            o: function(A, i, e) {
                throw new tA(A).Ca(i, e), "uncaught_exception" in IA ? IA.ta++ : IA.ta = 1, A
            },
            b: d,
            m: function(A, i, e, t, I) {
                var g = gA(e);
                dA(A, {
                    name: i = oA(i),
                    fromWireType: function(A) {
                        return !!A
                    },
                    toWireType: function(A, i) {
                        return i ? t : I
                    },
                    argPackAdvance: 8,
                    readValueFromPointer: function(A) {
                        if (1 === e) var t = R;
                        else if (2 === e) t = v;
                        else {
                            if (4 !== e) throw new TypeError("Unknown boolean type size: " + i);
                            t = q
                        }
                        return this.fromWireType(t[A >> g])
                    },
                    ha: null
                })
            },
            w: function(A, i, e, t, I, g, r, o, n, B, a, s, E) {
                a = oA(a), g = xA(I, g), o && (o = xA(r, o)), B && (B = xA(n, B)), E = xA(s, E);
                var C = sA(a);
                RA(C, (function() {
                    WA("Cannot construct " + a + " due to unbound types", [t])
                })), uA([A, i, e], t ? [t] : [], (function(i) {
                    if (i = i[0], t) var e = i.aa,
                        I = e.la;
                    else I = FA.prototype;
                    i = EA(C, (function() {
                        if (Object.getPrototypeOf(this) !== r) throw new QA("Use 'new' to construct " + a);
                        if (void 0 === n.ia) throw new QA(a + " has no accessible constructor");
                        var A = n.ia[arguments.length];
                        if (void 0 === A) throw new QA("Tried to invoke ctor of " + a + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(n.ia).toString() + ") parameters instead!");
                        return A.apply(this, arguments)
                    }));
                    var r = Object.create(I, {
                        constructor: {
                            value: i
                        }
                    });
                    i.prototype = r;
                    var n = new KA(a, i, r, E, e, g, o, B);
                    e = new YA(a, n, !0, !1), I = new YA(a + "*", n, !1, !1);
                    var s = new YA(a + " const*", n, !1, !0);
                    return NA[A] = {
                        pointerType: I,
                        wa: s
                    }, bA(C, i), [e, I, s]
                }))
            },
            r: function(A, i, e, t, I, g) {
                f(0 < i);
                var r = OA(i, e);
                I = xA(t, I);
                var o = [g],
                    n = [];
                uA([], [A], (function(A) {
                    var e = "constructor " + (A = A[0]).name;
                    if (void 0 === A.aa.ia && (A.aa.ia = []), void 0 !== A.aa.ia[i - 1]) throw new QA("Cannot register multiple constructors with identical number of parameters (" + (i - 1) + ") for class '" + A.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
                    return A.aa.ia[i - 1] = function() {
                        WA("Cannot construct " + A.name + " due to unbound types", r)
                    }, uA([], r, (function(t) {
                        return A.aa.ia[i - 1] = function() {
                            arguments.length !== i - 1 && hA(e + " called with " + arguments.length + " arguments, expected " + (i - 1)), n.length = 0, o.length = i;
                            for (var A = 1; A < i; ++A) o[A] = t[A].toWireType(n, arguments[A - 1]);
                            return A = I.apply(null, o), VA(n), t[0].fromWireType(A)
                        }, []
                    })), []
                }))
            },
            f: function(A, i, e, t, I, g, r, o) {
                var n = OA(e, t);
                i = oA(i), g = xA(I, g), uA([], [A], (function(A) {
                    function t() {
                        WA("Cannot call " + I + " due to unbound types", n)
                    }
                    var I = (A = A[0]).name + "." + i;
                    o && A.aa.Ea.push(i);
                    var B = A.aa.la,
                        a = B[i];
                    return void 0 === a || void 0 === a.da && a.className !== A.name && a.oa === e - 2 ? (t.oa = e - 2, t.className = A.name, B[i] = t) : (GA(B, i, I), B[i].da[e - 2] = t), uA([], n, (function(t) {
                        return t = _A(I, t, A, g, r), void 0 === B[i].da ? (t.oa = e - 2, B[i] = t) : B[i].da[e - 2] = t, []
                    })), []
                }))
            },
            v: function(A, i) {
                dA(A, {
                    name: i = oA(i),
                    fromWireType: function(A) {
                        var i = zA[A].value;
                        return 4 < A && 0 == --zA[A].Ha && (zA[A] = void 0, ZA.push(A)), i
                    },
                    toWireType: function(A, i) {
                        return jA(i)
                    },
                    argPackAdvance: 8,
                    readValueFromPointer: TA,
                    ha: null
                })
            },
            l: function(A, i, e) {
                e = gA(e), dA(A, {
                    name: i = oA(i),
                    fromWireType: function(A) {
                        return A
                    },
                    toWireType: function(A, i) {
                        if ("number" != typeof i && "boolean" != typeof i) throw new TypeError('Cannot convert "' + $A(i) + '" to ' + this.name);
                        return i
                    },
                    argPackAdvance: 8,
                    readValueFromPointer: Ai(i, e),
                    ha: null
                })
            },
            x: function(A, i, e, t, I, g) {
                var r = OA(i, e);
                A = oA(A), I = xA(t, I), RA(A, (function() {
                    WA("Cannot call " + A + " due to unbound types", r)
                }), i - 1), uA([], r, (function(e) {
                    return e = [e[0], null].concat(e.slice(1)), bA(A, _A(A, e, null, I, g), i - 1), []
                }))
            },
            d: function(A, i, e, t, I) {
                function g(A) {
                    return A
                }
                i = oA(i), -1 === I && (I = 4294967295);
                var r = gA(e);
                if (0 === t) {
                    var o = 32 - 8 * e;
                    g = function(A) {
                        return A << o >>> o
                    }
                }
                var n = -1 != i.indexOf("unsigned");
                dA(A, {
                    name: i,
                    fromWireType: g,
                    toWireType: function(A, e) {
                        if ("number" != typeof e && "boolean" != typeof e) throw new TypeError('Cannot convert "' + $A(e) + '" to ' + this.name);
                        if (e < t || e > I) throw new TypeError('Passing a number "' + $A(e) + '" from JS side to C/C++ side to an argument of type "' + i + '", which is outside the valid range [' + t + ", " + I + "]!");
                        return n ? e >>> 0 : 0 | e
                    },
                    argPackAdvance: 8,
                    readValueFromPointer: ii(i, r, 0 !== t),
                    ha: null
                })
            },
            c: function(A, i, e) {
                function t(A) {
                    return new I(G, P[1 + (A >>= 2)], P[A])
                }
                var I = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][i];
                dA(A, {
                    name: e = oA(e),
                    fromWireType: t,
                    argPackAdvance: 8,
                    readValueFromPointer: t
                }, {
                    Ba: !0
                })
            },
            i: function(A, i) {
                var e = "std::string" === (i = oA(i));
                dA(A, {
                    name: i,
                    fromWireType: function(A) {
                        var i = P[A >> 2];
                        if (e)
                            for (var t = A + 4, I = 0; I <= i; ++I) {
                                var g = A + 4 + I;
                                if (I == i || 0 == K[g]) {
                                    if (t = t ? D(K, t, g - t) : "", void 0 === r) var r = t;
                                    else r += String.fromCharCode(0), r += t;
                                    t = g + 1
                                }
                            } else {
                                for (r = Array(i), I = 0; I < i; ++I) r[I] = String.fromCharCode(K[A + 4 + I]);
                                r = r.join("")
                            }
                        return si(A), r
                    },
                    toWireType: function(A, i) {
                        i instanceof ArrayBuffer && (i = new Uint8Array(i));
                        var t = "string" == typeof i;
                        t || i instanceof Uint8Array || i instanceof Uint8ClampedArray || i instanceof Int8Array || hA("Cannot pass non-string to std::string");
                        var I = (e && t ? function() {
                                for (var A = 0, e = 0; e < i.length; ++e) {
                                    var t = i.charCodeAt(e);
                                    55296 <= t && 57343 >= t && (t = 65536 + ((1023 & t) << 10) | 1023 & i.charCodeAt(++e)), 127 >= t ? ++A : A = 2047 >= t ? A + 2 : 65535 >= t ? A + 3 : A + 4
                                }
                                return A
                            } : function() {
                                return i.length
                            })(),
                            g = ai(4 + I + 1);
                        if (P[g >> 2] = I, e && t) ! function(A, i, e) {
                            var t = K;
                            if (0 < e) {
                                e = i + e - 1;
                                for (var I = 0; I < A.length; ++I) {
                                    var g = A.charCodeAt(I);
                                    if (55296 <= g && 57343 >= g && (g = 65536 + ((1023 & g) << 10) | 1023 & A.charCodeAt(++I)), 127 >= g) {
                                        if (i >= e) break;
                                        t[i++] = g
                                    } else {
                                        if (2047 >= g) {
                                            if (i + 1 >= e) break;
                                            t[i++] = 192 | g >> 6
                                        } else {
                                            if (65535 >= g) {
                                                if (i + 2 >= e) break;
                                                t[i++] = 224 | g >> 12
                                            } else {
                                                if (i + 3 >= e) break;
                                                t[i++] = 240 | g >> 18, t[i++] = 128 | g >> 12 & 63
                                            }
                                            t[i++] = 128 | g >> 6 & 63
                                        }
                                        t[i++] = 128 | 63 & g
                                    }
                                }
                                t[i] = 0
                            }
                        }(i, g + 4, I + 1);
                        else if (t)
                            for (t = 0; t < I; ++t) {
                                var r = i.charCodeAt(t);
                                255 < r && (si(g), hA("String has UTF-16 code units that do not fit in 8 bits")), K[g + 4 + t] = r
                            } else
                                for (t = 0; t < I; ++t) K[g + 4 + t] = i[t];
                        return null !== A && A.push(si, g), g
                    },
                    argPackAdvance: 8,
                    readValueFromPointer: TA,
                    ha: function(A) {
                        si(A)
                    }
                })
            },
            h: function(A, i, e) {
                if (e = oA(e), 2 === i) var t = k,
                    I = m,
                    g = S,
                    r = function() {
                        return H
                    },
                    o = 1;
                else 4 === i && (t = M, I = F, g = N, r = function() {
                    return P
                }, o = 2);
                dA(A, {
                    name: e,
                    fromWireType: function(A) {
                        for (var e, I = P[A >> 2], g = r(), n = A + 4, B = 0; B <= I; ++B) {
                            var a = A + 4 + B * i;
                            B != I && 0 != g[a >> o] || (n = t(n, a - n), void 0 === e ? e = n : (e += String.fromCharCode(0), e += n), n = a + i)
                        }
                        return si(A), e
                    },
                    toWireType: function(A, t) {
                        "string" != typeof t && hA("Cannot pass non-string to C++ string type " + e);
                        var r = g(t),
                            n = ai(4 + r + i);
                        return P[n >> 2] = r >> o, I(t, n + 4, r + i), null !== A && A.push(si, n), n
                    },
                    argPackAdvance: 8,
                    readValueFromPointer: TA,
                    ha: function(A) {
                        si(A)
                    }
                })
            },
            n: function(A, i) {
                dA(A, {
                    Oa: !0,
                    name: i = oA(i),
                    argPackAdvance: 0,
                    fromWireType: function() {},
                    toWireType: function() {}
                })
            },
            g: function() {
                Z()
            },
            s: function(A, i, e) {
                K.copyWithin(A, i, i + e)
            },
            t: function() {
                Z("OOM")
            },
            u: function() {
                return 0
            },
            q: function() {},
            k: function(A, i, e, t) {
                for (var I = 0, g = 0; g < e; g++) {
                    for (var r = q[i + 8 * g >> 2], o = q[i + (8 * g + 4) >> 2], n = 0; n < o; n++) {
                        var B = K[r + n],
                            a = ei[A];
                        0 === B || 10 === B ? ((1 === A ? c : l)(D(a, 0)), a.length = 0) : a.push(B)
                    }
                    I += o
                }
                return q[t >> 2] = I, 0
            },
            a: u,
            j: function() {}
        };
        ! function() {
            function A(A) {
                i.asm = A.exports, O--, i.monitorRunDependencies && i.monitorRunDependencies(O), 0 == O && (null !== V && (clearInterval(V), V = null), _ && (A = _, _ = null, A()))
            }

            function e(i) {
                A(i.instance)
            }

            function t(A) {
                return (h || !r && !o || "function" != typeof fetch ? Promise.resolve().then(iA) : fetch($, {
                    credentials: "same-origin"
                }).then((function(A) {
                    if (!A.ok) throw "failed to load wasm binary file at '" + $ + "'";
                    return A.arrayBuffer()
                })).catch((function() {
                    return iA()
                }))).then((function(A) {
                    return WebAssembly.instantiate(A, I)
                })).then(A, (function(A) {
                    l("failed to asynchronously prepare wasm: " + A), Z(A)
                }))
            }
            var I = {
                a: ni
            };
            if (O++, i.monitorRunDependencies && i.monitorRunDependencies(O), i.instantiateWasm) try {
                return i.instantiateWasm(I, A)
            } catch (A) {
                return l("Module.instantiateWasm callback failed with error: " + A), !1
            }! function() {
                if (h || "function" != typeof WebAssembly.instantiateStreaming || z($) || "function" != typeof fetch) return t(e);
                fetch($, {
                    credentials: "same-origin"
                }).then((function(A) {
                    return WebAssembly.instantiateStreaming(A, I).then(e, (function(A) {
                        return l("wasm streaming compile failed: " + A), l("falling back to ArrayBuffer instantiation"), t(e)
                    }))
                }))
            }()
        }();
        var Bi = i.___wasm_call_ctors = function() {
            return (Bi = i.___wasm_call_ctors = i.asm.y).apply(null, arguments)
        };
        i._siphash = function() {
            return (i._siphash = i.asm.z).apply(null, arguments)
        }, i._DecodeBase58 = function() {
            return (i._DecodeBase58 = i.asm.A).apply(null, arguments)
        }, i._EncodeBase58 = function() {
            return (i._EncodeBase58 = i.asm.B).apply(null, arguments)
        }, i.__ripemd160 = function() {
            return (i.__ripemd160 = i.asm.C).apply(null, arguments)
        }, i._hmac_sha512_oneline = function() {
            return (i._hmac_sha512_oneline = i.asm.D).apply(null, arguments)
        }, i._pbkdf2_hmac_sha512 = function() {
            return (i._pbkdf2_hmac_sha512 = i.asm.E).apply(null, arguments)
        };
        var ai = i._malloc = function() {
                return (ai = i._malloc = i.asm.F).apply(null, arguments)
            },
            si = i._free = function() {
                return (si = i._free = i.asm.G).apply(null, arguments)
            };
        i._md5sum = function() {
            return (i._md5sum = i.asm.H).apply(null, arguments)
        }, i._secp256k1_context_create = function() {
            return (i._secp256k1_context_create = i.asm.I).apply(null, arguments)
        }, i._secp256k1_ec_pubkey_parse = function() {
            return (i._secp256k1_ec_pubkey_parse = i.asm.J).apply(null, arguments)
        }, i._secp256k1_ec_pubkey_serialize = function() {
            return (i._secp256k1_ec_pubkey_serialize = i.asm.K).apply(null, arguments)
        }, i._secp256k1_ecdsa_signature_parse_der = function() {
            return (i._secp256k1_ecdsa_signature_parse_der = i.asm.L).apply(null, arguments)
        }, i._secp256k1_ecdsa_signature_serialize_der = function() {
            return (i._secp256k1_ecdsa_signature_serialize_der = i.asm.M).apply(null, arguments)
        }, i._secp256k1_ecdsa_signature_serialize_compact = function() {
            return (i._secp256k1_ecdsa_signature_serialize_compact = i.asm.N).apply(null, arguments)
        }, i._secp256k1_ecdsa_verify = function() {
            return (i._secp256k1_ecdsa_verify = i.asm.O).apply(null, arguments)
        }, i._secp256k1_ec_pubkey_create = function() {
            return (i._secp256k1_ec_pubkey_create = i.asm.P).apply(null, arguments)
        }, i._secp256k1_ec_pubkey_tweak_add = function() {
            return (i._secp256k1_ec_pubkey_tweak_add = i.asm.Q).apply(null, arguments)
        }, i._secp256k1_context_randomize = function() {
            return (i._secp256k1_context_randomize = i.asm.R).apply(null, arguments)
        }, i._secp256k1_ecdsa_recoverable_signature_parse_compact = function() {
            return (i._secp256k1_ecdsa_recoverable_signature_parse_compact = i.asm.S).apply(null, arguments)
        }, i._secp256k1_ecdsa_recoverable_signature_serialize_compact = function() {
            return (i._secp256k1_ecdsa_recoverable_signature_serialize_compact = i.asm.T).apply(null, arguments)
        }, i._secp256k1_ecdsa_sign_recoverable = function() {
            return (i._secp256k1_ecdsa_sign_recoverable = i.asm.U).apply(null, arguments)
        }, i._secp256k1_ecdsa_recover = function() {
            return (i._secp256k1_ecdsa_recover = i.asm.V).apply(null, arguments)
        };
        var Ei, Ci = i.___getTypeName = function() {
            return (Ci = i.___getTypeName = i.asm.W).apply(null, arguments)
        };

        function Qi() {
            function A() {
                if (!Ei && (Ei = !0, i.calledRun = !0, !p)) {
                    if (eA(x), eA(X), t(i), i.onRuntimeInitialized && i.onRuntimeInitialized(), i.postRun)
                        for ("function" == typeof i.postRun && (i.postRun = [i.postRun]); i.postRun.length;) {
                            var A = i.postRun.shift();
                            L.unshift(A)
                        }
                    eA(L)
                }
            }
            if (!(0 < O)) {
                if (i.preRun)
                    for ("function" == typeof i.preRun && (i.preRun = [i.preRun]); i.preRun.length;) W();
                eA(b), 0 < O || (i.setStatus ? (i.setStatus("Running..."), setTimeout((function() {
                    setTimeout((function() {
                        i.setStatus("")
                    }), 1), A()
                }), 1)) : A())
            }
        }
        if (i.___embind_register_native_and_builtin_types = function() {
                return (i.___embind_register_native_and_builtin_types = i.asm.X).apply(null, arguments)
            }, i.dynCall_jiji = function() {
                return (i.dynCall_jiji = i.asm.Y).apply(null, arguments)
            }, i.getValue = function(A, i) {
                switch ("*" === (i = i || "i8").charAt(i.length - 1) && (i = "i32"), i) {
                    case "i1":
                    case "i8":
                        return R[A >> 0];
                    case "i16":
                        return v[A >> 1];
                    case "i32":
                    case "i64":
                        return q[A >> 2];
                    case "float":
                        return T[A >> 2];
                    case "double":
                        return J[A >> 3];
                    default:
                        Z("invalid type for getValue: " + i)
                }
                return null
            }, _ = function A() {
                Ei || Qi(), Ei || (_ = A)
            }, i.run = Qi, i.preInit)
            for ("function" == typeof i.preInit && (i.preInit = [i.preInit]); 0 < i.preInit.length;) i.preInit.pop()();
        return Qi(), A.ready
    });
    "object" == typeof i && "object" == typeof A ? A.exports = t : "function" == typeof define && define.amd ? define([], (function() {
        return t
    })) : "object" == typeof i && (i.Module = t)
}, function(A, i, e) {
    const t = e(24),
        I = e(23),
        g = e(22),
        r = e(14),
        o = e(13),
        n = e(12),
        B = e(11),
        a = e(10),
        s = e(9),
        E = e(8),
        C = e(7),
        Q = e(6),
        h = e(5),
        c = e(4),
        l = e(3),
        u = e(2);
    A.exports = {
        __initTask: null,
        asyncInit: async function(A) {
            null === this.__initTask ? this.__initTask = await this.__asyncInit(A) : "completed" !== this.__initTask && await this.__initTask
        },
        __asyncInit: async function(A) {
            void 0 === A && (A = this), g(A), I(A), r(A), A.__bitcoin_core_crypto = await this.__initCryptoModule(), o(A), n(A), s(A), a(A), B(A), A.secp256k1PrecompContextSign = A.__bitcoin_core_crypto.module._secp256k1_context_create(A.SECP256K1_CONTEXT_SIGN), A.secp256k1PrecompContextVerify = A.__bitcoin_core_crypto.module._secp256k1_context_create(A.SECP256K1_CONTEXT_VERIFY);
            let i = A.generateEntropy({
                    hex: !1
                }),
                e = A.__bitcoin_core_crypto.module._malloc(i.length);
            A.__bitcoin_core_crypto.module.HEAPU8.set(i, e), A.__bitcoin_core_crypto.module._secp256k1_context_randomize(A.secp256k1PrecompContextSign, e), E(A), C(A), Q(A), h(A), c(A), l(A), u(A), this.__initTask = "completed"
        },
        __initCryptoModule: () => new Promise((function(A) {
            t().then(i => {
                A({
                    module: i
                })
            })
        }))
    }
}]);